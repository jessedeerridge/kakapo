<!DOCTYPE html> 
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ã‚¶ãƒ»ã‚«ã‚«ãƒ</title>
<style>
  :root{
    --card-w: 56px;                 /* è‡ªåˆ†ã®æ‰‹æœ­ã‚«ãƒ¼ãƒ‰å¹…ï¼ˆè¡¨é¢ãƒ¬ãƒ³ãƒ€ï¼‰ */
    --card-w-opp: calc(64px * .4);  /* ç›¸æ‰‹ã®è£é¢ã‚«ãƒ¼ãƒ‰å¹…ï¼ˆè‡ªåˆ†ã®ç´„40%ï¼‰ */
    --card-r: 10px;
    --card-r-opp: 4px;              /* ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è§’ä¸¸ã‚’æŠ‘ãˆã‚‹ */
    --gap: 10px;
    --hand-h: 104px;                /* ç”»é¢ä¸‹ã®æ‰‹æœ­ãƒãƒ¼é«˜ã•ç›®å®‰ */

    /* ç›¸æ‰‹ã‚¨ãƒªã‚¢ã‚’å¤–å´ã¸å¯„ã›ã‚‹é‡ï¼ˆã¾ã¨ã‚ã¦èª¿æ•´ï¼‰ */
    --opp-shift: 28px;

    /* 40æšã‚«ãƒ¼ãƒ‰ã®å†…å´æ ¼å­ */
    --grid-gap: 2px;                /* ã‚»ãƒ«é–“éš”ï¼ˆpxï¼‰ */
    --radius: 8px;                  /* ã‚«ãƒ¼ãƒ‰å†…å´ã®ä¸¸ã¿ */
    --paper: #fff;                  /* è¡¨é¢ã®ç´™è‰² */
  }

  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#fff;color:#111}
  header{display:flex;justify-content:space-between;align-items:center;padding:12px;border-bottom:1px solid #eee;gap:12px}
  h1{margin:0;font-size:18px}
  .small{font-size:12px;opacity:.85;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .copybtn{padding:6px 10px;border:1px solid #ddd;border-radius:10px;background:#f7f7f7;cursor:pointer}
  main{padding:14px;display:grid;gap:16px;max-width:1100px;margin:0 auto; padding-bottom: calc(var(--hand-h) + 24px);}

  .join-box{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .join-box input{padding:10px;border:1px solid #ddd;border-radius:8px;font-size:16px}
  .btn{padding:10px 14px;border:1px solid #ddd;border-radius:10px;background:#111;color:#fff;cursor:pointer}
  .btn.ghost{background:#f7f7f7;color:#111}
  .btn.sm{padding:6px 10px;border-radius:8px}
  .hidden{display:none !important}
  .muted{opacity:.7; font-size:13px}

  /* ====== ãƒœãƒˆãƒ ã‚·ãƒ¼ãƒˆ ====== */
  .bsheet{position:fixed; inset:0; z-index:60; display:flex; flex-direction:column; justify-content:flex-end;}
  .bsheet.hidden{display:none !important}
  .bsheet .backdrop{position:absolute; inset:0; background:rgba(0,0,0,.24);}
  .bsheet .panel{
    position:relative; background:rgba(255,255,255,.98);
    border-top-left-radius:16px; border-top-right-radius:16px;
    border-top:1px solid #eee; box-shadow:0 -10px 30px rgba(0,0,0,.12);
    padding:10px 12px; animation:slideUp .16s ease-out;
    width:min(420px, calc(100vw - 32px));
    margin:0 auto 0;
  }
  @keyframes slideUp{from{transform:translateY(12px); opacity:.96} to{transform:translateY(0); opacity:1}}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:center; margin:8px 0;}
  .row.head{justify-content:space-between}
  .row .title{font-weight:700}
  .seg{display:flex; gap:8px; flex-wrap:wrap; justify-content:center}
  .seg .segbtn{
    min-width:56px; padding:8px 12px; border-radius:999px; cursor:pointer;
    border:1px solid #ddd; background:#f7f7f7; font-weight:600;
  }
  .seg .segbtn.active{background:#111; color:#fff; border-color:#111;}
  .seatbtn{
    min-width:56px; padding:10px 14px; border-radius:12px; cursor:pointer;
    border:1px solid #ddd; background:#f7f7f7;
  }
  .seatbtn.me{ background:#111; color:#fff; border-color:#111; }
  .seatbtn[disabled]{ opacity:.5; cursor:not-allowed; text-decoration:line-through; }

  /* å³ä¸‹ï¼šè¨­å®š(FAB) */
  .fab{
    position:fixed; right:16px; bottom:16px; z-index:70;
    width:48px; height:48px; border-radius:50%;
    display:flex; align-items:center; justify-content:center;
    background:#111; color:#fff; border:1px solid #000; cursor:pointer;
    box-shadow:0 6px 18px rgba(0,0,0,.2);
  }

  /* ãƒ†ãƒ¼ãƒ–ãƒ«ï¼†å ´é…ç½® */
  .table-area{ position:relative; min-height:420px; border:none; border-radius:0; padding:0; overflow:visible; }
  .badge{display:inline-block;padding:2px 8px;border-radius:999px;background:#111;color:#fff;font-size:12px}

  /* ç›¸æ‰‹ã‚¨ãƒªã‚¢ï¼ˆ3äººã¨ã‚‚åŒã˜å½¢ãƒ»åŒã˜å‘ãï¼‰ */
  .opp{ position:absolute; width:240px; height:180px; display:block; }
  .opp.A{left: calc(-150px - var(--opp-shift)); top:70%; transform:translateY(-50%);} /* å·¦ */
  .opp.B{right:calc(-150px - var(--opp-shift)); top:70%; transform:translateY(-50%);} /* å³ */
  .opp.C{left:50%; top: calc(30px - var(--opp-shift)); transform:translateX(-50%);}    /* ä¸Š */

  .opp .label{position:absolute; left:50%; top:4px; transform:translateX(-50%); font-weight:700; font-size:12px; opacity:.7}
  /* ç›¸æ‰‹ã‚¨ãƒªã‚¢ã®åå‰ãƒãƒƒã‚¸ã‚’è–„ãƒ™ãƒ¼ã‚¸ãƒ¥ï¼‹é»’å­—ï¼‹ç‚¹ç·šæ ã« */
  .opp .badge{
    background: #f6f0e6;   /* è–„ãƒ™ãƒ¼ã‚¸ãƒ¥ */
    color: #111;           /* é»’å­— */
    border: 2px dashed #333;  /* â† ç ´ç·šã«å¤‰æ›´ */
    border-radius: 10px;
    padding: 4px 10px;
    font-weight: 700;
    font-size: 12px;
  }
  .opp .badge{position:absolute; left:50%; bottom:165px; transform:translateX(-50%);} /* åå‰ãƒãƒƒã‚¸ */

  /* æ‰‡ã®åœŸå°ï¼ˆå…¨å“¡â€œä¸Šå‘ãâ€ã§çµ±ä¸€ï¼‰ */
  .fan{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:0; height:0; }
  .fan .card.opp{
    position:absolute; left:0; top:0;
    width: var(--card-w-opp);
    height: calc(var(--card-w-opp) / 0.714); /* 2.5 : 3.5 æ¯” */
    border:1px solid #ddd; border-radius: var(--card-r-opp);
background: url("kakapocardback.jpg") center/cover no-repeat;
    transform-origin:50% 100%; will-change: transform; backface-visibility: hidden; transform: translateZ(0);
    pointer-events:none;
  }

  /* è‡ªåˆ†ã®æ‰‹æœ­ãƒãƒ¼ */
  .handbar{
    position:fixed; left:0; right:0; bottom: calc(env(safe-area-inset-bottom) + 0px);
    z-index:40; display:flex; gap:8px; flex-wrap:wrap; justify-content:center;
    padding:10px 12px 14px; background:linear-gradient(to bottom, rgba(255,255,255,.0), rgba(255,255,255,.7) 40%, rgba(255,255,255,.95));
    backdrop-filter: blur(2px); min-height: var(--hand-h);
  }
  /* æ—§ æ‰‹ç•ªãƒ©ã‚¤ãƒ³ã¯ä½¿ã‚ãªã„ï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼ã®ã¿è¡¨ç¤ºï¼‰ */
  .handbar .topline{ display:none; }

  /* æ±ç”¨ã‚«ãƒ¼ãƒ‰ç®±ï¼ˆè‡ªåˆ†/å ´ã®è¡¨é¢ï¼‰ */
  .cardbox{ width:var(--card-w); aspect-ratio: 63.5 / 88.9; display:flex; align-items:center; justify-content:center; }
  .clickable{ cursor:pointer; }
  .unplayable{ opacity:.35; filter:grayscale(60%); pointer-events:none; }

  /* â€œå ´â€ã‚¹ãƒ­ãƒƒãƒˆ */
  .play-slot{ position:absolute; display:flex; align-items:center; justify-content:center; z-index:4; }
  .play-mine-fixed{ position:fixed; left:50%; bottom: calc(var(--hand-h) + 3px); transform:translateX(-50%); z-index:45; display:flex; align-items:center; justify-content:center; pointer-events:none; }
  .play-A{ left: calc(70px - var(--opp-shift)); top:60%; transform:translateY(-50%);}  /* å·¦ã®å ´ */
  .play-B{ right:calc(40px - var(--opp-shift)); top:60%; transform:translateY(-50%);} /* å³ã®å ´ */
  .play-C{ left:50%; top:  calc(110px - var(--opp-shift)); transform:translate(-50%, 0);}   /* ä¸Šã®å ´ */
  .played.winner .cardbox{ transform: scale(1.2); transform-origin:center; }

  .hostbar{ display:none; }

  /* ========= 40æšã‚«ãƒ¼ãƒ‰ã®è¡¨é¢ã‚¹ã‚¿ã‚¤ãƒ« ========= */
  .face{ position:relative; width: 100%; height: 100%; background:var(--paper); border:2px solid var(--color, #999); border-radius: var(--radius); padding: 10px; box-shadow: 0 2px 10px rgba(0,0,0,.06); color: var(--color, #666); display:flex; justify-content:center; align-items:center; overflow:hidden; }

  /* ãƒ”ãƒ¼ã‚¹èƒŒå¾Œã®æ–œã‚æ¥•å†† */
  .ovalBG{
    position:absolute; left:50%; top:50%;
    width:72%; height:64%;
    transform:translate(-50%,-50%) rotate(18deg);
    background: currentColor;
    border-radius: 42% / 58%;
    pointer-events:none;
    z-index:0;
  }

  .num{ position:absolute; font-weight:800; font-size:14px; line-height:1; color: var(--color, #666); user-select:none; }
  .tl{ top:4px; left:4px; } .tr{ top:4px; right:4px; } .bl{ bottom:4px; left:4px; transform: rotate(180deg); } .br{ bottom:4px; right:4px; transform: rotate(180deg); }

  .grid{ display:grid; grid-template-columns: repeat(var(--cols), 1fr); grid-auto-rows: 1fr; gap: 0; width: 90%; aspect-ratio: calc(var(--cols)) / calc(var(--rows)); background: transparent; will-change: transform; }
  .cell{ width:100%; height:100%; background: transparent; }
  .cell.filled{ background: currentColor; border-radius: 0; box-shadow: inset 0 0 0 1px #fff; }

  /* è‰²ãƒ†ãƒ¼ãƒï¼ˆcurrentColor ç”¨ï¼‰ */
  .red   { --color:#e53935; color:#e53935; }
  .blue  { --color:#1e88e5; color:#1e88e5; }
  .green { --color:#43a047; color:#43a047; }
  .yellow{ --color:#fdd835; color:#fdd835; }
  .purple{ --color:#8e24aa; color:#8e24aa; }

  /* å·¦ä¸Šï¼šãƒ“ã‚¯ãƒˆãƒªãƒ¼ã‚«ãƒ¼ãƒ‰è¡¨ç¤ºï¼ˆã‚«ãƒ¼ãƒ‰ã®ä¸‹ã«ã‚¿ã‚¤ãƒˆãƒ«ï¼‰ */
  .victoryArea{
    position:fixed; left:12px; top:12px; z-index:50;
    display:flex; flex-direction:column; align-items:center; gap:6px;
    background:rgba(255,255,255,.9); border:1px solid #eee; border-radius:12px; padding:8px 10px;
    box-shadow:0 4px 20px rgba(0,0,0,.08);
  }
  .victoryArea .title{ font-size:12px; opacity:.8; font-weight:700; }
  .victoryArea .cardbox{ transform: scale(1.2); }
/* å·¦ä¸Šï¼šãƒ€ãƒ–ãƒ«ã‚¹ã‚­ãƒ£ãƒ³ãƒ»ãƒãƒƒãƒ— */
.doubleScan{
  position:fixed; left: calc(12px + 140px); top:12px; z-index:51;
  display:flex; align-items:flex-start; gap:8px;
  background:rgba(255,255,255,.98); border:1px solid #eee; border-radius:12px; padding:8px 10px;
  box-shadow:0 6px 20px rgba(0,0,0,.12);
}
.doubleScan .title{
  font-weight:800; font-size:12px; opacity:.85; white-space:nowrap; margin-top:4px;
}
.doubleScan .body{
  display:flex; align-items:center; gap:8px;
}
.doubleScan .cardbox{ transform: scale(.9); }
  /* å·¦ä¸‹ï¼šæ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰ï¼ˆç·‘æ ï¼‹ç™½æ–‡å­—ã€Œæ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰ã€ã®ã¿ï¼‰ */
  .nextPanel{
    position:fixed; left:12px; bottom:12px; z-index:55;
    display:flex; align-items:center; justify-content:center;
    background:transparent;
    border:none; padding:0;
  }
  .nextBtn{
    border:2px solid #2e7d32; color:#fff; background:#2e7d32;
    padding:8px 14px; border-radius:999px; font-weight:700; cursor:pointer;
    box-shadow:0 4px 12px rgba(0,0,0,.12);
  }

  /* å‡ºã›ã‚‹ã‚«ãƒ¼ãƒ‰ã®é¼“å‹•ã‚¢ãƒ‹ãƒ¡ï¼ˆè‡ªåˆ†ã®æ‰‹ç•ªã®ã¿é©ç”¨ï¼‰ */
  @keyframes pulse12 {
    0% { transform: scale(1.0); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1.0); }
  }
  .pulsate { animation: pulse12 1.2s ease-in-out infinite; transform-origin:center; }

  /* å¸­åABCã®æ–‡å­—ã‚’æ¶ˆã™ï¼ˆç›¸æ‰‹ã‚¨ãƒªã‚¢ã®ã¿ï¼‰ */
  .opp .label{ display: none !important; }

  /* === Center 12x12 grid (èƒŒæ™¯ç½«ç·š) === */
.center-grid{
  position:absolute;
  left:50%; top:70%;
  transform:translate(-50%,-50%);
  width:min(60vmin, 420px);
  aspect-ratio: 1 / 1;
  display:grid;
  grid-template-columns: repeat(12, 1fr);
  grid-auto-rows: 1fr;
  gap:0;
  z-index:-1;
  pointer-events:none;

  /* â–¼ã“ã“ã‚’è¿½åŠ  â–¼ */
  background: url("celltable.jpg") center calc(50% + 1.6px) / cover no-repeat;
  background-size: 100% 100%;

}
  .center-grid .cg-cell{
    background:transparent;
    box-shadow: inset 0 0 0 1px #000; /* è–„ã„ç½«ç·š */
  }

  /* === Center-Piece overlayï¼ˆå‹è€…ãƒ”ãƒ¼ã‚¹ã‚’ä¸­å¤®ã«é‡ã­ã‚‹ï¼‰ === */
/* === Draggable piece on the table === */
.center-piece{
  position:absolute;         /* â† å›ºå®šåº§æ¨™ã§ã¯ãªãçµ¶å¯¾é…ç½® */
  left:0; top:0;
  display:grid;
  grid-template-columns: repeat(var(--cols, 1), var(--cell, 22px));
  grid-auto-rows: var(--cell, 22px);
  gap:0;
  z-index:5;
  pointer-events:auto;
  transform-origin:center center;     /* å›è»¢ã®ä¸­å¿ƒ */
  cursor:grab;
  /* â€» ä»¥å‰ã® translate(-50%,-50%) ã¨å¹…å›ºå®šæŒ‡å®šã¯å‰Šé™¤ */
}
.center-piece.dragging{ cursor:grabbing; }

.center-piece .cp-cell{ width:var(--cell,22px); height:var(--cell,22px); background:transparent; }
.center-piece .cp-cell.filled{
  background: currentColor;
  box-shadow: inset 0 0 0 1px #fff;
}

/* å³ä¸Šã®åè»¢ãƒãƒ³ãƒ‰ãƒ«ã¯æµç”¨ï¼ˆä½ç½®ã ã‘å¾®èª¿æ•´æ¨å¥¨ï¼‰ */
.cp-handles{
  position:absolute;
  top:-12px; right:-44px;
  display:flex; gap:6px;
  z-index:6;
  pointer-events:auto;
}
.cp-handles .flip-btn{
  width:28px; height:28px; border-radius:50%;
  border:0; background:#fff; box-shadow:0 2px 6px rgba(0,0,0,.25);
  font-weight:800; cursor:pointer; line-height:28px;
}

:root{
  --cell-size: calc(min(60vmin, 420px) / 12); /* ä¸­å¤®12x12ã®1ãƒã‚¹ */
}
.center-piece{
  grid-template-columns: repeat(var(--cols, 1), var(--cell-size));
  grid-auto-rows: var(--cell-size);
}
.center-piece .cp-cell{
  width:var(--cell-size);
  height:var(--cell-size);
}

/* å·¦ä¸‹ï¼šæ¨ã¦æœ­ï¼ˆã‚´ãƒŸç®±ï¼‰ */
.trashPanel{
  position:fixed; left:12px; bottom:60px; z-index:55;
  display:flex; align-items:center; justify-content:center;
}
.trashBtn{
  width:44px; height:44px; border-radius:50%;
  border:1px solid #ddd; background:#fff; cursor:pointer;
  box-shadow:0 4px 12px rgba(0,0,0,.12);
  font-size:20px; line-height:1; display:flex; align-items:center; justify-content:center;
}
.trashPopup{
  position:fixed; left:12px; bottom:112px; z-index:60;
  width:min(520px, 92vw); max-height:60vh; overflow:auto;
  background:rgba(255,255,255,.98); border:1px solid #eee; border-radius:12px; padding:8px 10px;
  box-shadow:0 10px 30px rgba(0,0,0,.18);
}
.trashPopup.hidden{ display:none !important; }
.trashPopup .head{ display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:6px; }
.trashPopup .rows{ display:flex; flex-direction:column; gap:6px; }
.trashPopup .row{ display:flex; align-items:center; gap:6px; }
.trashPopup .label{ min-width:56px; font-weight:700; text-transform:capitalize; opacity:.8; }
.trashPopup .cards{ display:flex; gap:4px; overflow-x:auto; padding:4px 2px; }
.trashPopup{
  height: 62vh;          /* ç”»é¢é«˜ã•ã„ã£ã±ã„ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä¸è¦ã«ã™ã‚‹ï¼‰ */
  max-height: 62vh;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
}
.trashPopup .content{
  flex: 1;
  overflow: hidden;      /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç¦æ­¢ */
}
/* æ¨ã¦æœ­ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—å†…ã®è¡Œé–“ã‚’è©°ã‚ã‚‹ */
.trashPopup .row{
  margin: 2px 0;    /* ä¸Šä¸‹ã®é–“éš”ã‚’ç‹­ã */
  padding: 0;
}

/* è¡Œå†…ã®ã‚«ãƒ¼ãƒ‰ã®ä¸Šä¸‹ä½™ç™½ã‚’ãªãã™ */
.trashPopup .cards{
  margin: 0;
  padding: 0;
  gap: 2px;         /* ã‚«ãƒ¼ãƒ‰é–“ã®éš™é–“ã‚‚å°‘ã—ç‹­ã‚ã‚‹ï¼ˆå¿…è¦ãªã‚‰ï¼‰ */
}


/* å°ã•ãªã‚«ãƒ¼ãƒ‰ï¼ˆæ¨ã¦æœ­è¡¨ç¤ºç”¨ï¼‰ */
.cardbox.sm{ width:var(--card-w); }

.cardbox.dimmed{
  opacity: .28;
  filter: brightness(75%); /* å°‘ã—æš—ã‚ã«ã™ã‚‹ */
}

/* â˜… è¿½åŠ ï¼šã‚„ã‚Šç›´ã—ãƒãƒƒãƒ— */
.redoPopup{
  position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
  z-index:70; background:rgba(255,255,255,.98); border:1px solid #eee; border-radius:12px;
  box-shadow:0 10px 30px rgba(0,0,0,.18); padding:10px 12px; min-width:260px;
}
.redoPopup.hidden{ display:none !important; }
.redoPopup .body{ display:flex; flex-direction:column; gap:10px; align-items:center; }
.redoPopup .txt{ font-weight:700; }
.redoPopup .actions{ display:flex; gap:8px; }

/* ãƒ€ãƒ–ãƒ«ã‚¹ã‚­ãƒ£ãƒ³ï¼šãƒˆãƒ¼ã‚¯ãƒ³è¡Œï¼ˆä¸Šéƒ¨ã«5ã¤ã®ã€‡ã‚’æ¨ªä¸¦ã³ï¼‰ */
.doubleScan .tokens{
  display:flex;
  gap:8px;
  align-items:center;
  justify-content:center;   /* ä¸­å¤®å¯„ã› */
  margin:4px 0;             /* ã‚¿ã‚¤ãƒˆãƒ«ã¨ã®é–“ã«ä½™ç™½ */
}
.doubleScan .dot{
  width:24px;
  height:24px;
  border-radius:50%;
  border:2px solid #333;
  background:#333;
}
.doubleScan .dot.empty{
  background:transparent;
}
</style>
</head>
<body>
<header>
  <h1>ã‚¶ãƒ»ã‚«ã‚«ãƒ</h1>
  <div class="small" id="headerInfo"></div>
</header>

<main>
  <!-- å…¥å®¤ -->
  <section id="joinPanel" class="join-box">
    <input id="nameInput" placeholder="åå‰ï¼ˆ1æ–‡å­—ï¼‰" maxlength="1" inputmode="text" />
    <input id="codeInput" placeholder="ãƒ«ãƒ¼ãƒ ã‚³ãƒ¼ãƒ‰ï¼ˆä¾‹: 1234ï¼‰" maxlength="12" inputmode="numeric" />
    <button id="btnJoin" class="btn">å…¥å®¤</button>
  </section>

  <!-- ãƒ†ãƒ¼ãƒ–ãƒ« -->
  <section id="afterPanel" class="hidden">
    <div id="hostBar" class="hostbar hidden">
      <span id="hostInfo">ãƒ›ã‚¹ãƒˆæœªè¨­å®š</span>
      <button id="btnBecomeHost" class="btn">ãƒ›ã‚¹ãƒˆã«ãªã‚‹</button>
      <button id="btn1p" class="btn ghost">1äººãƒ—ãƒ¬ã‚¤</button>
      <button id="btn2p" class="btn ghost">2äººãƒ—ãƒ¬ã‚¤</button>
      <button id="btn3p" class="btn ghost">3äººãƒ—ãƒ¬ã‚¤</button>
      <button id="btn4p" class="btn ghost">4äººãƒ—ãƒ¬ã‚¤</button>
    </div>

    <div id="tableArea" class="table-area">
      <!-- â–¼ä¸­å¤®ã®12x12æ ¼å­ -->
      <div id="centerGrid" class="center-grid" aria-hidden="true"></div>
      <!-- â–¼å‹è€…ãƒ”ãƒ¼ã‚¹ï¼ˆ12x12 åŒå¯¸ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼‰ -->
      <div id="centerPiece" class="center-piece" aria-hidden="false"></div>

      <!-- ç›¸æ‰‹A/B/C -->
      <div id="oppA" class="opp A hidden">
        <div class="label">A</div>
        <div class="fan"></div>
        <div class="badge">A</div>
      </div>
      <div id="oppB" class="opp B hidden">
        <div class="label">B</div>
        <div class="fan"></div>
        <div class="badge">B</div>
      </div>
      <div id="oppC" class="opp C hidden">
        <div class="label">C</div>
        <div class="fan"></div>
        <div class="badge">C</div>
      </div>

      <!-- â€œå ´â€ï¼ˆç›¸æ‰‹ï¼‰ -->
      <div id="playA" class="play-slot play-A"></div>
      <div id="playB" class="play-slot play-B"></div>
      <div id="playC" class="play-slot play-C"></div>
    </div>
  </section>
</main>

<!-- è‡ªåˆ†ã®æ‰‹æœ­ï¼†å ´ -->
<div id="handBar" class="handbar">
  <div class="topline" id="turnLine"></div> <!-- éè¡¨ç¤º -->
</div>
<div id="playMine" class="play-mine-fixed"></div>

<!-- å·¦ä¸Šï¼šãƒ“ã‚¯ãƒˆãƒªãƒ¼ã‚«ãƒ¼ãƒ‰ -->
<div id="victoryArea" class="victoryArea hidden">
  <div class="title"><div id="victTitle">ãƒ‡ã‚£ã‚·ã‚¸ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰</div></div>
  <div id="victoryCardBox"></div>
</div>
<!-- ãƒ€ãƒ–ãƒ«ã‚¹ã‚­ãƒ£ãƒ³ãƒ»ãƒãƒƒãƒ— -->
<div id="doubleScanPop" class="doubleScan hidden" role="status" aria-live="polite">
  <div class="title">ãƒ€ãƒ–ãƒ«ã‚¹ã‚­ãƒ£ãƒ³</div>
  <div id="doubleScanBody" class="body"></div>
  <!-- ä¸­èº«ã¯ JS ã§ (è‰²ãƒ»æœ€å°ã‚«ãƒ¼ãƒ‰) ã‚’æç”» -->
  <!-- æ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰ã§è‡ªå‹•çš„ã«æ¶ˆãˆã‚‹ -->
</div>


<!-- å·¦ä¸‹ï¼šæ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰ -->
<div id="nextPanel" class="nextPanel hidden">
  <button id="btnNextRound" class="nextBtn" title="æ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰">æ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰</button>
</div>

<!-- å·¦ä¸‹ï¼šæ¨ã¦æœ­ï¼ˆã‚´ãƒŸç®±ï¼‰ -->
<div id="trashPanel" class="trashPanel hidden">
  <button id="btnTrash" class="trashBtn" title="æ¨ã¦æœ­">ğŸ—‘ï¸</button>
</div>

<!-- æ¨ã¦æœ­ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— -->
<div id="trashPopup" class="trashPopup hidden" role="dialog" aria-label="æ¨ã¦æœ­">
  <div class="head">
  </div>
  <div id="trashContent" class="rows"></div>
</div>

<!-- â˜… è¿½åŠ ï¼šãƒ”ãƒ¼ã‚¹ç·¨é›†ãƒãƒƒãƒ—ï¼ˆã‚„ã‚Šç›´ã—ï¼‰ -->
<div id="redoPopup" class="redoPopup hidden" role="dialog" aria-label="ãƒ”ãƒ¼ã‚¹ç·¨é›†">
  <div class="body">
    <div class="txt">ã“ã®ãƒ”ãƒ¼ã‚¹ã‚’ã‚„ã‚Šç›´ã—ã¾ã™ã‹ï¼Ÿ</div>
    <div class="actions">
      <button id="redoOk" class="btn">ã‚„ã‚Šç›´ã™</button>
      <button id="redoCancel" class="btn ghost">é–‰ã˜ã‚‹</button>
    </div>
  </div>
</div>


<!-- å³ä¸‹ï¼šè¨­å®š -->
<button id="fabOpenSeat" class="fab" title="è¨­å®š / åº§å¸­é¸æŠ" aria-label="è¨­å®š">âš™ï¸</button>

<!-- ãƒœãƒˆãƒ ã‚·ãƒ¼ãƒˆ -->
<div id="seatSheet" class="bsheet hidden" aria-modal="true" role="dialog">
  <div class="backdrop" id="sheetBackdrop"></div>
  <div class="panel" role="document">
    <div class="row head">
      <div class="title" id="sheetTitle">åº§å¸­é¸æŠ</div>
      <button id="sheetClose" class="btn ghost" style="padding:6px 10px;">é–‰ã˜ã‚‹</button>
    </div>
    <div class="row" id="rowTop"><div class="muted">èª­ã¿è¾¼ã¿ä¸­â€¦</div></div>
    <div class="row" id="rowSeats"></div>
  </div>
</div>
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import { getDatabase, ref, set, onDisconnect, onValue, runTransaction, remove, update } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyARne6Jb4ePP7vbvLryE_P-jZ2umI3LFc",
    authDomain: "kakapo-8d297.firebaseapp.com",
    databaseURL: "https://kakapo-8d297-default-rtdb.firebaseio.com",
    projectId: "kakapo-8d297",
    storageBucket: "kakapo-8d297.firebasestorage.app",
    messagingSenderId: "702767130857",
    appId: "1:702767130857:web:54472c8d5ea09bd3cf6878",
    measurementId: "G-NXSRP1T826"
  };

  const app = initializeApp(firebaseConfig);
  const db  = getDatabase(app);

  // ==== DOM ====
  const headerInfo = document.getElementById('headerInfo');
  const joinPanel  = document.getElementById('joinPanel');
  const afterPanel = document.getElementById('afterPanel');
  const nameInput  = document.getElementById('nameInput');
  const codeInput  = document.getElementById('codeInput');
  const btnJoin    = document.getElementById('btnJoin');

  const handBar  = document.getElementById('handBar');
  const oppA     = document.getElementById('oppA');
  const oppB     = document.getElementById('oppB');
  const oppC     = document.getElementById('oppC');

  const playMine = document.getElementById('playMine');
  const playA    = document.getElementById('playA');
  const playB    = document.getElementById('playB');
  const playC    = document.getElementById('playC');
  // æ¨ã¦æœ­UI
  const trashPanel   = document.getElementById('trashPanel');
  const btnTrash     = document.getElementById('btnTrash');
  const trashPopup   = document.getElementById('trashPopup');
  const trashClose   = document.getElementById('trashClose');
  const trashContent = document.getElementById('trashContent');

  btnTrash?.addEventListener('click', ()=>{
    const opening = trashPopup.classList.contains('hidden');
    if (opening) renderDiscardPopup();
    show(trashPopup, opening);
  });
  trashClose?.addEventListener('click', ()=> show(trashPopup, false));
  document.addEventListener('keydown', e=>{ if (e.key==='Escape') show(trashPopup, false); });

  // ä¸­å¤®ãƒ¬ã‚¤ãƒ¤
  const centerGrid  = document.getElementById('centerGrid');   // èƒŒæ™¯ã®12x12ç½«ç·š
  const centerPiece = document.getElementById('centerPiece');  // å‹è€…ãƒ”ãƒ¼ã‚¹ã®12x12ï¼ˆåŒæœŸï¼‹å›è»¢/åè»¢ï¼‰

  // --- èƒŒæ™¯ã‚°ãƒªãƒƒãƒ‰ç”Ÿæˆ ---
  (function buildCenterGrid(){
    if (!centerGrid) return;
    const total = 12 * 12;
    const frag = document.createDocumentFragment();
    for (let i = 0; i < total; i++){
      const cell = document.createElement('div');
      cell.className = 'cg-cell';
      frag.appendChild(cell);
    }
    centerGrid.appendChild(frag);
  })();

  // Victory UI
  const victoryArea   = document.getElementById('victoryArea');
  const victoryCardBox= document.getElementById('victoryCardBox');
  const nextPanel     = document.getElementById('nextPanel');
  const btnNextRound  = document.getElementById('btnNextRound');
  // DoubleScan UI
  const doubleScanPop  = document.getElementById('doubleScanPop');
  const doubleScanBody = document.getElementById('doubleScanBody');
  // ãƒœãƒˆãƒ ã‚·ãƒ¼ãƒˆ
  const seatSheet   = document.getElementById('seatSheet');
  const rowTop      = document.getElementById('rowTop');
  const rowSeats    = document.getElementById('rowSeats');
  const sheetTitle  = document.getElementById('sheetTitle');
  const sheetClose  = document.getElementById('sheetClose');
  const sheetBackdrop = document.getElementById('sheetBackdrop');
  const fabOpenSeat = document.getElementById('fabOpenSeat');

  // ==== 40æšã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ï¼ˆè‰²Ã—8ï¼‰ ====
  const CARD_DATA = {
    red:   {1:'A1',2:'A1.B1',3:'A1,B1,C1',4:'A1,A2,A3,B3',5:'A1,A2,A3,A4,B3',6:'A1,B1,B2,B3,B4,C3',7:'A1,A2,A3,A4,A5B1,B3',8:'A1,B1,B2,B3,B4,B5,B6,C5'},
    blue:  {1:'A1',2:'A1,A2',3:'A1,A2,A3',4:'A1,A2,B1,B2',5:'A1,A2,A3,B1,B2',6:'A1,A2,A3,B1,B2,C2',7:'A1,A2,B1,B2,C1,C2,D1',8:'A1,A2,B1,B2,B3,C2,C3,D3'},
    green: {1:'A1',2:'A1,A2',3:'A1,A2,A3',4:'A1,A2,A3,B2',5:'A2,A3,B2,C1,C2',6:'A3,B1,B2,B3,C1,C3',7:'A1,A2,A3,A4,B1,C1,D1',8:'A1,A2,B1,C1,C2,C3,C4,D4'},
    yellow:{1:'A1',2:'A1,A2',3:'A1,A2,A3',4:'A1,B1,B2,C2',5:'A2,B1,B2,B3,C2',6:'A1,A3,B1,B2,B3,C2',7:'A1,A2,A3,B2,C1,C2,C3',8:'A1,A4,B1,B2,B3,B4,C1,C4'},
    purple:{0:'', 1:'A1,B1',2:'A1,A2',3:'A1,A2,B2',4:'A1,A2,B2',5:'A1,A2,B1,B2',6:'A1,A2,B1,B2',7:'A1,A2,A3,A4,A5,A6',8:'A1,A2,A3,A4,A5,A6,A7'}
  };

  // ã‚°ãƒ­ãƒ¼ãƒãƒ«æ ¼å­ã‚µã‚¤ã‚ºï¼ˆå…¨ã‚«ãƒ¼ãƒ‰ã§çµ±ä¸€ï¼‰
  const GRID_MAX = (function(){
    let maxCol=1, maxRow=1;
    const parse = s => (s.match(/[A-Z]\d+/gi)||[]).map(x=>x.toUpperCase());
    const toPos = t => ({ c:t.charCodeAt(0)-64, r:parseInt(t.slice(1),10) });
    for(const color in CARD_DATA){
      for(const i in CARD_DATA[color]){
        const ps = parse(CARD_DATA[color][i]).map(toPos);
        if(ps.length){
          maxCol = Math.max(maxCol, ...ps.map(p=>p.c));
          maxRow = Math.max(maxRow, ...ps.map(p=>p.r));
        }
      }
    }
    return {maxCol, maxRow};
  })();

  function parseCoords(s){ return (s.match(/[A-Z]\d+/gi) || []).map(x=>x.toUpperCase()); }
  function toPos(token){ return { col: token.charCodeAt(0)-64, row: parseInt(token.slice(1),10) }; }

  // === è¡¨ç¤ºç”¨ã‚½ãƒ¼ãƒˆï¼ˆè‰²ã‚°ãƒ«ãƒ¼ãƒ—â†’ç•ªå·æ˜‡é †ï¼‰ ===
  const COLOR_ORDER = ['red','blue','green','yellow','purple'];
  function parseCardId(id){ const [c, n] = String(id).split('-'); return { color:c, index:Number(n)||0 }; }
  function compareCardIds(a,b){
    const A = parseCardId(a), B = parseCardId(b);
    const ca = COLOR_ORDER.indexOf(A.color), cb = COLOR_ORDER.indexOf(B.color);
    if (ca !== cb) return ca - cb;
    return A.index - B.index;
  }

  // ==== çŠ¶æ…‹ ====
  const state = {
    uid: crypto.randomUUID(),
    name: "",
    code: "",
    joined: false,
    mySeat: null,      // 1..4
    playersN: null,    // 3 or 4
    hostUid: null,
    seats: {},         // { "1": {uid,name}, ... }
    hands: {},         // { "1":[cardId,...], ... }
    plays: {},         // { uid: {cardId,color,index,seat,round,ts} }
    game: {},          // ãƒ©ã‚¦ãƒ³ãƒ‰é€²è¡Œã®ãƒ¡ã‚¿
    graveyard: {},      // â˜… è¿½åŠ ï¼š{ red:[id...], blue:[id...], ... }  
    editingRound: null // â˜… è¿½åŠ ï¼šã„ã¾ã€Œã‚„ã‚Šç›´ã—ã€ç·¨é›†ä¸­ã®ãƒ©ã‚¦ãƒ³ãƒ‰ç•ªå·ï¼ˆnullã§æœªç·¨é›†ï¼‰
};

  // è¿½åŠ ï¼šã‚¹ã‚­ãƒ«é¸æŠãƒ•ã‚§ãƒ¼ã‚ºï¼ˆä»Šå›ã¯ â€œãªã—/é€šå¸¸â€ ã®ã¿æƒ³å®šï¼‰
  const skillMode = 'none';

  function randomLetter(){ return String.fromCharCode(65 + Math.floor(Math.random()*26)); }
  function random4(){ return String(Math.floor(Math.random()*10000)).padStart(4, '0'); }
  const NAME_RE = /^[A-Za-z\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FFF]$/;
  function normalizeName(raw){ const t = (raw || "").trim(); if (!t) return randomLetter(); const c = t[0]; return NAME_RE.test(c) ? c : randomLetter(); }
  function show(el, yes){ el.classList.toggle('hidden', !yes); }

  function updateHeader(){
    headerInfo.innerHTML = '';
    const spanRoom = document.createElement('span');
    spanRoom.textContent = `ã‚³ãƒ¼ãƒ‰ï¼š${state.code || '-'}`;
    const spanMe = document.createElement('span');
    spanMe.textContent = `ã‚ãªãŸï¼š${state.name || '-'}`;

    const g = state.game || {};
    const r = g.round || 0;
    const startSeat = g.startSeat;
    const startName = (g.startUid && Object.values(state.seats||{}).find(s=>s.uid===g.startUid)?.name) || (startSeat?`å¸­${startSeat}`:'-');
    const sc = g.startColor || '-';
    const turnUid = g.turnUid || null;
    const turnName = (turnUid && Object.values(state.seats||{}).find(s=>s.uid===turnUid)?.name) || '?';

    const status = document.createElement('span');
    status.textContent = `R${r} / ã‚¹ã‚¿ãƒ¼ãƒˆï¼š${startName} / ã‚¹ã‚¿ãƒ¼ãƒˆã‚«ãƒ©ãƒ¼ï¼š${sc} / æ‰‹ç•ªï¼š${turnName}`;

    const btn = document.createElement('button');
    btn.className = 'copybtn';
    btn.textContent = 'ãƒªãƒ³ã‚¯ã‚³ãƒ”ãƒ¼';
    btn.onclick = ()=>{
      const url = new URL(location.href);
      url.searchParams.set('room', state.code);
      url.searchParams.set('name', state.name);
      navigator.clipboard.writeText(url.toString());
      btn.textContent = 'ã‚³ãƒ”ãƒ¼æ¸ˆã¿ï¼';
      setTimeout(()=> btn.textContent='ãƒªãƒ³ã‚¯ã‚³ãƒ”ãƒ¼', 1200);
    };

    headerInfo.appendChild(spanRoom);
    headerInfo.appendChild(spanMe);
    headerInfo.appendChild(status);
    headerInfo.appendChild(btn);
  }

  // å…¥å®¤
  async function join(){
    const name = normalizeName(nameInput.value);
    const code = (codeInput.value || "").trim() || random4();
    state.name = name; state.code = code;

    const meRef = ref(db, `rooms/${code}/participants/${state.uid}`);
    await set(meRef, { name, at: Date.now() });
    onDisconnect(meRef).remove();

    await runTransaction(ref(db, `rooms/${code}/settings/hostUid`), cur => cur || state.uid, { applyLocally:false });

    updateHeader();
    show(joinPanel, false);
    show(afterPanel, true);
    state.joined = true;

    wireRoom();
    openSeatSheet();
    show(trashPanel, true);  // â† å…¥å®¤å¾Œã«è¡¨ç¤º

  }
  btnJoin.onclick = join;

  // äº‹å‰å…¥åŠ›
  try{
    const qs = new URLSearchParams(location.search);
    const qRoom = (qs.get('room')||'').trim();
    const qName = (qs.get('name')||'').trim();
    if (qRoom) codeInput.value = qRoom.slice(0, 12);
    if (qName) nameInput.value = qName.slice(0, 1);
  }catch(_e){}

  // ãƒ«ãƒ¼ãƒ è³¼èª­
  function wireRoom(){
    const room = `rooms/${state.code}`;

    onValue(ref(db, `${room}/settings`), snap=>{
      const st = snap.val() || {};
      state.hostUid = st.hostUid || null;
      state.playersN = st.players || null;
      const hostBar = document.getElementById('hostBar');
      const btn1 = document.getElementById('btn1p');
      const btn2 = document.getElementById('btn2p');
      const btn3 = document.getElementById('btn3p');
      const btn4 = document.getElementById('btn4p');
      const btnHost = document.getElementById('btnBecomeHost');
      const hostInfo = document.getElementById('hostInfo');
      if (hostBar){ hostBar.style.display = 'block'; }
      if (btnHost){ btnHost.onclick = async()=>{ await set(ref(db, `${room}/settings/hostUid`), state.uid); }; }
      if (btn1){ btn1.onclick = async ()=>{ await setPlayersAndDeal(1); }; }
      if (btn2){ btn2.onclick = async ()=>{ await setPlayersAndDeal(2); }; }
      if (btn3){ btn3.onclick = async ()=>{ await setPlayersAndDeal(3); }; }
      if (btn4){ btn4.onclick = async ()=>{ await setPlayersAndDeal(4); }; }
      if (hostInfo){ hostInfo.textContent = `ãƒ›ã‚¹ãƒˆï¼š${st.hostUid ? (st.hostUid===state.uid?'ã‚ãªãŸ':st.hostUid.slice(0,4)) : 'æœªè¨­å®š'}`; }

      if (!seatSheet.classList.contains('hidden')) renderSeatSheet();
      updateHeader();
      renderAll();
    });

    onValue(ref(db, `${room}/hands`), snap=>{ state.hands = snap.val() || {}; renderAll(); });

    onValue(ref(db, `${room}/graveyard`), snap=>{
      state.graveyard = snap.val() || {};
      // é–‹ã„ã¦ã„ã‚‹ã¨ãã¯å³æ™‚å†æç”»
      if (!trashPopup.classList.contains('hidden')) renderDiscardPopup();
    });


    onValue(ref(db, `${room}/seats`), snap=>{
      state.seats = snap.val() || {};
      state.mySeat = null;
      for (const k of Object.keys(state.seats)){
        if (state.seats[k]?.uid === state.uid){ state.mySeat = Number(k); break; }
      }
      if (!seatSheet.classList.contains('hidden')) renderSeatSheet();
      renderAll();
    });

    onValue(ref(db, `${room}/plays`), snap=>{
      state.plays = snap.val() || {};
      renderPlays();
      maybeComputeVictory(); // ãƒ›ã‚¹ãƒˆãªã‚‰åˆ¤å®š
    });

    onValue(ref(db, `${room}/game`), snap=>{
      state.game = snap.val() || {};
      updateHeader();
      renderAll();
      renderVictoryWidgets(); // â† ä¸­å¤®ãƒ”ãƒ¼ã‚¹æç”»ã‚‚ã“ã“ã§
renderDoubleScan();     // â† ãƒ€ãƒ–ãƒ«ã‚¹ã‚­ãƒ£ãƒ³ãƒ»ãƒãƒƒãƒ—ã‚’åŒæœŸæç”»
    });

    // æ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰æ™‚ï¼šãƒ€ãƒ–ãƒ«ã‚¹ã‚­ãƒ£ãƒ³ã‚’æ¶ˆå»ï¼ˆä»–å‡¦ç†ã¨ä½µå­˜å¯ï¼‰
    btnNextRound?.addEventListener('click', async ()=>{
      try{
        const room = `rooms/${state.code}`;
        await update(ref(db), { [`${room}/game/doubleScan`]: null });
      }catch(_e){}
    });

  }

  // ===== 40æšãƒ‡ãƒƒã‚­ã®ç”Ÿæˆãƒ»ã‚·ãƒ£ãƒƒãƒ•ãƒ«ãƒ»é…å¸ƒ =====
  function buildDeck40(){
    const deck = [];
    for(const color of ['red','blue','green','yellow','purple']){
      for(let i=1;i<=8;i++) deck.push({ id:`${color}-${i}`, color, index:i });
    }
    return deck; // 5è‰²Ã—8 = 40
  }
  function shuffleInPlace(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
  function makeDealtByRoundRobin(N, deck){
    const out={ '1':[], '2':[], '3':[], '4':[] };
    deck.forEach((card,idx)=>{ const seat=((idx)%N)+1; out[String(seat)].push(card.id); });
    return out;
  }

  function detectStartSeatFromHands(N, hands){
    // ç´«8ã‚’å«ã‚€å¸­ãŒã‚¹ã‚¿ãƒ¼ãƒˆå¸­
    const target = 'purple-8';
    for (let i=1; i<=N; i++){
      if ((hands[String(i)]||[]).includes(target)) return i;
    }
    return 1;
  }

function renderDoubleScan(){
  if (!doubleScanPop || !doubleScanBody) return;
  const g  = state.game || {};
  const ds = g.doubleScan || null;

  // â˜… ä¿®æ­£ï¼šè¡¨ç¤ºæ¡ä»¶ã‚’ã€Œds ãŒç¾åœ¨ãƒ©ã‚¦ãƒ³ãƒ‰ã«å­˜åœ¨ã™ã‚‹ã‹ã€ã«å¤‰æ›´
  const shouldShow = !!(ds && Number(ds.round) === Number(g.round));

  if (!shouldShow) {
    doubleScanBody.innerHTML = '';
    doubleScanPop.classList.add('hidden');
    return;
  }


  doubleScanBody.innerHTML = '';
  doubleScanPop.classList.remove('hidden');

  // === ã‚¹ã‚­ãƒ«ãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆä¸Šéƒ¨ã«è¡¨ç¤ºï¼‰ ===
// === ã‚¹ã‚­ãƒ«ãƒˆãƒ¼ã‚¯ãƒ³ ===
const tokens = Math.max(0, Math.min(5, Number(g.skillTokens ?? 5)));
const tokenRow = document.createElement('div');
tokenRow.className = 'tokens';
for (let i = 0; i < 5; i++){
  const d = document.createElement('div');
  d.className = 'dot' + (i < 5 - tokens ? ' empty' : '');
  tokenRow.appendChild(d);
}

// â˜… ã‚¿ã‚¤ãƒˆãƒ«ã®ä¸­ã«è¿½åŠ ï¼ˆä¸­å¤®ã«ç¸¦ä¸¦ã³ã«ãªã‚‹ï¼‰
const titleEl = doubleScanPop.querySelector('.title');
if (titleEl){
  const old = titleEl.querySelector('.tokens');
  if (old) old.remove();
  titleEl.appendChild(tokenRow);
}
  // ã‚¿ã‚¤ãƒˆãƒ«ã®å³å´ã«å¯„ã›ãŸã„ã®ã§ã€ã‚¿ã‚¤ãƒˆãƒ«ã®å‰ã«è¡Œã‚’æŒ¿å…¥
  // ï¼ˆ.doubleScan ã®æ§‹é€ ï¼š<div class="title">, <div id="doubleScanBody" class="body">ï¼‰
  // â†’ tokens ã¯ body ã‚³ãƒ³ãƒ†ãƒŠã®å…ˆé ­ã«æŒ¿å…¥ã—ã¦ã€Œä¸Šæ®µã€ã«è¦‹ã›ã‚‹
  const frag = document.createDocumentFragment();
  frag.appendChild(tokenRow);

  // === ãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ï¼ˆå¾“æ¥ã©ãŠã‚Šï¼‰ ===
  const mini = makeCardFaceEl(ds.cardId);
  mini.classList.add('clickable');
  mini.style.cursor = 'pointer';
  frag.appendChild(mini);

  // body ã«ã¾ã¨ã‚ã¦è¿½åŠ ï¼ˆå…ˆé ­ãŒ tokensï¼‰
  doubleScanBody.appendChild(frag);

  // ã‚¯ãƒªãƒƒã‚¯ â†’ è¿½åŠ ãƒ”ãƒ¼ã‚¹ç”Ÿæˆ â†’ ãƒˆãƒ¼ã‚¯ãƒ³ã‚’1æ¸›ã‚‰ã™ï¼ˆå³ã‹ã‚‰1ã¤æ¶ˆãˆã‚‹ï¼‰â†’ ãƒãƒƒãƒ—å…¨å“¡éè¡¨ç¤º
  mini.addEventListener('click', async ()=>{
    const gNow = state.game || {};
    const vict = gNow.victory;
    if (!vict || vict.uid !== state.uid) return; // å‹è€…ã®ã¿æœ‰åŠ¹

    try{
      // 1) è¿½åŠ ãƒ”ãƒ¼ã‚¹ã‚’ç”Ÿæˆï¼ˆæ—¢å­˜ï¼‰
      await addExtraCenterPieceFromDoubleScan(ds);

      // 2) ãƒˆãƒ¼ã‚¯ãƒ³ã‚’1æ¸›ç®—ï¼ˆä¸‹é™0ï¼‰
      const room = `rooms/${state.code}`;
      const next = Math.max(0, (Number((state.game||{}).skillTokens ?? 5) - 1));
      await update(ref(db), {
        [`${room}/game/skillTokens`]: next
      });

      // 3) ãƒãƒƒãƒ—ã‚’å…¨å“¡ã§é–‰ã˜ã‚‹ï¼ˆåŒæœŸï¼‰
      await update(ref(db), { [`${room}/game/doubleScan`]: null });

      // 4) ãƒ­ãƒ¼ã‚«ãƒ«ã§ã‚‚å³æ™‚é–‰ã˜ã‚‹
      doubleScanBody.innerHTML = '';
      doubleScanPop.classList.add('hidden');
    }catch(err){
      console.error('doubleScan tokens/update failed:', err);
    }
  }, { once:true });
}
async function addExtraCenterPieceFromDoubleScan(ds){
  const g = state.game || {};
  const room = `rooms/${state.code}`;
  const r = g.round || 1;

  // æ—¢ã«å‹è€…ãƒ”ãƒ¼ã‚¹ãŒå‡ºã¦ã„ã‚‹ã“ã¨ã‚’å‰æã«ã€Œè¿½åŠ ã€ã™ã‚‹ï¼ˆå¾Œæ–¹äº’æ›ã®ãŸã‚é…åˆ—åŒ–å‡¦ç†ã‚’è¡Œã†ï¼‰
  const rect = tableArea.getBoundingClientRect();
  const initX = rect.width / 2;
  const initY = rect.height * 0.55;

  const piece = {
    cardId: `${ds.color}-${ds.index}`,
    color:  ds.color,
    index:  ds.index,
    round:  r,
    uid:    g.victory?.uid || state.uid, // å‹è€…ã®UIDã§å±æ€§ã¥ã‘
    angle:  0,
    flipX:  1,
    flipY:  1,
    x:      initX,
    y:      initY,
    ts:     Date.now(),
    extra:  true
  };

  // å¾Œæ–¹äº’æ›ï¼šcenterPieces[r] ãŒã€Œå˜ä¸€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã§ã‚‚ã€Œé…åˆ—ã€ã§ã‚‚OKã«ã™ã‚‹
  await runTransaction(ref(db, `${room}/game/centerPieces/${r}`), cur=>{
    if (!cur) return [piece];               // ä½•ã‚‰ã‹ã®ç†ç”±ã§æœªä½œæˆãªã‚‰é…åˆ—ã¨ã—ã¦ä½œæˆ
    if (Array.isArray(cur)) return cur.concat(piece);
    return [cur, piece];                     // æ—§:å˜ä¸€â†’æ–°:é…åˆ—ã¸æ˜‡æ ¼
  }, { applyLocally:false });
}


  function seatUid(seatNum){
    return state.seats?.[String(seatNum)]?.uid || null;
  }

  // æ™‚è¨ˆå›ã‚Š: å³éš£=å¸­ç•ªå·ã‚’1ã¤æ¸›ã‚‰ã™æ–¹å‘
  function orderSeatsFrom(startSeat, N){
    const arr=[];
    for (let k=0; k<N; k++){
      const seat = (((startSeat - 1 - k) % N) + N) % N + 1;
      arr.push(seat);
    }
    return arr;
  }

  async function setPlayersAndDeal(N){
    const room=`rooms/${state.code}`;
  let deck = buildDeck40();
  if (N === 3) {
    // â˜… ä¸‰äººãƒ—ãƒ¬ã‚¤æ™‚ã¯ purple-1 ã‚’é…å¸ƒã‹ã‚‰é™¤å¤–
    deck = deck.filter(c => c.id !== 'purple-1');
  }
  deck = shuffleInPlace(deck);    const deal=makeDealtByRoundRobin(N, deck);

    const hands = deal;

    const startSeat = detectStartSeatFromHands(N, hands);
    const orderSeats = orderSeatsFrom(startSeat, N);
    const startUid = seatUid(startSeat);

    const initGame = {
      round: 1,
      playersN: N,
      startSeat,
      orderSeats,    // åº§å¸­ç•ªå·é…åˆ—
      startUid: startUid || null,
      turnUid: startUid || null,
      startColor: null,
prevVictoryColor: 'purple',
      victory: null, // {cardId, uid, color, index, round}
      startColors: {}, // { "1": "red", ... }
      // â˜… ä¸­å¤®ãƒ”ãƒ¼ã‚¹ï¼ˆå½¢ï¼‹å§¿å‹¢ï¼‰: æ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰å¾Œã‚‚æ®‹ã™ã®ã§ã€ã“ã“ã¯ null ã®ã¾ã¾é–‹å§‹
      centerPiece: null
    };

    await update(ref(db), {
      [`${room}/settings/players`]: N,
      [`${room}/hands`]: hands,
      [`${room}/plays`]: null,
      [`${room}/game`]: {
        ...initGame,
        victory: {
          cardId: (N === 3 ? 'purple-1' : 'purple-0'),
          color:  'purple',
          index:  (N === 3 ? 1 : 0),
          round:  1,
          uid:    null,  // è¡¨ç¤ºã®ã¿ï¼ˆå‹è€…ç¢ºå®šã§ã¯ãªã„ï¼‰
          seat:   null,
          ts:     Date.now()
        }
      }    });
  }

  // ã‚·ãƒ¼ãƒˆ
  function openSeatSheet(){ show(seatSheet, true); renderSeatSheet(); }
  function closeSeatSheet(){ show(seatSheet, false); }
  sheetClose.addEventListener('click', closeSeatSheet);
  sheetBackdrop.addEventListener('click', closeSeatSheet);
  fabOpenSeat.addEventListener('click', openSeatSheet);

  function renderSeatSheet(){
    const isHost = state.hostUid === state.uid;
    sheetTitle.textContent = isHost ? 'è¨­å®šã¨ç€å¸­ï¼ˆãƒ›ã‚¹ãƒˆï¼‰' : 'ç€å¸­ï¼ˆã‚²ã‚¹ãƒˆï¼‰';

    rowTop.innerHTML = '';
    if (isHost){
      const seg = document.createElement('div'); seg.className = 'seg';
      const btn1 = document.createElement('button'); btn1.className = 'segbtn' + (state.playersN===1 ? ' active':''); btn1.textContent = '1äºº'; btn1.onclick = async ()=>{ await setPlayersAndDeal(1); };      
const btn2 = document.createElement('button'); btn2.className = 'segbtn' + (state.playersN===2 ? ' active':''); btn2.textContent = '2äºº'; btn2.onclick = async ()=>{ await setPlayersAndDeal(2); };      
const btn3 = document.createElement('button'); btn3.className = 'segbtn' + (state.playersN===3 ? ' active':''); btn3.textContent = '3äºº'; btn3.onclick = async ()=>{ await setPlayersAndDeal(3); };
const btn4 = document.createElement('button'); btn4.className = 'segbtn' + (state.playersN===4 ? ' active':''); btn4.textContent = '4äºº'; btn4.onclick = async ()=>{ await setPlayersAndDeal(4); };
      seg.appendChild(btn1); seg.appendChild(btn2); seg.appendChild(btn3); seg.appendChild(btn4);
      const cap = document.createElement('div'); cap.className='muted'; cap.textContent='äººæ•°ã‚’é¸ã‚“ã æ™‚ç‚¹ã§40æšã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«é…å¸ƒã—ã¾ã™ã€‚æ¬¡ã«åº§å¸­ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚';
      rowTop.appendChild(seg); rowTop.appendChild(cap);
    }else{
      const cap = document.createElement('div'); cap.className='muted'; cap.textContent = state.playersN ? `ç¾åœ¨ ${state.playersN} äººãƒ—ãƒ¬ã‚¤` : 'ãƒ›ã‚¹ãƒˆãŒäººæ•°ã‚’è¨­å®šä¸­â€¦';
      rowTop.appendChild(cap);
    }

    rowSeats.innerHTML = '';
    const N = state.playersN || 4;
    for (let i=1; i<=4; i++){
      const taken = !!state.seats[i];
      const mine  = state.seats[i]?.uid === state.uid;
      const invalidByPlayers = (!N) || (N===3 && i===4);

      const btn = document.createElement('button');
      btn.className = 'seatbtn' + (mine ? ' me' : '');
      btn.textContent = mine ? `å¸­${i}ï¼ˆã‚ãªãŸï¼‰` : taken ? `å¸­${i}ï¼ˆä½¿ç”¨ä¸­ï¼‰` : `å¸­${i}`;
      btn.disabled = (!mine && (taken || invalidByPlayers));
      btn.onclick = async ()=>{
        if (mine){
          await releaseMySeat();
        } else {
          const ok = await claimSeat(i);
          if (ok){
            await maybeFillStartFromSeat();
            closeSeatSheet();
          }
        }
      };
      rowSeats.appendChild(btn);
    }
  }

  async function claimSeat(n){
    const seatRef = ref(db, `rooms/${state.code}/seats/${n}`);
    try{
      const res = await runTransaction(seatRef, cur=>{ if (!cur || cur.uid === state.uid){ return { uid: state.uid, name: state.name, at: Date.now() }; } return cur; }, {applyLocally:false});
      if (!res.committed || res.snapshot.val()?.uid !== state.uid){ alert(`å¸­${n} ã¯ä½¿ç”¨ä¸­ã§ã™ã€‚`); return false; }
     else{
      // --- ã“ã“ã‹ã‚‰åŒæœŸãƒ­ã‚¸ãƒƒã‚¯ï¼šåº§å¸­â†’uidï¼ˆå†å…¥å®¤ã§uidãŒå¤‰ã‚ã£ãŸå¯¾ç­–ï¼‰ ---
      try{
        const room = `rooms/${state.code}`;
        const g = state.game || {};
       const updates = {};

        // 1) ã‚¹ã‚¿ãƒ¼ãƒˆå¸­ã®uidãŒå¤ã„å ´åˆï¼šä»Šã®ç€å¸­è€…(uid)ã«ç½®ãæ›ãˆ
        if (g.startSeat && g.startSeat === n && g.startUid !== state.uid){
          updates[`${room}/game/startUid`] = state.uid;
        }

        // 2) æ‰‹ç•ªã®å¸­ã‚’å†è¨ˆç®—ã—ã¦ã€è©²å½“å¸­ãªã‚‰ turnUid ã‚‚è‡ªåˆ†ã«ç½®ãæ›ãˆ
        //    ï¼ˆorderSeats ã¨ ä»Šãƒ©ã‚¦ãƒ³ãƒ‰ã®ãƒ—ãƒ¬ã‚¤æ•°ã‹ã‚‰ã€Œä»Šæ‰‹ç•ªã®å¸­ã€ã‚’æ±ºã‚ã‚‹ï¼‰
        const N = g.playersN || state.playersN || 0;
        if (N && Array.isArray(g.orderSeats) && g.orderSeats.length === N){
          // ä»Šãƒ©ã‚¦ãƒ³ãƒ‰ã«ç¢ºå®šã—ã¦ã„ã‚‹ãƒ—ãƒ¬ã‚¤æ•°
          const playsNow = Object.values(state.plays || {}).filter(p => Number(p?.round) === (g.round||1)).length;
          const expectedSeat = g.orderSeats[playsNow % N];  // ã„ã¾æ‰‹ç•ªã®å¸­ç•ªå·
          if (expectedSeat === n){
           updates[`${room}/game/turnUid`] = state.uid;
          }
        } else {
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šturnUid ãŒæœªè¨­å®šã‹å¤ã„uidã§åº§å¸­ã«ä¸åœ¨ãªã‚‰ã€è‡ªåˆ†ã«ç§»è­²
          const turnSeat = (g.turnUid && (Object.entries(state.seats||{}).find(([k,v])=>v?.uid===g.turnUid)?.[0] | 0)) || 0;
          if (!g.turnUid || !turnSeat){
            updates[`${room}/game/turnUid`] = state.uid;
          }
        }

        if (Object.keys(updates).length){
          await update(ref(db), updates);
        }
      }catch(_e){}
      // --- åŒæœŸãƒ­ã‚¸ãƒƒã‚¯ã“ã“ã¾ã§ ---
      return true;      }
    }catch(e){ console.error(e); alert('ç€å¸­ã«å¤±æ•—ã—ã¾ã—ãŸã€‚'); return false; }
  }
  async function releaseMySeat(){
    if (!state.mySeat) return;
    const room = `rooms/${state.code}`;
    const g = state.game || {};
    const r = g.round || 1;
    const my = state.plays?.[state.uid];
    const isRoundOpen = !(g?.victory && g.victory.round === r && g.victory.uid);

    try{
     // ã¾ãšåº§å¸­ã‚’å¤–ã™
      await remove(ref(db, `${room}/seats/${state.mySeat}`));

      // å‹è€…æœªç¢ºå®šã‹ã¤ã€Œä»Šãƒ©ã‚¦ãƒ³ãƒ‰ã®è‡ªåˆ†ã®è¨˜éŒ²ã€ã‹ã¤ seat ãŒé›¢å¸­å‰ã®å¸­ç•ªå·ãªã‚‰æƒé™¤
      if (isRoundOpen && my && Number(my.round) === r && Number(my.seat) === Number(state.mySeat)) {
        await remove(ref(db, `${room}/plays/${state.uid}`));
      }
    }catch(_e){}
  }
  async function maybeFillStartFromSeat(){
    const room = `rooms/${state.code}`;
    const g = state.game || {};
    if (!g.playersN || !g.startSeat) return;
    const uid = seatUid(g.startSeat);
    if (uid && (!g.startUid || !g.turnUid)){
      await update(ref(db, `${room}/game`), { startUid: uid, turnUid: uid });
    }
  }

  // ç›¸å¯¾é…ç½®
  function seatedList(){
    return Object.entries(state.seats)
      .filter(([_,v])=>v && v.uid)
      .map(([k,v])=>({ seat:Number(k), uid:v.uid, name:v.name||'?' }))
      .sort((a,b)=>a.seat-b.seat);
  }
  function clockwiseOthers(){
    if (!state.mySeat) return [];
    const N = state.game?.playersN || state.playersN || 4;
    const cwOffset = (s)=> ((s.seat - state.mySeat + N) % N);
    return seatedList()
      .filter(s => s.seat !== state.mySeat)
      .sort((a,b) => cwOffset(a) - cwOffset(b));
  }
  function computeABCPositions(){
    const arr = clockwiseOthers();
    const N = state.game?.playersN || state.playersN || 4;
    const map = {};
    if (arr[0]) map.B = arr[0];
    if (N === 3){
      if (arr[1]) map.A = arr[1];
    }else{
      if (arr[1]) map.C = arr[1];
      if (arr[2]) map.A = arr[2];
    }
    return map;
  }
  function getHandForSeat(seatNumber){ return state.hands?.[String(seatNumber)] || []; }

  // ç›¸æ‰‹æ‰‡ã®è£é¢ãƒ¬ãƒ³ãƒ€
  function getOppCardDims(){
    const s = getComputedStyle(document.documentElement);
    const w = Math.round(parseFloat(s.getPropertyValue('--card-w-opp')) || 26);
    const h = Math.round(w / 0.714);
    return { w, h };
  }
  function renderFan(container, count, options={}){
    const maxSpreadDeg = options.maxSpreadDeg ?? 56;
    const radius = options.radius ?? 70;
    container.style.transform = `translate(-50%,-50%)`;
    container.innerHTML = '';
    if (count <= 0) return;
    const step = count > 1 ? (maxSpreadDeg / (count - 1)) : 0;
    const start = -maxSpreadDeg/2;
    const { w, h } = getOppCardDims();
    for (let i=0; i<count; i++){
      const angle = start + step * i;
      const card = document.createElement('div');
      card.className = 'card opp';
      card.style.width  = w + 'px';
      card.style.height = h + 'px';
      card.style.transform = `rotate(${angle}deg) translateY(-${radius}px) translateZ(0)`;
      card.style.zIndex = String(1000 + i);
      container.appendChild(card);
    }
  }

  // ===== è¡¨é¢ã‚«ãƒ¼ãƒ‰ï¼ˆè‡ªåˆ†ã®æ‰‹æœ­ï¼å ´ï¼‰ =====
  function makeCardFaceEl(cardId){
    const [color, idxStr] = cardId.split('-');
    const index = Number(idxStr);
    const coordString = CARD_DATA[color]?.[index];
    const positions = parseCoords(coordString||'').map(toPos);

    let minC=1, maxC=1, minR=1, maxR=1;
    if(positions.length){
      minC = Math.min(...positions.map(p=>p.col));
      maxC = Math.max(...positions.map(p=>p.col));
      minR = Math.min(...positions.map(p=>p.row));
      maxR = Math.max(...positions.map(p=>p.row));
    }
    const bboxCols = maxC - minC + 1;
    const bboxRows = maxR - minR + 1;

    const startCol = 1 + Math.floor((GRID_MAX.maxCol - bboxCols)/2);
    const startRow = 1 + Math.floor((GRID_MAX.maxRow - bboxRows)/2);

    const centered = new Set(
      positions.map(p=>{ const c = startCol + (p.col - minC); const r = startRow + (p.row - minR); return `${r}-${c}`; })
    );

    const box = document.createElement('div');
    box.className = 'cardbox';

    const face = document.createElement('div');
    face.className = `face ${color}`;

    // æ•°å­—ã¯ purple-0 ã§ã¯éè¡¨ç¤º
    if (!(color === 'purple' && index === 0)) {
      for(const cls of ['tl','tr','bl','br']){
        const n = document.createElement('div');
        n.className = `num ${cls}`;
        n.textContent = index;
        face.appendChild(n);
      }
    }

    const oval = document.createElement('div');
    oval.className = 'ovalBG';
    face.appendChild(oval);

    const grid = document.createElement('div');
    grid.className = 'grid';
    grid.style.setProperty('--cols', GRID_MAX.maxCol);
    grid.style.setProperty('--rows', GRID_MAX.maxRow);

    for(let r=1; r<=GRID_MAX.maxRow; r++){
      for(let c=1; c<=GRID_MAX.maxCol; c++){
        const cell = document.createElement('div');
        cell.className = 'cell' + (centered.has(`${r}-${c}`) ? ' filled' : '');
        grid.appendChild(cell);
      }
    }

    face.appendChild(grid);
    box.appendChild(face);

    // åŠã‚»ãƒ«è£œæ­£
    const ro = new ResizeObserver(()=>{
      const rect = grid.getBoundingClientRect();
      const cs = getComputedStyle(grid);
      const gapX = parseFloat(cs.getPropertyValue('column-gap') || cs.getPropertyValue('gap') || '0') || 0;
      const gapY = parseFloat(cs.getPropertyValue('row-gap')    || cs.getPropertyValue('gap') || '0') || 0;
      const cellW = (rect.width  - (GRID_MAX.maxCol - 1) * gapX) / GRID_MAX.maxCol;
      const cellH = (rect.height - (GRID_MAX.maxRow - 1) * gapY) / GRID_MAX.maxRow;
      const needX = (GRID_MAX.maxCol % 2) !== (bboxCols % 2);
      const needY = (GRID_MAX.maxRow % 2) !== (bboxRows % 2);
      const shiftX = needX ? (cellW + gapX) / 2 : 0;
      const shiftY = needY ? (cellH + gapY) / 2 : 0;
      grid.style.transform = `translate(${shiftX}px, ${shiftY}px)`;
    });
    ro.observe(grid);

    return box;
  }

  // ====== ã‚¿ãƒ¼ãƒ³ï¼é¸æŠãƒ­ã‚¸ãƒƒã‚¯ ======
  function myUid(){ return state.uid; }
  function isHost(){ return state.hostUid === state.uid; }
  function myHandIds(){
    if (!state.mySeat) return [];
    const arr = getHandForSeat(state.mySeat).slice();
    return arr.sort(compareCardIds);
  }
  function currentTurnUid(){ return state.game?.turnUid || null; }
  function isMyTurn(){ return currentTurnUid() === myUid(); }
  function getStartColor(){ return state.game?.startColor || null; }
  function startPlayerUid(){ return state.game?.startUid || null; }
  function playersN(){ return state.game?.playersN || state.playersN || 0; }

  function seatOfUid(uid){
    for(const k of Object.keys(state.seats||{})){
      if (state.seats[k]?.uid === uid) return Number(k);
    }
    return null;
  }
function isRoundClosed(){
  const g = state.game || {};
  const v = g.victory;
  // å‹è€…(uid)ãŒç¢ºå®šã—ãŸæ™‚ã ã‘ãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†æ‰±ã„
  return !!(v && v.round === g.round && v.uid);
}

  function orderUidsNow(){
    const g = state.game || {};
    const N = g.playersN || state.playersN || 0;
    if (!N || !g.orderSeats) return [];
    const arr=[];
    for(const seat of g.orderSeats){
      const uid = seatUid(seat);
      if (uid) arr.push(uid);
    }
    return arr;
  }

  function allowedSetForMyTurn(){
    const sc = getStartColor();
    const my = myHandIds();
    if (!sc) return new Set(my); // ã‚¹ã‚¿ãƒ¼ãƒˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æœ€åˆï¼šåˆ¶é™ãªã—
    const hasSame = my.some(id => parseCardId(id).color === sc);
    if (!hasSame) return new Set(my);
    return new Set(my.filter(id => parseCardId(id).color === sc));
  }


function renderDiscardPopup(){
  if (!trashContent) return;
  trashContent.innerHTML = '';

  const gy = state.graveyard || {};          // { red:[id...], ... }
  const colors = COLOR_ORDER;                // ['red','blue','green','yellow','purple']

  for (const color of colors){
    const row = document.createElement('div');
    row.className = 'row';

    const cards = document.createElement('div');
    cards.className = 'cards';

    // å…¨ã‚«ãƒ¼ãƒ‰ã‚’ 1-8 ã§ä¸¦ã¹ã‚‹ï¼ˆç´«0ã¯å¯¾è±¡å¤–ï¼‰
    for (let i = 1; i <= 8; i++){
      const id = `${color}-${i}`;
      const box = makeCardFaceEl(id);
      box.classList.add('sm');

      // æ¨ã¦æœ­ã«ç„¡ã„ã‚«ãƒ¼ãƒ‰ã¯è–„ã
      const discardedList = gy[color] || [];
      const isDiscarded = discardedList.includes(id);
      if (!isDiscarded) box.classList.add('dimmed');

      cards.appendChild(box);
    }

    row.appendChild(cards);
    trashContent.appendChild(row);
  }
}



  // UI å…¨ä½“æç”»
  function renderAll(){
    renderHands();
    renderPlays();
    renderVictoryWidgets();
  }

  function renderHands(){
    handBar.querySelectorAll('.cardbox').forEach(el=>el.remove());

    if (!state.mySeat){
      oppA.classList.add('hidden'); oppB.classList.add('hidden'); oppC.classList.add('hidden');
      return;
    }

    // è‡ªåˆ†ã®æ‰‹æœ­ï¼ˆè‰²â†’ç•ªå·æ˜‡é †ï¼‰
    const myCards = myHandIds();
    const turnMine = isMyTurn();
    const allowed = turnMine ? allowedSetForMyTurn() : new Set(myCards);
    const alreadyPlayedThisRound =
      !!(state.plays?.[state.uid] && Number(state.plays[state.uid].round) === (state.game?.round || 1));

    for (const cardId of myCards){
      const box = makeCardFaceEl(cardId);

      if (turnMine && !isRoundClosed() && allowed.has(cardId) && !alreadyPlayedThisRound){
        box.classList.add('clickable', 'pulsate');
        box.onclick = ()=> confirmMySelection(cardId);
      } else {
        box.onclick = null;
      }

      if (turnMine && !allowed.has(cardId)){
        box.classList.add('unplayable');
      }

      handBar.appendChild(box);
    }

    // ç›¸æ‰‹ï¼ˆ3åº§å¸­ã¨ã‚‚æ‰‡ã‚’è£é¢ã§æç”»ï¼‰
    const rel = computeABCPositions();
    const seatToCount = seat => getHandForSeat(seat).length;

    if (rel.A){
      oppA.classList.remove('hidden');
      const badge = oppA.querySelector('.badge'); if (badge) badge.textContent = `${rel.A.name}`;
      renderFan(oppA.querySelector('.fan'), seatToCount(rel.A.seat));
    }else{ oppA.classList.add('hidden'); }

    if (rel.B){
      oppB.classList.remove('hidden');
      const badge = oppB.querySelector('.badge'); if (badge) badge.textContent = `${rel.B.name}`;
      renderFan(oppB.querySelector('.fan'), seatToCount(rel.B.seat));
    }else{ oppB.classList.add('hidden'); }

    if (rel.C){
      oppC.classList.remove('hidden');
      const badge = oppC.querySelector('.badge'); if (badge) badge.textContent = `${rel.C.name}`;
      renderFan(oppC.querySelector('.fan'), seatToCount(rel.C.seat));
    }else{ oppC.classList.add('hidden'); }
  }

  // ===== â€œå ´â€ã®æç”» =====
  function renderPlays(){
    playMine.innerHTML = '';
    playA.innerHTML = ''; playB.innerHTML = ''; playC.innerHTML = '';

    if (!state.mySeat) return;
    const rel = computeABCPositions();

    // å‹è€…ã‚«ãƒ¼ãƒ‰ã‚¯ãƒªãƒƒã‚¯ â†’ ä¸­å¤®ãƒ”ãƒ¼ã‚¹ç”Ÿæˆï¼ˆå‹è€…æœ¬äººã®ã¿å¯ï¼‰
    const attachWinnerClickIfNeeded = (wrapEl, playObj)=>{
      const g = state.game || {};
      const v = g.victory;
      if (!v) return;

      const isWinner = (v.uid === playObj.uid) && (v.round === g.round);
      const iAmWinner = (playObj.uid === myUid());
      const centerExistsThisRound = !!(g.centerPiece && g.centerPiece.round === g.round);

      if (isWinner && iAmWinner && !centerExistsThisRound && skillMode === 'none'){
        // è‡ªåˆ†ã®å ´(#playMine)ã¯CSSã§ pointer-events:none ãªã®ã§ã€ã“ã“ã§æœ‰åŠ¹åŒ–ã™ã‚‹
        const mine = document.getElementById('playMine');
        if (mine) mine.style.pointerEvents = 'auto';

        wrapEl.classList.add('clickable');
        wrapEl.style.cursor = 'pointer';
        wrapEl.style.pointerEvents = 'auto';

  wrapEl.addEventListener('click', async ()=>{
    try{
      const g = state.game || {};
      const room = `rooms/${state.code}`;
      const arr = playsOfCurrentRound();                // ä»Šãƒ©ã‚¦ãƒ³ãƒ‰ã®å ´ã®å…¨ã‚«ãƒ¼ãƒ‰
      const N   = g.playersN || 0;

      // --- è¿½åŠ : å…¨å“¡åŒè‰²ãƒã‚§ãƒƒã‚¯ï¼ˆäººæ•°ã‚‚æƒã£ã¦ã„ã‚‹ã“ã¨ï¼‰ ---
      const allSame =
        Array.isArray(arr) &&
        arr.length === N &&
        new Set(arr.map(o=>o.color)).size === 1;

      // --- æ¡ä»¶ã‚’æº€ãŸã™å ´åˆã®ã¿ doubleScan ã‚’è¨˜éŒ² ---
      if (allSame){
        // indexï¼ˆæ•°å­—ï¼‰ãŒæœ€å°ã®ã‚‚ã®ã‚’æ¡ç”¨ï¼ˆåŒå€¤ã¯ COLOR_ORDER é †ï¼‰
        const order = COLOR_ORDER;
        const sorted = arr.slice().sort((a,b)=>{
          if (a.index !== b.index) return a.index - b.index;
          return order.indexOf(a.color) - order.indexOf(b.color);
        });
        const min = sorted[0];
        const rec = {
          cardId: min.cardId,
          color:  min.color,
          index:  min.index,
          round:  g.round || 1,
          ts:     Date.now()
        };
        await update(ref(db), { [`${room}/game/doubleScan`]: rec });
      }else{
        // åŒè‰²ã§ãªã‘ã‚Œã°èª¤è¡¨ç¤ºé˜²æ­¢ã®ãŸã‚å¿µã®ãŸã‚æ¶ˆã™
        await update(ref(db), { [`${room}/game/doubleScan`]: null });
      }

      // --- å¾“æ¥ã©ãŠã‚Šä¸­å¤®ãƒ”ãƒ¼ã‚¹ã‚’å‡ºç¾ ---
      await materializeCenterPieceFromWinner(playObj);
    }catch(_e){
      // noopï¼ˆãƒ­ã‚°ã¯ä¸è¦ãªã‚‰ç„¡è¦–ï¼‰
    }
  }, { once:true });

      }
    };

    const drawAt = (slotEl, uid)=>{
      const obj = state.plays?.[uid];
      if (!obj) return;
      const box = makeCardFaceEl(obj.cardId);
      const wrap = document.createElement('div');
      wrap.className = 'played';
      const vict = state.game?.victory;
      if (vict && vict.uid === uid && vict.round === state.game.round){
        wrap.classList.add('winner');
      }
      wrap.appendChild(box);
      slotEl.appendChild(wrap);

      // ã‚¯ãƒªãƒƒã‚¯ä»˜ä¸ï¼ˆå‹è€…ã®å ´ã‚«ãƒ¼ãƒ‰ã®ã¿ï¼‰
      attachWinnerClickIfNeeded(wrap, { uid, ...obj });
    };

    if (rel.A) drawAt(playA, rel.A.uid);
    if (rel.B) drawAt(playB, rel.B.uid);
    if (rel.C) drawAt(playC, rel.C.uid);

    // è‡ªåˆ†ï¼ˆç¢ºå®šæ¸ˆã¿ãªã‚‰å›ºå®šå ´ã«ï¼‰
    const my = state.plays?.[state.uid];
    if (my){
      const box = makeCardFaceEl(my.cardId);
      const wrap = document.createElement('div');
      wrap.className = 'played';
      const vict = state.game?.victory;
      if (vict && vict.uid === state.uid && vict.round === state.game.round){
        wrap.classList.add('winner');
      }
      wrap.appendChild(box);
      playMine.innerHTML = '';
      playMine.appendChild(wrap);

      // è‡ªåˆ†ãŒå‹è€…ã®æ™‚ã€ã‚¯ãƒªãƒƒã‚¯æœ‰åŠ¹åŒ–
      attachWinnerClickIfNeeded(wrap, { uid: state.uid, ...my });
    }
  }

  // ã‚¯ãƒªãƒƒã‚¯å³ç¢ºå®šï¼ˆå¤‰æ›´ä¸å¯ï¼‰
  async function confirmMySelection(cardId){
    if (!isMyTurn() || !cardId) return;
    if (state.plays?.[state.uid]) return; // æ—¢ã«ç¢ºå®šæ¸ˆã¿

    const g = state.game || {};
    const round = g.round || 1;
    const [color, idxStr] = cardId.split('-');
    const index = Number(idxStr);
    const mySeatNum = state.mySeat;
    const room = `rooms/${state.code}`;

    const playObj = { cardId, color, index, seat: mySeatNum, round, ts: Date.now() };
    await set(ref(db, `${room}/plays/${state.uid}`), playObj);

    const current = (state.hands?.[String(mySeatNum)]||[]).slice();
    const nextArr = current.filter(x => x !== cardId);
    await set(ref(db, `${room}/hands/${mySeatNum}`), nextArr);

    const startUid = startPlayerUid();
    const updates = {};
    if (!g.startColor && startUid === myUid()){
      updates[`${room}/game/startColor`] = color;
      updates[`${room}/game/startColors/${round}`] = color;
    }

    const order = orderUidsNow();
    const curIdx = order.indexOf(myUid());
    const nextIdx = (curIdx >= 0) ? ( (curIdx + 1) % order.length ) : 0;
    const nextUid = order[nextIdx] || null;
    updates[`${room}/game/turnUid`] = nextUid;

    if (Object.keys(updates).length){
      await update(ref(db), updates);
    }
  }

  // ===== å‹è€…åˆ¤å®šï¼ˆãƒ›ã‚¹ãƒˆã®ã¿å®Ÿæ–½ï¼‰ =====
  function playsOfCurrentRound(){
    const g = state.game || {};
    const round = g.round || 1;
    const entries = Object.entries(state.plays || {});
    return entries
      .map(([uid, obj]) => ({ uid, ...obj }))
      .filter(o => o && Number(o.round) === round);
  }

  async function maybeComputeVictory(){
    if (!isHost()) return;
    const g = state.game || {};
    const N = g.playersN || 0;
    if (!N) return;

    const arr = playsOfCurrentRound();
    if (arr.length !== N) return; // ã¾ã æƒã£ã¦ã„ãªã„
if (g.victory && g.victory.round === g.round && g.victory.uid) return;

    const prevColor = g.prevVictoryColor || null;
    let candidates = [];
    if (prevColor){
      candidates = arr.filter(o => o.color === prevColor);
    }
    if (candidates.length === 0){
      const sc = g.startColor;
      candidates = arr.filter(o => o.color === sc);
    }
    candidates.sort((a,b)=> b.index - a.index);
    const winner = candidates[0] || arr[0];

    const room = `rooms/${state.code}`;
    const victoryObj = { cardId: winner.cardId, uid: winner.uid, color: winner.color, index: winner.index, round: g.round, seat: winner.seat, ts: Date.now() };

    await update(ref(db), {
      [`${room}/game/victory`]: victoryObj,
      [`${room}/game/prevVictoryColor`]: winner.color,
      [`${room}/game/turnUid`]: null          // â˜… å‹æ•—ç¢ºå®šã§æ‰‹ç•ªã‚’åœæ­¢
    });
  }

// è¿½åŠ ï¼šãƒ†ãƒ¼ãƒ–ãƒ«å‚ç…§ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ä¸Šéƒ¨ã® DOM å–å¾—ç¾¤ã®è¿‘ãã«ï¼‰
const tableArea = document.getElementById('tableArea');

// æ—¢å­˜ã® cp-handles ã®ã‚¯ãƒªãƒƒã‚¯ä¼æ’­ã‚’æ­¢ã‚ã‚‹å‡¦ç†ã¯æµç”¨

// ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ï¼šã‚«ãƒ¼ãƒ‰å®šç¾©æ–‡å­—åˆ— â†’ ã‚»ãƒ«é…åˆ— â†’ æœ€å°å¤–æ¥ã§æ­£è¦åŒ–
function parseCells(str){
  const out=[]; const re=/([A-Z])(\d+)/g; let m;
  while((m=re.exec(str))!==null){ out.push({r:m[1].charCodeAt(0)-65, c:parseInt(m[2],10)-1}); }
  return out;
}
function normalizeCells(cells){
  const minR=Math.min(...cells.map(v=>v.r)), minC=Math.min(...cells.map(v=>v.c));
  const rel=cells.map(v=>({r:v.r-minR, c:v.c-minC}));
  return { rel, rows: Math.max(...rel.map(v=>v.r))+1, cols: Math.max(...rel.map(v=>v.c))+1 };
}


function applyPieceTransform(el, cp){
  const { x=0, y=0, angle=0, flipX=1, flipY=1 } = cp || {};
  // x,y ã¯ã€Œä¸­å¿ƒåº§æ¨™ã€ã€‚å·¦ä¸Šèµ·ç‚¹â†’ä¸­å¿ƒèµ·ç‚¹ã«è£œæ­£ã™ã‚‹ãŸã‚ã®  -50%,-50%  ã‚’å¾Œæ®µã«å…¥ã‚Œã‚‹
  el.style.transform =
    `translate(${x}px, ${y}px) translate(-50%,-50%) rotate(${angle}deg) scale(${flipX},${flipY})`;
}

function renderCenterPiecesNow(){
  const g   = state.game || {};
  const cps = g.centerPieces || {};
  const container = centerPiece;   // id="centerPiece" ã‚³ãƒ³ãƒ†ãƒŠ
  container.innerHTML = '';

  // ãƒ©ã‚¦ãƒ³ãƒ‰æ˜‡é †ã§å®‰å®šæç”»ï¼ˆã‚­ãƒ¼ãŒæ•°å€¤ä»¥å¤–ã§ã‚‚è½ã¡ãªã„ã‚ˆã†ã«å®‰å…¨æ¯”è¼ƒï¼‰
  const entries = Object.entries(cps).sort((a,b)=>{
    const na = Number(a[0]); const nb = Number(b[0]);
    if (Number.isNaN(na) && Number.isNaN(nb)) return String(a[0]).localeCompare(String(b[0]));
    if (Number.isNaN(na)) return 1;
    if (Number.isNaN(nb)) return -1;
    return na - nb;
  });

  // å³ä¸Šã®â€œåè»¢â€ãƒœã‚¿ãƒ³ç”¨ï¼šã‚¯ãƒªãƒƒã‚¯ä¼æ’­æŠ‘æ­¢ã¯ãƒãƒ³ãƒ‰ãƒ«ã«éƒ½åº¦ä»˜ä¸ã™ã‚‹
  const roomBase = `rooms/${state.code}/game/centerPieces`;

  // --- ã‚„ã‚Šç›´ã—ãƒãƒƒãƒ—å‚ç…§ã¨æŒ™å‹• ---
  const redoPopup   = document.getElementById('redoPopup');
  const redoOk      = document.getElementById('redoOk');
  const redoCancel  = document.getElementById('redoCancel');

  function openRedoPopup(round){
    state.editingRound = round;            // å¯¾è±¡ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’ä¿æŒ
    redoPopup?.classList.remove('hidden');
  }
  function closeRedoPopup(){
    // â˜… ãƒ•ãƒ©ã‚°ã¯æ¶ˆã•ãšã€éš ã™ã ã‘ï¼ˆOKå¾Œã®æ“ä½œè¨±å¯ã®ãŸã‚ï¼‰
    redoPopup?.classList.add('hidden');
  }

  // é‡è¤‡ãƒã‚¤ãƒ³ãƒ‰é˜²æ­¢ã®ãŸã‚ onclick ã‚’ä½¿ç”¨
  if (redoOk) {
    redoOk.onclick = ()=>{
      // OK â†’ editingRound ã‚’ä¿æŒã—ãŸã¾ã¾å†æç”» â†’ ãƒãƒƒãƒ—ã‚’é–‰ã˜ã‚‹
      renderCenterPiecesNow();
      closeRedoPopup();
    };
  }
  if (redoCancel) {
    redoCancel.onclick = ()=>{
      // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ï¼Esc ã¯ç·¨é›†ä¸­ãƒ•ãƒ©ã‚°ã‚’ç ´æ£„ã—ã¦é–‰ã˜ã‚‹
      state.editingRound = null;
      closeRedoPopup();
    };
  }
  document.addEventListener('keydown', e=>{
    if (e.key === 'Escape' && !redoPopup.classList.contains('hidden')){
      state.editingRound = null;
      closeRedoPopup();
    }
  });

  // --- å„ãƒ©ã‚¦ãƒ³ãƒ‰ã®ãƒ”ãƒ¼ã‚¹æç”» ---
  for (const [roundStr, cpOrList] of entries){
    const round = Number(roundStr);
    // å¾Œæ–¹äº’æ›ï¼šå˜ä¸€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼é…åˆ—ã®ä¸¡å¯¾å¿œ
    const list = Array.isArray(cpOrList) ? cpOrList : [cpOrList];

    list.forEach((cp, idx)=>{
      if (!cp || !cp.color || !cp.index) return;

      // å½¢ã®ç”Ÿæˆï¼ˆæ—¢å­˜ CARD_DATA ã‚’ä½¿ç”¨ï¼‰
      const def = CARD_DATA[cp.color]?.[cp.index] || '';
      const parsed = parseCells(def);
      if (!parsed.length) return;
      const { rel, rows, cols } = normalizeCells(parsed);

      const host = document.createElement('div');
      host.className = `center-piece ${cp.color||''}`;
      host.style.setProperty('--cols', cols);

      for (let r=0; r<rows; r++){
        for (let c=0; c<cols; c++){
          const cell=document.createElement('div');
          cell.className='cp-cell';
          if (rel.some(v=>v.r===r && v.c===c)) cell.classList.add('filled');
          host.appendChild(cell);
        }
      }

      // ä½ç½®ãƒ»å§¿å‹¢ã®é©ç”¨ï¼ˆä¸­å¤®ä½ç½®ã®ã‚ºãƒ¬é˜²æ­¢ã¯ applyPieceTransform ã«ä¸€æœ¬åŒ–ï¼‰
      applyPieceTransform(host, cp);

      // === æ“ä½œæ¨©é™ã¨ãƒãƒ³ãƒ‰ãƒ« ===
      const isMyWinPiece   = !!(cp?.uid && cp.uid === state.uid);
      const isCurrentRound = (g.round || 1) === round;
      const allowOps = isMyWinPiece && (isCurrentRound || state.editingRound === round);

      // â€œã‚„ã‚Šç›´ã—â€ãƒãƒƒãƒ—ï¼ˆè‡ªåˆ†å‹åˆ©ãƒ”ãƒ¼ã‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯æ™‚ã€‚æ—¢ã«æ“ä½œå¯ãªã‚‰å‡ºã•ãªã„ï¼‰
      if (isMyWinPiece){
        host.style.cursor = 'pointer';
        host.addEventListener('click', (e)=>{
          if (!allowOps){ e.stopPropagation(); openRedoPopup(round); }
        });
      }

      if (allowOps){
        // åè»¢ãƒœã‚¿ãƒ³
        const handles=document.createElement('div');
        handles.className='cp-handles';
        const btnX=document.createElement('button'); btnX.className='flip-btn'; btnX.textContent='â‡”';
        const btnY=document.createElement('button'); btnY.className='flip-btn'; btnY.textContent='â‡•';
        handles.appendChild(btnX); handles.appendChild(btnY);
        host.appendChild(handles);

        // è¤‡æ•°ãƒ”ãƒ¼ã‚¹å¯¾å¿œï¼šä¿å­˜ãƒ‘ã‚¹ã¯é…åˆ—è¦ç´ ã‚’ç›´æ¥
        const savePath = Array.isArray(cps[roundStr])
          ? `${roomBase}/${round}/${idx}`
          : `${roomBase}/${round}`;

        ['pointerdown','pointerup','click'].forEach(ev=>{
          [btnX,btnY,handles].forEach(el=>el.addEventListener(ev, e=>e.stopPropagation(), {passive:false}));
        });
        btnX.onclick = async ()=>{
          const cur = (state.game?.centerPieces?.[round]?.[idx]?.flipX ?? state.game?.centerPieces?.[round]?.flipX) === -1 ? 1 : -1;
          await update(ref(db), { [`${savePath}/flipX`]: cur });
        };
        btnY.onclick = async ()=>{
          const cur = (state.game?.centerPieces?.[round]?.[idx]?.flipY ?? state.game?.centerPieces?.[round]?.flipY) === -1 ? 1 : -1;
          await update(ref(db), { [`${savePath}/flipY`]: cur });
        };

        // ãƒ‰ãƒ©ãƒƒã‚°ï¼†å›è»¢ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§90åº¦å›è»¢ï¼ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•ï¼‰
        enablePieceDragRotate(host, savePath, round);
      }

      container.appendChild(host);
    });
  }
}


async function rotateCenterBy90(){
  const g = state.game || {}; const r = g.round || 1;
  const cp = g.centerPieces?.[r]; if (!cp) return;
  const room = `rooms/${state.code}`;
  const next = ((cp.angle||0) + 90) % 360;
  await update(ref(db), { [`${room}/game/centerPieces/${r}/angle`]: next });
}

async function toggleCenterFlip(axis){
  const g = state.game || {}; const r = g.round || 1;
  const cp = g.centerPieces?.[r]; if (!cp) return;
  const room = `rooms/${state.code}`;
  if (axis === 'X'){
    const next = (cp.flipX===-1)? 1 : -1;
    await update(ref(db), { [`${room}/game/centerPieces/${r}/flipX`]: next });
  }else{
    const next = (cp.flipY===-1)? 1 : -1;
    await update(ref(db), { [`${room}/game/centerPieces/${r}/flipY`]: next });
  }

  }

  // å‹è€…å ´ã‚«ãƒ¼ãƒ‰ã®ã‚¯ãƒªãƒƒã‚¯ã§ç™ºç«ï¼ˆå‹è€…æœ¬äººã®ã¿ï¼‰
async function materializeCenterPieceFromWinner(winnerPlay){
  const g = state.game || {};
  const room = `rooms/${state.code}`;

  // ãƒ†ãƒ¼ãƒ–ãƒ«ä¸­å¤®ã‚ãŸã‚Šã«åˆæœŸé…ç½®
  const rect = tableArea.getBoundingClientRect();
  const initX = rect.width / 2;
  const initY = rect.height * 0.55;

  const centerPieceObj = {
    cardId: winnerPlay.cardId,
    color:  winnerPlay.color,
    index:  winnerPlay.index,
    round:  g.round || 1,
    uid:    winnerPlay.uid,
    angle:  0,
    flipX:  1,
    flipY:  1,
    x:      initX,
    y:      initY,
    ts:     Date.now()
  };


  {
    const curRound = g.round || 1;
    const playsObj = state.plays || {};
    const arr = Object.values(playsObj).filter(p => (p?.round || curRound) === curRound);
    const byColor = {};
    for (const p of arr){
      if (!p?.cardId || !p?.color) continue;
      (byColor[p.color] ||= []).push(p.cardId);
    }
    // æ—¢å­˜ã®æ¨ã¦æœ­ã«è¿½è¨˜ï¼ˆé…åˆ—ã‚’å¾Œã‚ã«é€£çµï¼‰
    if (Object.keys(byColor).length){
      await runTransaction(ref(db, `${room}/graveyard`), cur=>{
        const out = cur || {};
        for (const c of Object.keys(byColor)){
          out[c] = Array.isArray(out[c]) ? out[c].concat(byColor[c]) : byColor[c].slice();
        }
        return out;
      }, { applyLocally:false });
    }
  }

  await update(ref(db), {
    [`${room}/plays`]: null,
  [`${room}/game/centerPieces/${g.round || 1}`]: centerPieceObj,
    [`${room}/game/turnUid`]: null
  });
}


function enablePieceDragRotate(el, savePath, roundOverride){
  let dragging=false, moved=false;
  let sx=0, sy=0, ox=0, oy=0;

  // savePath æœ«å°¾ã® /{round}/{idx} ã‚’èª­ã‚€ï¼ˆidx ã¯ä»»æ„ï¼‰
  function pickCpOfThis(elRound){
    const g = state.game || {};
    const cpRaw = g.centerPieces && g.centerPieces[elRound];
    const m = savePath.match(/centerPieces\/(\d+)(?:\/(\d+))?$/);
    const idx = m && m[2] != null ? Number(m[2]) : null;
    if (Array.isArray(cpRaw)) return (idx!=null ? (cpRaw[idx]||{}) : (cpRaw[0]||{}));
    return cpRaw || {};
  }

  el.onpointerdown = (e)=>{
    if (e.target.classList.contains('flip-btn')) return;
    el.setPointerCapture(e.pointerId);
    const g = state.game || {};
    const r = Number(roundOverride) || (g.round || 1);
    const cp0 = pickCpOfThis(r);
    sx = e.clientX; sy = e.clientY;
    ox = cp0.x || 0; oy = cp0.y || 0;
    dragging = true; moved = false;
    el.classList.add('dragging');
  };

  el.onpointermove = (e)=>{
    if (!dragging) return;
    const dx = e.clientX - sx, dy = e.clientY - sy;
    if (!moved && Math.hypot(dx,dy) > 3) moved = true;

    // ãƒ­ãƒ¼ã‚«ãƒ«è¦‹ãŸç›®ã ã‘å…ˆã«åæ˜ ï¼ˆã“ã®è¦ç´ ã® cp ã‚’åŸºæº–ã«ï¼‰
    const g = state.game || {};
    const r = Number(roundOverride) || (g.round || 1);
    const cp0 = { ...pickCpOfThis(r) };
    cp0.x = ox + dx; cp0.y = oy + dy;
    applyPieceTransform(el, cp0);
  };

  el.onpointerup = el.onpointercancel = async (e)=>{
    if (!dragging) return;
    dragging = false;
    el.classList.remove('dragging');

    const dx = e.clientX - sx, dy = e.clientY - sy;
    const movedEnough = Math.hypot(dx,dy) > 3;

    if (!movedEnough){
      // ã‚¯ãƒªãƒƒã‚¯ â†’ 90åº¦å›è»¢ï¼ˆã“ã®è¦ç´ ã® cp ã‚’åŸºæº–ã«ï¼‰
      const g = state.game || {};
      const r = Number(roundOverride) || (g.round || 1);
      const cp0 = pickCpOfThis(r);
      const next = ((cp0.angle||0) + 90) % 360;
      await update(ref(db), { [`${savePath}/angle`]: next });
    } else {
      // x,y ã‚’ç¢ºå®š
      const newX = ox + dx, newY = oy + dy;
      await update(ref(db), { [`${savePath}/x`]: newX, [`${savePath}/y`]: newY });
    }
  };
}


  function renderVictoryWidgets(){

    const g = state.game || {};
    const v = g.victory || null;

    // å·¦ä¸Šï¼šæœ€æ–°ã®ãƒ“ã‚¯ãƒˆãƒªãƒ¼ã‚«ãƒ¼ãƒ‰
    if (v && v.cardId){
      victoryArea.classList.remove('hidden');
      victoryCardBox.innerHTML = '';
      const box = makeCardFaceEl(v.cardId);
      victoryCardBox.appendChild(box);
    }else{
      victoryArea.classList.add('hidden');
    }

    // å·¦ä¸‹ï¼šæ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰ï¼ˆãƒ›ã‚¹ãƒˆã®ã¿ãƒ»å‹è€…ç¢ºå®šå¾Œï¼‰
const shouldShowNext = !!(v && v.round === g.round && v.uid === state.uid);    show(nextPanel, shouldShowNext);

    // â˜… ä¸­å¤®ãƒ”ãƒ¼ã‚¹ï¼ˆå¸¸ã«åŒæœŸæç”»ï¼‰
renderCenterPiecesNow();
  }

  // æ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰é–‹å§‹ï¼šâ˜… å‹è€…ã¾ãŸã¯ãƒ›ã‚¹ãƒˆãŒæŠ¼ã›ã‚‹ï¼ˆä¸­å¤®ãƒ”ãƒ¼ã‚¹ã¯æ¶ˆã•ãªã„ï¼ä¿æŒï¼‰
  btnNextRound.addEventListener('click', async ()=>{
    const g = state.game || {};
    const v = g.victory;

  // â˜… ã‚„ã‚Šç›´ã—è§£é™¤å‡¦ç†
  if (state.editingRound !== null){
    state.editingRound = null;
    // ãƒãƒƒãƒ—ã‚’é–‰ã˜ã‚‹
    show(document.getElementById('redoPopup'), false);

    // ã„ã¾è¡¨ç¤ºä¸­ã® centerPiece ã‚’å–å¾—ã—ã¦ä¿å­˜
    const cpEls = centerPiece.querySelectorAll('.center-piece');
    cpEls.forEach(async el=>{
      const round = el.dataset.round;
      if (!round) return;
      const cp = {
        color: el.dataset.color,
        index: Number(el.dataset.index),
        round: Number(round),
        x: parseFloat(el.dataset.x)||0,
        y: parseFloat(el.dataset.y)||0,
        angle: parseFloat(el.dataset.angle)||0,
        flipX: parseFloat(el.dataset.flipX)||1,
        flipY: parseFloat(el.dataset.flipY)||1,
        ts: Date.now()
      };
      await update(ref(db), {
        [`${room}/game/centerPieces/${round}`]: cp
      });
    });
  }

    // å‹è€…ç¢ºå®šã—ã¦ã„ã¦ã€ã‹ã¤ä»Šãƒ©ã‚¦ãƒ³ãƒ‰ã®å‹è€…ã‹ï¼Ÿ
    if (!v || v.round !== g.round) return;
    // å®Ÿè¡Œæ¨©é™ï¼šå‹è€…æœ¬äºº or ãƒ›ã‚¹ãƒˆ
    const canProceed = (v.uid === state.uid) || isHost();
    if (!canProceed) return;
    const room = `rooms/${state.code}`;
    const N = g.playersN || 0;

    const startSeatNext = v.seat || seatOfUid(v.uid) || g.startSeat;
    const orderSeats = orderSeatsFrom(startSeatNext, N);
    const startUidNext = seatUid(startSeatNext) || v.uid || g.startUid;

    const updates = {};
    updates[`${room}/game/round`] = (g.round||1) + 1;
    updates[`${room}/game/startSeat`] = startSeatNext;
    updates[`${room}/game/orderSeats`] = orderSeats;
    updates[`${room}/game/startUid`] = startUidNext || null;
    updates[`${room}/game/turnUid`] = startUidNext || null;
    updates[`${room}/game/startColor`] = null;
    // updates[`${room}/game/centerPiece`] = null; // â† æ¶ˆã•ãªã„ï¼
    updates[`${room}/plays`] = null;

    await update(ref(db), updates);
  });

  // ===== æç”»èµ·ç‚¹ =====
  window.addEventListener('beforeunload', ()=>{
    if (!state.joined) return;
    if (state.mySeat){
      remove(ref(db, `rooms/${state.code}/seats/${state.mySeat}`)).catch(()=>{});
    }
  });
</script>
</body>
</html>
