<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ザ・カカポ</title>
<style>
  :root{
    --card-w: 56px;                 /* 自分の手札カード幅（表面レンダ） */
    --card-w-opp: calc(64px * .4);  /* 相手の裏面カード幅（自分の約40%） */
    --card-r: 10px;
    --card-r-opp: 4px;              /* 他プレイヤーの角丸を抑える */
    --gap: 10px;
    --hand-h: 104px;                /* 画面下の手札バー高さ目安 */

    /* 相手エリアを外側へ寄せる量（まとめて調整） */
    --opp-shift: 28px;

    /* カード表面 */
    --grid-gap: 2px;
    --radius: 8px;
    --paper: #fff;

    /* 決定色（ディシジョン）：常に紫 */
    --decision-color: #8e24aa;

    /* 中央12x12のセルサイズ */
    --center-cell: 28px;
    /* カード面セル（カードの中のミニ格子） */
    --cell-size: 8px;
  }

  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#fff;color:#111}
  header{display:flex;justify-content:space-between;align-items:center;padding:12px;border-bottom:1px solid #eee;gap:8px}
  h1{margin:0;font-size:18px}
  .small{font-size:12px;opacity:.85;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .copybtn{padding:6px 10px;border:1px solid #ddd;border-radius:10px;background:#f7f7f7;cursor:pointer}
  main{padding:14px;display:grid;gap:16px;max-width:1100px;margin:0 auto; padding-bottom: calc(var(--hand-h) + 24px);}  

  .join-box{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .join-box input{padding:10px;border:1px solid #ddd;border-radius:8px;font-size:16px}
  .btn{padding:10px 14px;border:1px solid #ddd;border-radius:10px;background:#111;color:#fff;cursor:pointer}
  .btn.ghost{background:#189e6b;}
  .btn.sm{padding:6px 10px;border-radius:8px}
  .hidden{display:none !important}
  .muted{opacity:.7; font-size:13px}

  /* 右下：設定(FAB) */
  .fab{
    position:fixed; right:16px; bottom:16px; z-index:70;
    width:48px; height:48px; border-radius:50%;
    display:flex; align-items:center; justify-content:center;
    background:#111; color:#fff; border:1px solid #000; cursor:pointer;
    box-shadow:0 6px 18px rgba(0,0,0,.2);
  }

  /* テーブル＆場配置 */
  .table-area{ position:relative; min-height:420px; border:none; border-radius:0; padding:0; overflow:visible; }
  .badge{display:inline-block;padding:2px 8px;border-radius:999px;background:#111;color:#fff;font-size:12px}

  /* 相手エリア（3人とも同じ形・同じ向き） */
  .opp{ position:absolute; width:240px; height:180px; display:block; }
  .opp.A{left: calc(-150px - var(--opp-shift)); top:50%; transform:translateY(-50%);} /* 左 */
  .opp.B{right:calc(-150px - var(--opp-shift)); top:50%; transform:translateY(-50%);} /* 右 */
  .opp.C{left:50%; top: calc(-20px - var(--opp-shift)); transform:translateX(-50%);}    /* 上 */

  .opp .badge{
    background: #f6f0e6; color:#111; border:2px dashed #333; border-radius:10px; padding:4px 10px; font-weight:700; font-size:12px;
    position:absolute; left:50%; bottom:100px; transform:translateX(-50%);
  }

  /* 扇の土台（全員“上向き”で統一） */
  .fan{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:0; height:0; }
  .fan .card.opp{
    position:absolute; left:0; top:0; width: var(--card-w-opp); height: calc(var(--card-w-opp) / 0.714);
    border:1px solid #ddd; border-radius: var(--card-r-opp);
    background: url("kakapocardback.jpg") center/cover no-repeat;
    transform-origin:50% 100%; will-change: transform; backface-visibility: hidden; transform: translateZ(0);
    pointer-events:none;
  }

  /* 自分の手札バー */
  .handbar{
    position:fixed; left:0; right:0; bottom: calc(env(safe-area-inset-bottom) + 10px);
    z-index:40; display:flex; gap:8px; flex-wrap:wrap; justify-content:center;
    padding:10px 12px 14px; background:linear-gradient(to bottom, rgba(255,255,255,.0), rgba(255,255,255,.7) 40%, rgba(255,255,255,.95));
    backdrop-filter: blur(2px); min-height: var(--hand-h);
  }

  /* 汎用カード箱（自分/場の表面） */
  .cardbox{ width:var(--card-w); aspect-ratio: 63.5 / 88.9; display:flex; align-items:center; justify-content:center; }
  .clickable{ cursor:pointer; }
  .unplayable{ opacity:.35; filter:grayscale(60%); pointer-events:none; }

  /* “場”スロット */
  .play-slot{ position:absolute; display:flex; align-items:center; justify-content:center; z-index:4; }
  .play-mine-fixed{ position:fixed; left:50%; bottom: calc(var(--hand-h) + 3px); transform:translateX(-50%); z-index:45; display:flex; align-items:center; justify-content:center; }
  .play-A{ left: calc(70px - var(--opp-shift)); top:60%; transform:translateY(-50%);}  /* 左の場 */
  .play-B{ right:calc(40px - var(--opp-shift)); top:60%; transform:translateY(-50%);} /* 右の場 */
  .play-C{ left:50%; top:  calc(110px - var(--opp-shift)); transform:translate(-50%, 0);}   /* 上の場 */
  .played.winner .cardbox{ transform: scale(1.3); transform-origin:center; }

  /* ========= 40枚カードの表面スタイル ========= */
  .face{ position:relative; width: 100%; height: 100%; background:var(--paper); border:2px solid var(--color, #999); border-radius: var(--radius); padding: 10px; box-shadow: 0 2px 10px rgba(0,0,0,.06); color: var(--color, #666); display:flex; justify-content:center; align-items:center; overflow:hidden; }
  .ovalBG{ position:absolute; left:50%; top:50%; width:72%; height:64%; transform:translate(-50%,-50%) rotate(18deg); background: currentColor; border-radius: 42% / 58%; pointer-events:none; z-index:0;  }
  .num{ position:absolute; font-weight:800; font-size:14px; line-height:1; color: var(--color, #666); user-select:none; }
  .tl{ top:4px; left:4px; } .tr{ top:4px; right:4px; } .bl{ bottom:4px; left:4px; transform: rotate(180deg); } .br{ bottom:4px; right:4px; transform: rotate(180deg); }

  /* カード内の小さな格子（空セルは透明） */
  .grid{
    display:grid;
    grid-template-columns: repeat(var(--cols), var(--cell-size));
    grid-template-rows: repeat(var(--rows), var(--cell-size));
    gap: 0;
    justify-content:center;
    align-content:center;
  }
  .cell{ width:var(--cell-size); height:var(--cell-size); }
  .cell.filled{
    background: currentColor;
    border-radius: .4px;
    border: 1px solid #fff;
    z-index: 2;
  }

  /* 色テーマ */
  .red   { --color:#e53935; color:#e53935; }
  .blue  { --color:#1e88e5; color:#1e88e5; }
  .green { --color:#43a047; color:#43a047; }
  .yellow{ --color:#fdd835; color:#fdd835; }
  .purple{ --color:#8e24aa; color:#8e24aa; }

  /* 左上：ディシジョンカード表示 */
  .victoryArea{ position:fixed; left:12px; top:60px; z-index:50; display:flex; flex-direction:column; align-items:center; gap:6px; background:rgba(255,255,255,.9); border:1px solid #eee; border-radius:12px; padding:8px 10px; box-shadow:0 4px 20px rgba(0,0,0,.08); }
  .victoryArea .title{ font-size:12px; opacity:.8; font-weight:700; }
  .victoryArea .cardbox{ transform: scale(1.1); }


  /* 右下：次ラウンド（緑） */
  .nextPanel{ position:fixed; right:12px; bottom:12px; z-index:55; display:flex; align-items:center; justify-content:center; background:transparent; border:none; padding:0; }
  .nextBtn{ border:2px solid #2e7d32; color:#fff; background:#2e7d32; padding:10px 16px; border-radius:999px; font-weight:700; cursor:pointer; box-shadow:0 4px 12px rgba(0,0,0,.12); }
/* 左下：ゴミ箱（FAB） */
.trashBtn{
  position:fixed; left:12px; bottom:12px; z-index:56;
  width:48px; height:48px; border-radius:50%;
  display:flex; align-items:center; justify-content:center;
  background:#111; color:#fff; border:1px solid #000; cursor:pointer;
  box-shadow:0 6px 18px rgba(0,0,0,.2);
}

/* 捨て札ポップ（ボトムシート） */
.trash-panel{
  position:relative;
  background:rgba(255,255,255,.98);
  border-radius:16px;                 /* ← 上下すべての角を丸く */
  border:1px solid #eee;              /* ← 上だけでなく全面ボーダー */
  box-shadow:0 4px 30px rgba(0,0,0,.12);
  padding:10px 12px;
  width:min(680px, calc(100vw - 32px));
  margin:0 auto;
}

.trash-grid{
  display:flex;flex-direction:column;gap:10px;
}
.trash-row{
  display:flex;align-items:center;gap:8px;flex-wrap:wrap;
}
.trash-row .label{
  font-weight:700;width:64px;text-transform:capitalize;
}
.dim{ opacity:.45; filter:grayscale(30%); }

  /* 出せるカードの鼓動アニメ（自分の手番のみ適用） */
  @keyframes pulse12 { 0% { transform: scale(1.0); } 50% { transform: scale(1.2); } 100% { transform: scale(1.0); } }
  .pulsate { animation: pulse12 1.2s ease-in-out infinite; transform-origin:center; }

  /* ダブルスキャンUI（右側） */
  #doubleScanArea { left: 120px; top: 60px; }
  .doubleScan { display:flex; flex-direction:column; align-items:center; margin-bottom:6px; }
  .doubleScan .label { font-size:12px; font-weight:700; margin-bottom:4px; }
  .doubleScan .circles { display:flex; gap:6px; }
  .doubleScan .circles span { width:14px; height:14px; border-radius:50%; background:#000; display:inline-block; }
  .blank-card { border:2px dashed #999; border-radius: var(--radius); width: var(--card-w); aspect-ratio: 63.5 / 88.9; background: transparent; }

/* ▼ 中央 12x12 グリッド（背景に画像、上に罫線） */
.center-grid{
  position:absolute;
  left:50%; top:80%;
  transform:translate(-50%,-50%);
  width: calc(12 * var(--center-cell));
  height: calc(12 * var(--center-cell));
  /* 上から順に前面 → 背面。罫線を前面、画像を背面に配置 */
  background:
    linear-gradient(to right, black 1px, transparent 1px) 0 0/var(--center-cell) var(--center-cell),
    linear-gradient(to bottom, black 1px, transparent 1px) 0 0/var(--center-cell) var(--center-cell),
    url("celltable.jpg") center/cover no-repeat;
  /* 画像が見えるように白ベールは撤去 */
  border: 1px solid #d0d0d0;
  border-radius: 0;
  z-index: 1;
  pointer-events: none; /* 誤タップ防止：上のカード操作を邪魔しない */
}


  /* ▼ ピース（ドラッグ対象）を載せるレイヤ */
  .center-piece-layer{
    position:absolute;
    left:50%; top:80%;
    transform:translate(-50%,-50%);
    width: calc(12 * var(--center-cell));
    height: calc(12 * var(--center-cell));
  z-index: 60;           /* 中央ピースが play-slot(4) や handbar(45) より前に来るように */
  pointer-events: auto;
  touch-action: none;    /* 念のため */

  }
.piece{
  position:absolute; left:0; top:0;
  transform-origin: 0 0; /* 左上基準で回転/反転 → セル目にピッタリ */
  /* 幅・高さは JS で --w, --h を設定（セル数） */
  width: calc(var(--w) * var(--center-cell));
  height: calc(var(--h) * var(--center-cell));
  cursor: grab;
  touch-action: none; /* スクロール抑止 */
}

  .piece.dragging{ cursor: grabbing; }
  .piece .sq{
    position:absolute;
    width: var(--center-cell);
    height: var(--center-cell);
    background: currentColor;
    border: 1px solid #fff;         /* 白枠 */
    border-radius: 2px;
    box-sizing: border-box;
    pointer-events: none;           /* ヒットは親 .piece に集約 */
  }

/* 追加: フリップハンドル */
.piece .handles{
  position:absolute;
  right:-4px;               /* 右上に少し外側へ */
  top:-24px;
  display:flex; gap:4px;
  z-index:2;
  pointer-events:auto;
}
.piece .handle{
  font-size:12px; line-height:1;
  padding:4px 6px;
  border-radius:12px;
  background:rgba(17,17,17,.85);
  color:#fff;
  border:1px solid rgba(0,0,0,.35);
  box-shadow:0 2px 6px rgba(0,0,0,.18);
  cursor:pointer; user-select:none;
}
.piece .handle:active{ transform:translateY(1px); }

.trash-row .label{ display:none; }










/* ====== 共通：カード幅に応じて比率スケール（追記） ====== */
:root{
  /* ベース設計値（今のPCサイズに合わせて必要なら調整） */
  --card-w-base: 56px;      /* 既定のカード幅 */
  --num-size-base: 14px;    /* 角の数字の既定フォントサイズ */
  --cell-size-base: 8px;    /* カード内セルの既定サイズ（px） */
  --face-padding-base: 10px;/* カード内余白の既定（px） */
  --card-radius-base: 6px;  /* カード角丸の既定（px） */

  /* 比率（--card-w に連動。--card-w 未定義でもベースで動作） */
  --card-scale: calc(var(--card-w, var(--card-w-base)) / var(--card-w-base));

  /* 派生トークン：以下は全部 --card-w に追従 */
  --num-size: clamp(8px, calc(var(--num-size-base) * var(--card-scale)), var(--num-size-base));
  --cell-size: max(3.5px, calc(var(--cell-size-base) * var(--card-scale)));
  --face-padding: max(2px, calc(var(--face-padding-base) * var(--card-scale)));
  --card-radius: calc(var(--card-radius-base) * var(--card-scale));

  /* 相手カード幅も比率で（元の 64px * .36 ≒ 23.04px / 56px ≒ 0.41） */
  --opp-w-ratio: 0.41;
  --card-w-opp: calc(var(--card-w, var(--card-w-base)) * var(--opp-w-ratio));
}

/* 最小限の上書き（既存CSSがこれらの変数を参照していれば不要です） */
.face{ padding: var(--face-padding); border-radius: var(--card-radius); }
.face .num{ font-size: var(--num-size); line-height: 1; }

/* （保険）もし .cell のサイズが変数参照になっていない場合だけ有効化してください
.face .cell, .grid .cell{ width: var(--cell-size); height: var(--cell-size); }
*/

/* ====== モバイル：幅だけ指定すれば他は自動で縮小 ====== */
@media (max-width: 600px){
  :root{
    --card-w: 40px;  /* ←ご指定の値。これだけで数字/セル/余白/角丸も自動で小さくなる */
    /* --card-w-opp は上の比率式により自動更新されます */
  }
}


/* ===== スマホ時：セルテーブル＆ピース 固定サイズ ===== */
@media (max-width: 600px){
  :root{
    --center-cell: 22px;  /* ← 固定サイズ（1マスの一辺）ここだけ変えればOK */
  }

  /* 任意：小さい時に枠線が細すぎないよう微調整 */
  .piece .sq{
    border-width: max(1px, calc(var(--center-cell) * 0.04));
    border-radius: calc(var(--center-cell) * 0.08);
  }
}






/* handbar のモバイル2段レイアウト */
@media (max-width: 600px){
  .handbar{
    flex-direction: column;   /* ←縦積み */
    flex-wrap: nowrap;
    align-items: center;
    gap: 6px;
  }
  .handbar .handrow{
    display: flex;
    gap: 6px;
    justify-content: center;
  }
  /* 下段があるときは高さを少し増やす（カード高さ=幅/0.714） */
  .handbar.two-lines{
    min-height: calc(var(--hand-h) + (var(--card-w) / 0.714) + 12px);
  }
}




@media (max-width: 600px){
  /* 見出しを2行＆中央寄せ */
  #victoryArea { 
    text-align: center;        /* 子のインライン要素を中央に */
  }
  #victoryArea .title{
    position: relative;
    color: transparent;        /* 元のテキストを視覚的に隠す */
  }
  #victoryArea .title::before{
    content: "ディシジョン\Aカード";  /* \A で改行 */
    white-space: pre; 
    color: #111;
    line-height: 1.1;
    display: block;            /* ブロックにして */
    margin: 0 auto;            /* 自身も中央に */
  }

  /* カード（画像含む）を中央寄せ */
  #victoryArea .card,
  #victoryArea .card > img,
  #victoryArea img.card,
  #victoryArea .decisionCard {
    display: block;
    margin-left: auto;
    margin-right: auto;
  }

  /* カード一覧がコンテナで横並びなら中央寄せ */
  #victoryArea .cards,
  #victoryArea .card-list,
  #victoryArea .deck {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;           /* 収まらないときは折り返す */
    gap: 8px;
  }
}


/* 捨て札一覧のカードを全体の85%に（影響範囲は .trash-panel 内のみ） */
.trash-panel{
  --trash-scale: 0.85; /* ← 好みで 0.80〜0.90 に調整可 */
}
.trash-panel .cardbox{
  /* 幅だけ小さく → 高さは aspect-ratio で追従 */
  width: calc(var(--card-w, var(--card-w-base)) * var(--trash-scale));
}
/* 数字・内側セル・余白なども同率で縮小（にじみ防止） */
.trash-panel .face{
  padding: calc(var(--face-padding) * var(--trash-scale));
  border-radius: calc(var(--card-radius) * var(--trash-scale));
}
.trash-panel .face .num{
  font-size: calc(var(--num-size) * var(--trash-scale));
}
.trash-panel .cell{
  width:  calc(var(--cell-size) * var(--trash-scale));
  height: calc(var(--cell-size) * var(--trash-scale));
}




/* ===== スマホ時：他プレイヤー手札 & 場の位置調整（上書き） ===== */
@media (max-width: 600px){
  :root{
    /* まず全体の押し出し量を弱める（マイナスにすると内側に寄ります） */
    --opp-shift: -10px;

    /* ← ここを触れば “感覚的に” 位置調整できます（推奨: ここだけ触る） */
    --opp-side-x: -118px;   /* A/B の左右位置（負の絶対値↑で外に、↓で内側に） */
    --opp-side-y: 56%;      /* A/B の縦位置（50%でド真ん中） */
    --opp-top-y: 8px;       /* C の上端からの距離 */

    --play-side-x: 22px;    /* A/B の “場” の左右位置 */
    --play-side-y: 64%;     /* A/B の “場” の縦位置 */
    --play-top-y: 92px;     /* C の “場” の縦位置 */

    /* バッジの位置（必要なら） */
    --opp-badge-bottom: 76px;
  }

  /* 他プレイヤー手札（扇の土台ごと） */
  .opp.A{ left: var(--opp-side-x); top: var(--opp-side-y); transform: translateY(-50%); }
  .opp.B{ right:var(--opp-side-x); top: var(--opp-side-y); transform: translateY(-50%); }
  .opp.C{ left: 50%; top: var(--opp-top-y); transform: translateX(-50%); }

  /* バッジの微調整（必要なときだけ活きます） */
  .opp .badge{ bottom: var(--opp-badge-bottom); }

  /* 各プレイヤーの “場” の位置も合わせて寄せる */
  .play-A{ left: var(--play-side-x); top: var(--play-side-y); transform: translateY(-50%); }
  .play-B{ right:var(--play-side-x); top: var(--play-side-y); transform: translateY(-50%); }
  .play-C{ left: 50%; top: var(--play-top-y); transform: translate(-50%, 0); }
}

/* さらに小さい端末向けの予備プリセット（任意） */
@media (max-width: 380px){
  :root{
    --opp-side-x: -110px;
    --opp-side-y: 58%;
    --play-side-x: 18px;
    --play-side-y: 66%;
    --play-top-y: 96px;
  }
}

/* === スマホ：ディシジョンカードポップを細くする === */
@media (max-width: 600px){
  /* ポップ本体をカード幅 + 左右余白に固定（content-boxに変更） */
  #victoryArea{
    box-sizing: content-box;                    /* ← 追加：widthを内容幅基準にする */
    inline-size: calc(var(--card-w) + 16px);    /* ← widthでも可。カード幅 + 8px×2 */
    padding: 6px 8px;
    overflow: hidden;                           /* ← 保険：小数誤差の1pxはみ出し防止 */
  }

  /* モバイルでは拡大を解除（溢れ防止） */
  #victoryArea .cardbox{
    transform: none;
  }

  /* 見出しが幅を押し広げないように */
  #victoryArea .title{ font-size: 11px; }
  #victoryArea .title::before{
    overflow-wrap: anywhere;
  }
}

/* === スマホ：ディシジョンカードポップの高さを空白消しで算出 === */
@media (max-width: 600px){
  /* コンテナ自体の余白とギャップを最小化（高さ=タイトル+カード+最小padding） */
  #victoryArea{
    display: inline-grid;      /* 内容にぴったりの高さにしやすい */
    grid-auto-rows: auto;
    align-items: start;
    gap: 0;                    /* ← flexのgap(6px)を無効化して詰める */
    padding-block: 4px;        /* 上下の内側余白を最小限に */
  }

  /* タイトル側の空白を極小化（2行想定だが行間は詰める） */
  #victoryArea .title{
    margin: 0;
    line-height: 1;            /* 行間の余白を削減 */
  }
  #victoryArea .title::before{
    display: block;
    white-space: pre;          /* 「ディシジョン↵カード」のまま */
    line-height: 1;            /* ここでも行間を詰める */
    margin: 0;
  }

  /* カード側の“行のベースライン余白”を除去（画像/インライン要素の隙間対策） */
  #decisionCardBox{
    line-height: 0;            /* イメージ/インラインの下側に出る隙間を消す */
  }
  #decisionCardBox .cardbox{
    display: block;            /* ブロック化して上下の余白を安定化 */
    margin: 0 auto;
  }
}

/* --- スマホ時：他プレイヤー手札だけ下げる & 上プレイヤー全体を少し下へ --- */
@media (max-width: 600px){
  :root{
    /* 上プレイヤーの全体オフセット（ネームも含めて下げる） */
    --opp-top-y: 20px;        /* 既存の 8px を上書き：少し下へ */

    /* 他プレイヤーの “手札（扇）だけ” のオフセット量 */
    --fan-shift-side: 30px;   /* A/B の扇を下げる量（お好みで 10〜18px 目安） */
    --fan-shift-top: 25px;     /* C の扇を微調整したい場合。不要なら 0px でもOK */
  }

  /* 手札（扇）だけ下げる：ネーム（.badge）や枠（.opp）は動かさない */
  .opp.A .fan,
  .opp.B .fan{ top: calc(50% + var(--fan-shift-side)); }

  /* 上プレイヤーは “全体” を下げる（ネームも一緒に）＋必要なら扇も微調整 */
  .opp.C{ top: var(--opp-top-y); }            /* 全体を下げる */
  .opp.C .fan{ top: calc(50% + var(--fan-shift-top)); }  /* 扇だけ微調整（任意） */
}


/* --- スマホ時：右プレイヤーを少し左へ寄せる --- */
@media (max-width: 600px){
  :root{
    --opp-right-nudge: 18px;   /* 左に寄せる量（8〜18pxで微調整） */
  }
  /* 右プレイヤー全体（ネーム＋手札）を左へ */
  .opp.B{ right: calc(var(--opp-side-x) + var(--opp-right-nudge)); }
}

/* スマホ：ダブルスキャンポップをディシジョンカードの“右に隣接” */
@media (max-width: 600px){
  #doubleScanArea{
    position: fixed;                 /* 既存と同じ（victoryAreaと揃える） */
    box-sizing: content-box;
    inline-size: calc(var(--card-w) + 43px); /* カード幅 + 左右8px */
    padding: 6px 8px;
    top: 60px;                        /* victoryAreaと同じY */
    /* 12px(勝利ポップの左余白) + 勝利ポップ幅 + 8px(間隔) = 右に隣接 */
    left: calc(25px + (var(--card-w) + 16px) + 8px);
    overflow: hidden;                 /* 念のためのはみ出し防止 */
  }
}


/* === スマホ：ダブルスキャンのカード幅をディシジョンカードと同じに === */
@media (max-width: 600px){
  /* ダブルスキャン内のカード（プレースホルダ/実カード）が常に --card-w に */
  #doubleScanArea .cardbox,
  #doubleScanArea .blank-card{
    width: var(--card-w);
    aspect-ratio: 63.5 / 88.9;  /* 念のため明示 */
    transform: none;            /* 念のため拡大禁止 */
  } }

/* === スマホ：ダブルスキャン“ポップ内のカード”を少し上に寄せる === */
@media (max-width: 600px){
  /* まず、ラベル＋丸行（.doubleScan）とカードの間のスキマを詰める */
  #doubleScanArea .doubleScan{
    margin-bottom: 2px;   /* 既存 6px → 2px（0〜4pxで好み調整） */
  } }

/* スマホ：上プレイヤーのネーム＆手札を下げる（後勝ちの追記） */
@media (max-width: 600px){
  :root{
    --opp-top-y: 10px;       /* 上プレイヤー全体（.opp.C）を下へ。ネームも一緒に下がる */
  
  }
}

@media (max-width: 600px){
  :root{
    /* 上プレイヤーのプレイ位置（C）を下へ。お好みで数値調整 */
    --play-top-y: 133px;  /* 例: 92px → 128px にすると明確に下がる */
  }
}




/* === 着席ポップ === */
.seat-pop{
  position: fixed;
  left: 50%;
  bottom: 10px;
  transform: translateX(-50%);
  background: #189e6b;
  border: 1px solid #eee;
  border-radius: 12px;
  box-shadow: 0 12px 28px rgba(0,0,0,.12);
  padding: 10px;
  z-index: 220;
  display: flex;
  flex-direction: column;
  gap: 10px;
  min-width: 280px;
}
.seat-pop .row{ display:flex; gap:8px; align-items:center; }
.seat-pop label{ width:84px; font-size:13px; }

.tabs{ display:flex; gap:6px; flex-wrap:wrap; }
.tab{
  padding:6px 10px;
  border:1px solid #ddd;
  border-radius:999px;
  cursor:pointer;
  user-select:none;
  position: relative;
  background:#189e6b;
}
.tab.active{ background:#189e6b; color:#fff; border-color:#111; }
.tab.disabled{ opacity:.35; pointer-events:none; }

.tab.taken::after{
  content: '✕';
  position: absolute; inset: 0;
  display: grid; place-items: center;
  font-size: 18px; font-weight: 700; color:#b91c1c; /* ←赤で見える色に */
  z-index: 1;  /* 念のため最前面に */
  pointer-events: none;
}


/* 捨て札パネル内：グリッドの列/行サイズも trash-scale に揃える（ピースの隙間解消） */
.trash-panel .grid{
  grid-template-columns: repeat(var(--cols), calc(var(--cell-size) * var(--trash-scale)));
  grid-template-rows:    repeat(var(--rows), calc(var(--cell-size) * var(--trash-scale)));
}

/* 手札は薄くしない（非アクティブでも不透明のまま） */
.handbar .cardbox.unplayable{
  opacity: 1 !important;
  filter: none !important;
}


/* === ステージ選択ポップ === */
.stage-pop{
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  background: #189e6b;
  border: 1px solid #eee;
  border-radius: 12px;
  box-shadow: 0 12px 28px rgba(0,0,0,.18);
  padding: 10px;
  z-index: 230;        /* seat-pop(220) より前 */
  min-width: 300px;
}
.stage-pop .title{ font-weight:700; }
.stage-grid{
  display: grid;
  grid-template-columns: repeat(4, minmax(50px, 1fr)); /* 4列×5行=20個 */
  gap: 8px;
  margin-top: 6px;
}
.stage-btn{
  padding: 8px 0;
  border: 1px solid #ddd;
  border-radius: 10px;
  background: #fff;
  cursor: pointer;
  font-weight: 700;
}
.stage-btn.active{
  background: #111;
  color: #fff;
  border-color: #111;
}

/* ステージ用の上位オーバーレイ（seatBackdrop より前面） */
#stageBackdrop{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.16);
  z-index: 225;
}


















/* ▼ 中央セルの描画レイヤ（セル塗り＆辺塗り） */
.center-draw-layer{
  position:absolute;
  left:50%; top:80%;
  transform:translate(-50%,-50%);
  width: calc(12 * var(--center-cell));
  height: calc(12 * var(--center-cell));
  z-index: 50;            /* 罫線(1)より前、ピース(60)より後ろ */
  pointer-events: none;   /* 操作の邪魔をしない */
}
.center-draw-layer svg{
  width:100%; height:100%;
  display:block;
  shape-rendering: crispEdges; /* にじみ抑制 */
}



@media (max-width: 600px){
  :root{
    --opp-right-nudge: 18px;   /* 既存のまま */
  }
  /* これで right が負にならず、画面の右外へはみ出さない */
  .opp.B{ right: max(0px, calc(var(--opp-side-x) + var(--opp-right-nudge))); }
}
@media (max-width: 600px){
  html, body, .table-area{ overflow-x: hidden; }
}













</style>
</head>
<body>
<header>
  <h1>ザ・カカポ</h1>
  <div class="small" id="headerInfo"></div>
</header>

<main>
  <!-- 入室 -->
  <section id="joinPanel" class="join-box">
    <input id="nameInput" placeholder="名前（1文字）" maxlength="1" inputmode="text" />
    <input id="codeInput" placeholder="ルームコード（例: 1234）" maxlength="12" inputmode="numeric" />
    <button id="btnJoin" class="btn">入室</button>
  </section>

  <!-- テーブル -->
  <section id="afterPanel" class="hidden">
    <div id="hostBar" class="hidden" style="display:none">
      <span id="hostInfo">ホスト未設定</span>
      <button id="btnBecomeHost" class="btn">ホストになる</button>
      <button id="btn1p" class="btn ghost">1人</button>
      <button id="btn2p" class="btn ghost">2人</button>
      <button id="btn3p" class="btn ghost">3人</button>
      <button id="btn4p" class="btn ghost">4人</button>
      <span class="muted">※人数を選ぶと配布・ラウンド初期化</span>
    </div>

    <div id="tableArea" class="table-area">
      <!-- ▼ 中央 12x12 グリッド線 -->
      <div id="centerGrid" class="center-grid" aria-hidden="true"></div>

<!-- ▼ 中央 12x12 セル描画（オーバーレイ） -->
<div id="centerDraw" class="center-draw-layer" aria-hidden="true">
  <svg viewBox="0 0 12 12" preserveAspectRatio="none"></svg>
</div>

      <!-- ▼ ドラッグ同期ピースの描画レイヤ -->
      <div id="centerPiece" class="center-piece-layer" aria-label="drag-layer"></div>

      <!-- 相手A/B/C -->
      <div id="oppA" class="opp A hidden">
        <div class="fan"></div>
        <div class="badge">A</div>
      </div>
      <div id="oppB" class="opp B hidden">
        <div class="fan"></div>
        <div class="badge">B</div>
      </div>
      <div id="oppC" class="opp C hidden">
        <div class="fan"></div>
        <div class="badge">C</div>
      </div>

      <!-- “場”（相手） -->
      <div id="playA" class="play-slot play-A"></div>
      <div id="playB" class="play-slot play-B"></div>
      <div id="playC" class="play-slot play-C"></div>
    </div>
  </section>
</main>

<!-- 自分の手札＆場 -->
<div id="handBar" class="handbar"></div>
<div id="playMine" class="play-mine-fixed"></div>

<!-- 左上：ディシジョンカード -->
<div id="victoryArea" class="victoryArea hidden">
  <div class="title">ディシジョンカード</div>
  <div id="decisionCardBox"></div>
</div>

<!-- 右側：ダブルスキャンポップ -->
<div id="doubleScanArea" class="victoryArea hidden">
  <div class="doubleScan">
    <div class="label">ダブルスキャン</div>
    <div class="circles">
      <span></span><span></span><span></span><span></span><span></span>
    </div>
  </div>
  <div class="cardbox blank-card"></div>
</div>

<!-- 右下：次ラウンド -->
<div id="nextPanel" class="nextPanel hidden">
  <button id="btnNextRound" class="nextBtn" title="次ラウンド">次ラウンド</button>
</div>

<!-- 右下：設定 -->
<button id="fabOpenSeat" class="fab hidden" title="設定 / 座席選択" aria-label="設定">⚙️</button>
<!-- 左下：捨て札 -->
<button id="btnOpenTrash" class="trashBtn hidden" title="トラッシュ" aria-label="捨て札">🗑️</button>
<div id="seatBackdrop" class="hidden" style="position:fixed;inset:0;z-index:210;background:rgba(0,0,0,.24);"></div>

<!-- 着席ポップ -->

<div id="seatPop" class="seat-pop hidden" role="dialog" aria-modal="true" aria-label="座席選択">
  <div class="row hidden" id="playersRow">
    <label>人数</label>
    <div id="playersTabs" class="tabs">
      <div class="tab" data-n="1">1</div>
      <div class="tab" data-n="2">2</div>
      <div class="tab" data-n="3">3</div>
      <div class="tab" data-n="4">4</div>
    </div>
  </div>
  <div class="row">


<!-- ステージ選択（seatPopの上に重ねる） -->
<div id="stageBackdrop" class="hidden"></div>
<div id="stagePop" class="stage-pop hidden" role="dialog" aria-modal="true" aria-label="ステージ選択">
  <div class="row head" style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
    <div class="title">ステージ選択</div>
  </div>
  <div id="stageGrid" class="stage-grid"></div>
</div>



    <label>席を選択</label>
    <div id="seatTabs" class="tabs"></div>
  </div>



  <div class="row" style="justify-content:flex-end">
    <button class="btn sm ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>


<!-- 捨て札シート -->
<div id="trashSheet" class="hidden" style="position:fixed;inset:0;z-index:85;display:flex;align-items:center;justify-content:center;">
  <div id="trashBackdrop" style="position:absolute;inset:0;background:rgba(0,0,0,.24);"></div>
  <div class="trash-panel" role="dialog" aria-modal="true" 
       style="max-height:80vh;overflow-y:auto;">

    <div class="row head" style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
      <div class="title" style="font-weight:700">捨て札一覧</div>
    </div>
    <div id="trashBody" class="trash-grid"></div>
  </div>
</div>


<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import { getDatabase, ref, set, onDisconnect, onValue, runTransaction, remove, update } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyARne6Jb4ePP7vbvLryE_P-jZ2umI3LFc",
    authDomain: "kakapo-8d297.firebaseapp.com",
    databaseURL: "https://kakapo-8d297-default-rtdb.firebaseio.com",
    projectId: "kakapo-8d297",
    storageBucket: "kakapo-8d297.firebasestorage.app",
    messagingSenderId: "702767130857",
    appId: "1:702767130857:web:54472c8d5ea09bd3cf6878",
    measurementId: "G-NXSRP1T826"
  };

  const app = initializeApp(firebaseConfig);
  const db  = getDatabase(app);

  // ==== DOM ====
  const headerInfo = document.getElementById('headerInfo');
  const joinPanel  = document.getElementById('joinPanel');
  const afterPanel = document.getElementById('afterPanel');
  const nameInput  = document.getElementById('nameInput');
  const codeInput  = document.getElementById('codeInput');
  const btnJoin    = document.getElementById('btnJoin');
const playersRow  = document.getElementById('playersRow');
const playersTabs = document.getElementById('playersTabs');

  const handBar  = document.getElementById('handBar');
  const oppA     = document.getElementById('oppA');
  const oppB     = document.getElementById('oppB');
  const oppC     = document.getElementById('oppC');

  const playMine = document.getElementById('playMine');
  const playA    = document.getElementById('playA');
  const playB    = document.getElementById('playB');
  const playC    = document.getElementById('playC');

  const victoryArea     = document.getElementById('victoryArea');
  const decisionCardBox = document.getElementById('decisionCardBox');
  const nextPanel       = document.getElementById('nextPanel');
  const btnNextRound    = document.getElementById('btnNextRound');

  // 中央レイヤ
  const centerGrid  = document.getElementById('centerGrid');   // 背景の12x12罫線
  const centerPiece = document.getElementById('centerPiece');  // 勝者ピースの12x12（同期ドラッグ）

const seatPop  = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const fabOpenSeat = document.getElementById('fabOpenSeat'); // 既存
const seatBackdrop = document.getElementById('seatBackdrop'); // ← 追加
// --- ステージ選択ポップDOM ---
const stagePop = document.getElementById('stagePop');
const stageBackdrop = document.getElementById('stageBackdrop');
const stageGrid = document.getElementById('stageGrid');
seatBackdrop?.addEventListener('click', hideSeatPop); // ← 追加（外側クリックで閉じる）







// 捨て札UI
const btnOpenTrash  = document.getElementById('btnOpenTrash');
const trashSheet    = document.getElementById('trashSheet');
const trashBackdrop = document.getElementById('trashBackdrop');
const trashBody     = document.getElementById('trashBody');
// ★ ゴミ箱UIの開閉はグローバルで常時有効にしておく（入室前でも開く）
btnOpenTrash?.addEventListener('click', () => {
  show(trashSheet, true);
  renderTrash();
});
trashBackdrop?.addEventListener('click', () => show(trashSheet, false));
  // ==== 40枚カードデータ（色×8、紫は0~8 ※0はピースなし表現） ====
  const CARD_DATA = {
    red:   {1:'A1',2:'A1,B1',3:'A1,B1,C1',4:'A1,B1,C1,C2',5:'A1,B1,C1,C2,D1',6:'A1,A2,B2,C2,C3,D2',7:'A1,A2,B1,C1,C2,D1,E1',8:'A1,A2,B2,C2,D2,E2,E3,F2'},
    blue:  {1:'A1',2:'A1,B1',3:'A1,B1,C1',4:'A1,A2,B1,B2',5:'A1,A2,B1,B2,C1',6:'A1,A2,A3,B1,B2,C2',7:'A1,A2,B1,B2,C1,C2,D1',8:'A1,A2,B1,B2,B3,C2,C3,D3'},
    green: {1:'A1',2:'A1,B1',3:'A1,B1,C1',4:'A1,B1,B2,C1',5:'A2,A3,B2,C1,C2',6:'A3,B1,B2,B3,C1,C3',7:'A1,A2,A3,A4,B1,C1,D1',8:'A1,A2,B1,C1,C2,C3,C4,D4'},
    yellow:{1:'A1',2:'A1,B1',3:'A1,B1,C1',4:'A1,B1,B2,C2',5:'A2,B1,B2,B3,C2',6:'A1,A3,B1,B2,B3,C2',7:'A1,A2,A3,B2,C1,C2,C3',8:'A1,A2,A3,B2,C2,D1,D2,D3'},
    purple:{0:'',  1:'A1,B1',2:'A1,B1',3:'A1,A2,B2',4:'A1,A2,B2',5:'A1,A2,B1,B2',6:'A1,A2,B1,B2',7:'A1,B1,C1,D1,E1,F1',8:'A1,B1,C1,D1,E1,F1,G1'}
  };
  const COLOR_ORDER = ['red','blue','green','yellow','purple'];

  // ==== 状態 ====
  const state = {
    uid: crypto.randomUUID(),
    name: "",
    code: "",
    joined: false,
    mySeat: null,      // 1..4
    playersN: null,    // 1..4
    hostUid: null,
    seats: {},         // { "1": {uid,name}, ... }
    hands: {},         // { "1":[cardId,...], ... }
    plays: {},         // { uid: {cardId,color,index,seat,round,ts} }
    game: {},          // ラウンド進行のメタ
    centerPieces: {},  // { [round]: { [pieceId]: PieceObj } }
    dragging: { id: null, round: null, raf: 0, offPx: {x:0,y:0}, ownLock: false },
  trash: {},   // { [cardId]: true } 捨て札累積フラグ
    used:  {},   // ★ プレイ済み累積フラグ（勝者含む）

  };

  // ==== ユーティリティ ====
  function randomLetter(){ return String.fromCharCode(65 + Math.floor(Math.random()*26)); }
  function random4(){ return String(Math.floor(Math.random()*10000)).padStart(4, '0'); }
  const NAME_RE = /^[A-Za-z\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FFF]$/;
  function normalizeName(raw){ const t = (raw || "").trim(); if (!t) return randomLetter(); const c = t[0]; return NAME_RE.test(c) ? c : randomLetter(); }
  function show(el, yes){ el.classList.toggle('hidden', !yes); }
  function parseCardId(id){ const [c, n] = String(id).split('-'); return { color:c, index:Number(n)||0 }; }

// 追加：手札を「色順→数字昇順」で並べ替える
  function sortHandByColorIndex(ids){
    const order = (COLOR_ORDER || ['red','blue','green','yellow','purple']);
    const rank = c => {
      const i = order.indexOf(c);
      return i >= 0 ? i : 999;
    };
    return (ids||[]).slice().sort((a,b)=>{
      const pa = parseCardId(a), pb = parseCardId(b);
      const byColor = rank(pa.color) - rank(pb.color);
      if (byColor !== 0) return byColor;
      return pa.index - pb.index;
    });
  }

  function buildDeck40(){
    const deck = [];
    for(const color of ['red','blue','green','yellow','purple']){
      for(let i=1;i<=8;i++) deck.push({ id:`${color}-${i}`, color, index:i });
    }
    return deck;
  }
  function shuffleInPlace(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
  function makeDealtByRoundRobin(N, deck){ const out={ '1':[], '2':[], '3':[], '4':[] }; deck.forEach((card,idx)=>{ const seat=((idx)%N)+1; out[String(seat)].push(card.id); }); return out; }
  function seatUid(seatNum){ return state.seats?.[String(seatNum)]?.uid || null; }

  function orderSeatsFrom(startSeat, N){
    const arr=[]; for (let k=0; k<N; k++){ const seat = (((startSeat - 1 - k) % N) + N) % N + 1; arr.push(seat); } return arr;
  }
  function getSeatOfUid(uid){ for (const [k,v] of Object.entries(state.seats||{})){ if (v?.uid===uid) return Number(k); } return null; }

function updateHeader(){
  headerInfo.innerHTML = '';

  // 部屋番号のみ
  const spanRoom = document.createElement('span');
  spanRoom.textContent = state.code || '-';

  // COPYボタン
  const btn = document.createElement('button');
  btn.className = 'copybtn';
  btn.textContent = 'COPY';
  btn.onclick = ()=>{
    const url = new URL(location.href);
    url.searchParams.set('room', state.code);
    url.searchParams.set('name', state.name);
    navigator.clipboard.writeText(url.toString());
    btn.textContent = 'COPIED';
    setTimeout(()=> btn.textContent='COPY', 1200);
  };

  // 名前のみ
  const spanMe = document.createElement('span');
  spanMe.textContent = state.name || '-';

  // 順番に追加：部屋番号 → COPY → 名前
  headerInfo.appendChild(spanRoom);
  headerInfo.appendChild(btn);
  headerInfo.appendChild(spanMe);
}

// --- ミッション描画（セル塗り＆辺塗り） ---
const centerDraw = document.getElementById('centerDraw');
const centerDrawSvg = centerDraw?.querySelector('svg');

const EDGE_COLORS = {
  red:   '#e53935',
  yellow:'#fdd835',
  purple:'#8e24aa',
  blue:  '#1e88e5',
  green: '#43a047',
};

// 既存付近：EDGE_WIDTH/EDGE_CHAMFER 定義あたり
const EDGE_WIDTH   = 0.22;          // 線の太さ（セル単位）
const EDGE_CHAMFER = EDGE_WIDTH;    // 線の内側厚みと同じ量 → 端の45°がきれいに出る
const SVG_NS = 'http://www.w3.org/2000/svg';

function cellXY(token){
  // "F6" などを {x:5,y:5} の0始まりに
  const t = String(token || '').trim().toUpperCase();
  const m = t.match(/^([A-L])\s*(1[0-2]|[1-9])$/);
  if(!m) return null;
  return { x: m[1].charCodeAt(0) - 65, y: Number(m[2]) - 1 };
}

function drawFill(x, y, color = '#fff'){
  const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
  r.setAttribute('x', x);
  r.setAttribute('y', y);
  r.setAttribute('width', 1);
  r.setAttribute('height', 1);
  r.setAttribute('fill', color);
  return r;
}

// --- 連続ランをまとめて内側塗り＆端だけ45°キャップで描く ---
function renderEdgesGrouped(parentG, edgeSpecs){
  if (!edgeSpecs?.length) return;
  const groups = { top:new Map(), bottom:new Map(), left:new Map(), right:new Map() };

  // 1) マス座標に直して、向き×色×固定座標ごとにグルーピング
  for (const e of edgeSpecs){
    const c = cellXY(e.cell);
    if (!c) continue;
    const side = String(e.side||'').toLowerCase();
    const color = EDGE_COLORS[e.color] || e.color || '#000';

    if (side === 'top' || side === 'bottom'){
      const y = side === 'top' ? c.y : c.y;     // ベースy（bottomはベース= y+1 を後で使う）
      const key = `${color}|${y}`;
      const map = groups[side];
      if (!map.has(key)) map.set(key, []);
      map.get(key).push({ x:c.x, color });
    } else if (side === 'left' || side === 'right'){
      const x = side === 'left' ? c.x : c.x;    // ベースx（rightはベース= x+1 を後で使う）
      const key = `${color}|${x}`;
      const map = groups[side];
      if (!map.has(key)) map.set(key, []);
      map.get(key).push({ y:c.y, color });
    }
  }

  // 2) 水平ラン（top/bottom）をまとめて描画
  for (const side of ['top','bottom']){
    const map = groups[side];
    for (const [key, arr] of map){
      const [color] = key.split('|');
      // x を昇順に並べて連続ラン（x, x+1, x+2, …）に分割
      const xs = arr.map(o=>o.x).sort((a,b)=>a-b);
      let runStart = null, last = null;
      const flush = (y, x0, x1) => {
        // x0..x1 は連続セル（右端は x1+1）
        const t = EDGE_WIDTH, c = Math.min(EDGE_CHAMFER, (x1 - x0 + 1) / 2);
        const yBase = (side === 'top') ? Number(key.split('|')[1]) : Number(key.split('|')[1]) + 1;
        const dir   = (side === 'top') ? +1 : -1; // 内側方向（topは下へ、bottomは上へ）

        const p = document.createElementNS(SVG_NS, 'polygon');
        // 内側だけに寄せる：縦方向は [yBase, yBase + dir*t]
        // ラン中央はまっすぐ、両端だけ45°（Δx = c, Δy = t）
        const xL = x0, xR = x1 + 1;
        const pts = [
          `${xL},${yBase}`,           // 左上(ベース)
          `${xR},${yBase}`,           // 右上(ベース)
          `${xR - c},${yBase + dir*t}`, // 右下(斜めで45°)
          `${xL + c},${yBase + dir*t}`, // 左下(斜めで45°)
        ].join(' ');
        p.setAttribute('points', pts);
        p.setAttribute('fill', color);
        parentG.appendChild(p);
      };

      const y = Number(key.split('|')[1]);
      for (const x of xs){
        if (runStart === null){ runStart = last = x; continue; }
        if (x === last + 1){ last = x; continue; }
        flush(y, runStart, last);
        runStart = last = x;
      }
      if (runStart !== null) flush(y, runStart, last);
    }
  }

  // 3) 垂直ラン（left/right）をまとめて描画
  for (const side of ['left','right']){
    const map = groups[side];
    for (const [key, arr] of map){
      const [color] = key.split('|');
      const ys = arr.map(o=>o.y).sort((a,b)=>a-b);
      let runStart = null, last = null;
      const flush = (x, y0, y1) => {
        const t = EDGE_WIDTH, c = Math.min(EDGE_CHAMFER, (y1 - y0 + 1) / 2);
        const xBase = (side === 'left') ? Number(key.split('|')[1]) : Number(key.split('|')[1]) + 1;
        const dir   = (side === 'left') ? +1 : -1; // 内側方向（leftは右へ、rightは左へ）

        const p = document.createElementNS(SVG_NS, 'polygon');
        // 内側だけに寄せる：横方向は [xBase, xBase + dir*t]
        const yT = y0, yB = y1 + 1;
        const pts = [
          `${xBase},${yT}`,              // 上(ベース)
          `${xBase},${yB}`,              // 下(ベース)
          `${xBase + dir*t},${yB - c}`,  // 右(または左)内側へ＋上端/下端は45°
          `${xBase + dir*t},${yT + c}`,
        ].join(' ');
        p.setAttribute('points', pts);
        p.setAttribute('fill', color);
        parentG.appendChild(p);
      };

      const x = Number(key.split('|')[1]);
      for (const y of ys){
        if (runStart === null){ runStart = last = y; continue; }
        if (y === last + 1){ last = y; continue; }
        flush(x, runStart, last);
        runStart = last = y;
      }
      if (runStart !== null) flush(x, runStart, last);
    }
  }
}



function drawEdge(x, y, side, colorName = 'purple'){
  const color = EDGE_COLORS[colorName] || colorName || '#000';
  const t = EDGE_WIDTH, c = EDGE_CHAMFER;
  const p = document.createElementNS(SVG_NS, 'polygon');
  let pts = '';
  if (side === 'top'){
    const x0 = x, x1 = x + 1, yy = y;
    // 中心(左右端)を結ぶ帯に、両端45°の面取り
    pts = `${x0},${yy} ${x0+c},${yy - t/2} ${x1 - c},${yy - t/2} ${x1},${yy} ${x1 - c},${yy + t/2} ${x0 + c},${yy + t/2}`;
  } else if (side === 'bottom'){
    const x0 = x, x1 = x + 1, yy = y + 1;
    pts = `${x0},${yy} ${x0+c},${yy + t/2} ${x1 - c},${yy + t/2} ${x1},${yy} ${x1 - c},${yy - t/2} ${x0 + c},${yy - t/2}`;
  } else if (side === 'left'){
    const xx = x, y0 = y, y1 = y + 1;
    pts = `${xx},${y0} ${xx - t/2},${y0 + c} ${xx - t/2},${y1 - c} ${xx},${y1} ${xx + t/2},${y1 - c} ${xx + t/2},${y0 + c}`;
  } else if (side === 'right'){
    const xx = x + 1, y0 = y, y1 = y + 1;
 pts = `${xx},${y0} ${xx + t/2},${y0 + c} ${xx + t/2},${y1 - c} ${xx},${y1} ${xx - t/2},${y1 - c} ${xx - t/2},${y0 + c}`;
  }
  p.setAttribute('points', pts);
  p.setAttribute('fill', color);
  return p;
}

function renderMissionOverlay(spec){
  if(!centerDrawSvg) return;

  // まるごと描き直し
  centerDrawSvg.replaceChildren();

  // レイヤ順：defs → 塗り → 画像 → 辺線
  const defs = document.createElementNS(SVG_NS,'defs');
  const gFill = document.createElementNS(SVG_NS,'g');
  const gImg  = document.createElementNS(SVG_NS,'g');
  const gEdge = document.createElementNS(SVG_NS,'g');
  centerDrawSvg.append(defs, gFill, gEdge, gImg);

  // セル塗り（同時に filled 座標を収集）
  const filled = [];
  (spec.fills || []).forEach(cell=>{
    const c = cellXY(cell);
    if (c){
      gFill.appendChild(drawFill(c.x, c.y, '#fff'));
      filled.push(c);
    }
  });

  // 画像のクリップ（図形＝filled の合成矩形で clipPath を作成）
  if (spec.image && filled.length){
    const minX = Math.min(...filled.map(p=>p.x));
    const minY = Math.min(...filled.map(p=>p.y));
    const maxX = Math.max(...filled.map(p=>p.x)) + 1;
    const maxY = Math.max(...filled.map(p=>p.y)) + 1;

    const clipId = 'clip-mission1';
    const clip = document.createElementNS(SVG_NS,'clipPath');
    clip.setAttribute('id', clipId);

    // 5マス（F6,F7,G6,G7,H6）それぞれを clipPath に追加
    filled.forEach(({x,y})=>{
      const r = document.createElementNS(SVG_NS,'rect');
      r.setAttribute('x', x);
      r.setAttribute('y', y);
      r.setAttribute('width', 1);
      r.setAttribute('height', 1);
      clip.appendChild(r);
    });
    defs.appendChild(clip);

    // 画像は図形の外にはみ出した分を clip でカット
    const img = document.createElementNS(SVG_NS,'image');
    img.setAttribute('x', minX);
    img.setAttribute('y', minY);
    img.setAttribute('width',  maxX - minX);
    img.setAttribute('height', maxY - minY);
    img.setAttribute('preserveAspectRatio', 'xMidYMid slice'); // 図形をしっかり覆う（全面貼り）
    img.setAttribute('clip-path', `url(#${clipId})`);
    // href 互換
    img.setAttribute('href', spec.image);
    img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', spec.image);
    gImg.appendChild(img);
  }

  // 辺塗り
renderEdgesGrouped(gEdge, spec.edges || []);

}

function clearMissionOverlay(){
  if (centerDrawSvg) centerDrawSvg.replaceChildren();
}
function updateMissionOverlay(){
  // settingsがまだ来ていない間は描かない
  if (typeof state?.stage === 'undefined' || state.stage === null) return;

  const stg = Number(state.stage);

  if (stg === 1){
    renderMissionOverlay(MISSION_1);                 // 既存どおり1枚
    centerDraw?.classList.remove('hidden');

  } else if (stg === 2){
    renderMissionOverlays([MISSION_2_FIG1, MISSION_2_FIG2]);  // 図1と図2を“各自の位置”に
    centerDraw?.classList.remove('hidden');

  } else if (stg === 3){
    renderMissionOverlays([MISSION_3_FIG1, MISSION_3_FIG2]);  // 同上
    centerDraw?.classList.remove('hidden');

  } else {
    clearMissionOverlay();
    centerDraw?.classList.add('hidden'); // 視覚的にも非表示
  }
}

// 図リストをそれぞれ独立した <g> に描画（置かれたセルは“指定の通り”に表示）
function renderMissionOverlays(specList){
  if (!centerDrawSvg) return;

  // 一度だけクリアして、同一SVG内に複数の図を重ねる
  centerDrawSvg.replaceChildren();

  // 共通レイヤ
  const defs = document.createElementNS(SVG_NS,'defs');
  const gFill = document.createElementNS(SVG_NS,'g');
  const gImg  = document.createElementNS(SVG_NS,'g');
  const gEdge = document.createElementNS(SVG_NS,'g');
  centerDrawSvg.append(defs, gFill, gEdge, gImg);

  specList.forEach((spec, idx) => {
    // 1) 塗り（filled 収集）
    const filled = [];
    (spec.fills || []).forEach(cell => {
      const c = cellXY(cell);
      if (c){
        gFill.appendChild(drawFill(c.x, c.y, '#fff'));
        filled.push(c);
      }
    });

    // 2) 画像（filled の合成を clipPath にしてはみ出しカット）
    if (spec.image && filled.length){
      const minX = Math.min(...filled.map(p=>p.x));
      const minY = Math.min(...filled.map(p=>p.y));
      const maxX = Math.max(...filled.map(p=>p.x)) + 1;
      const maxY = Math.max(...filled.map(p=>p.y)) + 1;

      const clipId = `clip-m${Date.now()}-${idx}`;
      const clip = document.createElementNS(SVG_NS,'clipPath');
      clip.setAttribute('id', clipId);

      filled.forEach(({x,y})=>{
        const r = document.createElementNS(SVG_NS,'rect');
        r.setAttribute('x', x);
        r.setAttribute('y', y);
        r.setAttribute('width', 1);
        r.setAttribute('height', 1);
        clip.appendChild(r);
      });
      defs.appendChild(clip);

      const img = document.createElementNS(SVG_NS,'image');
      img.setAttribute('x', minX);
      img.setAttribute('y', minY);
      img.setAttribute('width',  maxX - minX);
      img.setAttribute('height', maxY - minY);
      img.setAttribute('preserveAspectRatio', 'xMidYMid slice');
      img.setAttribute('clip-path', `url(#${clipId})`);
      img.setAttribute('href', spec.image);
      img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', spec.image);
      gImg.appendChild(img);
    }


    // 辺塗り（指定セル・指定辺・指定色）
renderEdgesGrouped(gEdge, spec.edges || []);

  });
}


// ▼ ミッション#1（ご指定）
//  白塗：F6, F7, G6, G7, H6
//  辺塗：G7の右辺, H6の下辺（紫）
const MISSION_1 = {
  fills: ['F6','F7','G6','G7','H6'],
  edges: [
    { cell:'G7', side:'right',  color:'purple' },
    { cell:'H6', side:'bottom', color:'purple' },
  ],
  image: 'bird1.png'   // ← 追加：この画像を図形内に貼り付ける


};
const MISSION_2_FIG1 = {
  fills: ['D3','D4','D5','D6','D7','E6','E7'],
  edges: [
    { cell:'D4', side:'right',  color:'red' },
    { cell:'D5', side:'right',  color:'red' },
    { cell:'E6', side:'top',    color:'red' },
  ],
image: 'bird2.png' 
};

// ▼ ミッション #2 図2
// 白塗：I8, I9, I10, J8, J9, K8
// 辺塗：I10の右辺, J9の右辺と下辺, K8の下辺（青）
const MISSION_2_FIG2 = {
  fills: ['I8','I9','I10','J8','J9','K8'],
  edges: [
    { cell:'I10', side:'right',  color:'blue' },
    { cell:'J9',  side:'right',  color:'blue' },
    { cell:'J9',  side:'bottom', color:'blue' },
    { cell:'K8',  side:'bottom', color:'blue' },
  ],
image: 'bird3.png' 
};

// ▼ ミッション #3 図1
// 白塗：E8, F7, F8, F9, G7, G8, G9, H8
// 辺塗：F7の左辺と上辺, G7の右辺と上辺（黄）
const MISSION_3_FIG1 = {
  fills: ['E8','F7','F8','F9','G7','G8','G9','H8'],
  edges: [
    { cell:'F7', side:'left',   color:'yellow' },
    { cell:'F7', side:'top',    color:'yellow' },
    { cell:'G7', side:'right',  color:'yellow' },
    { cell:'G7', side:'top',    color:'yellow' },
  ],
image: 'bird4.png' 
};

// ▼ ミッション #3 図2
// 白塗：J5, K5, K6, K7, K8  （※ご指定「J5.K5,6,7,8」は J5 と K5〜8 の意と解釈）
// 辺塗：K5の上辺と右辺（緑）
const MISSION_3_FIG2 = {
  fills: ['J5','K5','K6','K7','K8'],
  edges: [
    { cell:'K5', side:'top',   color:'green' },
    { cell:'K5', side:'right', color:'green' },
  ],
image: 'bird5.png' 
};


// 画面幅や --center-cell が変わっても viewBox で追従するため再計算は不要。
// 必要があれば他のミッションに差し替えるだけ：renderMissionOverlay(MISSION_X)

  // === カード面 Element ===
  function makeCardFaceEl(cardId){
    const {color, index} = parseCardId(cardId);
    const host = document.createElement('div'); host.className = `cardbox`;
    // purple-0 だけは数字を表示しない
    const isPurpleZero = (color === 'purple' && index === 0);
    const face = document.createElement('div');
    face.className = `face ${color}${isPurpleZero ? ' zero' : ''}`;
    host.appendChild(face);
    if (!isPurpleZero){
      const tl = document.createElement('div'); tl.className='num tl'; tl.textContent = String(index); face.appendChild(tl);
      const tr = document.createElement('div'); tr.className='num tr'; tr.textContent = String(index); face.appendChild(tr);
      const bl = document.createElement('div'); bl.className='num bl'; bl.textContent = String(index); face.appendChild(bl);
      const br = document.createElement('div'); br.className='num br'; br.textContent = String(index); face.appendChild(br);
    }
    const oval = document.createElement('div'); oval.className='ovalBG'; face.appendChild(oval);
    // shape grid（カードの中の表示）
    const def = (CARD_DATA[color]||{})[index] || '';
    const tokens = (def.match(/[A-Z]\d+/gi)||[]).map(s=>s.toUpperCase());
    const toRC = t => ({ r: t.charCodeAt(0)-65, c: Number(t.slice(1))-1 });
    const cells = tokens.map(toRC);
    if (tokens.length){
      const minR = Math.min(...cells.map(p=>p.r));
      const minC = Math.min(...cells.map(p=>p.c));
      const rel  = cells.map(p=>({ r:p.r-minR, c:p.c-minC }));
      const rows = Math.max(...rel.map(p=>p.r))+1; const cols = Math.max(...rel.map(p=>p.c))+1;
      const grid = document.createElement('div'); grid.className='grid'; grid.style.setProperty('--rows', rows); grid.style.setProperty('--cols', cols);
      for (let i=0;i<rows*cols;i++){ const d=document.createElement('div'); d.className='cell'; grid.appendChild(d); }
      rel.forEach(({r,c})=>{ grid.children[r*cols+c].classList.add('filled'); });
      face.appendChild(grid);
    }
    return host;
  }

  // === 入室 ===
  async function join(){
    const name = normalizeName(nameInput.value);
    const code = (codeInput.value || "").trim() || random4();
    state.name = name; state.code = code;

    const meRef = ref(db, `rooms/${code}/participants/${state.uid}`);
    await set(meRef, { name, at: Date.now() });
    onDisconnect(meRef).remove();

    await runTransaction(ref(db, `rooms/${code}/settings/hostUid`), cur => cur || state.uid, { applyLocally:false });

    updateHeader(); show(joinPanel, false); show(afterPanel, true); state.joined = true;
show(btnOpenTrash, true);
show(fabOpenSeat, true);
 wireRoom(); showSeatPop();
    document.getElementById('doubleScanArea').classList.remove('hidden');
  }
  btnJoin.onclick = join;

  // 事前入力
  try{
    const qs = new URLSearchParams(location.search);
    const qRoom = (qs.get('room')||'').trim(); const qName = (qs.get('name')||'').trim();
    if (qRoom) codeInput.value = qRoom.slice(0, 12);
    if (qName) nameInput.value = qName.slice(0, 1);
  }catch(_e){}

  // === ルーム購読 ===
  function wireRoom(){
    const room = `rooms/${state.code}`;

    onValue(ref(db, `${room}/settings`), snap=>{
const st = snap.val() || {}; state.hostUid = st.hostUid || null; state.playersN = st.players || null; state.stage = Number(st.stage || 1);state.stageFig = Number(st.stageFig || 1); 
  updateMissionOverlay(); // ← ステージ1のときだけ塗る      const hostBar = document.getElementById('hostBar');
      const btn1 = document.getElementById('btn1p'); const btn2 = document.getElementById('btn2p'); const btn3 = document.getElementById('btn3p'); const btn4 = document.getElementById('btn4p'); const btnHost = document.getElementById('btnBecomeHost'); const hostInfo = document.getElementById('hostInfo');
      if (hostBar){ hostBar.style.display = 'block'; }
      if (btnHost){ btnHost.onclick = async()=>{ await set(ref(db, `${room}/settings/hostUid`), state.uid); }; }
      if (btn1){ btn1.onclick = async ()=>{ await setPlayersAndDeal(1); }; }
      if (btn2){ btn2.onclick = async ()=>{ await setPlayersAndDeal(2); }; }
      if (btn3){ btn3.onclick = async ()=>{ await setPlayersAndDeal(3); }; }
      if (btn4){ btn4.onclick = async ()=>{ await setPlayersAndDeal(4); }; }
      if (hostInfo){ hostInfo.textContent = `ホスト：${st.hostUid ? (st.hostUid===state.uid?'あなた':st.hostUid.slice(0,4)) : '未設定'}`; }
 if (!seatPop.classList.contains('hidden')) { renderSeatTabs(); renderPlayersTabs(); }
      updateHeader(); renderAll();
    });

    onValue(ref(db, `${room}/hands`), snap=>{ state.hands = snap.val() || {}; renderAll(); });

    onValue(ref(db, `${room}/seats`), snap=>{
      state.seats = snap.val() || {}; state.mySeat = null; for (const k of Object.keys(state.seats)){ if (state.seats[k]?.uid === state.uid){ state.mySeat = Number(k); break; } }
 if (!seatPop.classList.contains('hidden')) { renderSeatTabs(); renderPlayersTabs(); }
      renderAll();
    });

// 変更後
onValue(ref(db, `${room}/plays`), snap=>{
  state.plays = snap.val() || {};
  renderPlays();
  // 先に勝者を確定
  maybeComputeVictory().finally(()=>{
    // 勝者が state.game に反映された後にプレビューを再描画
    renderDoubleScanPreview();
  });
});

    onValue(ref(db, `${room}/game`), snap=>{
      state.game = snap.val() || {};
      updateHeader(); renderAll();

      // ★ ここから追加：ダブルスキャンのトークン描画更新
      const used = state.game.doubleScanUsed || 0;
      const circles = document.querySelectorAll('#doubleScanArea .circles span');
      circles.forEach((c,i)=>{
        if (i < used){
          c.classList.add('used');
          c.style.background = '#ccc';
        }else{
          c.classList.remove('used');
          c.style.background = '#000';
        }
      });
      // ★ 追加ここまで

      // ラウンドにひもづく中央ピース購読
      wireCenterPiecesListener();
    });


    // 全ラウンド配下を購読（ラウンド変わっても即反映）
    onValue(ref(db, `${room}/centerPieces`), snap=>{
      state.centerPieces = snap.val() || {};
      renderCenterPieces();
    });

// 捨て札購読
onValue(ref(db, `${room}/trash`), snap=>{
  state.trash = snap.val() || {};
  if (!trashSheet.classList.contains('hidden')) renderTrash();
});
// ★ 使用済み購読
onValue(ref(db, `${room}/used`), snap=>{
  state.used = snap.val() || {};
  if (!trashSheet.classList.contains('hidden')) renderTrash();
});
// ゴミ箱UIの開閉
btnOpenTrash?.addEventListener('click', ()=>{ show(trashSheet, true); renderTrash(); });
trashBackdrop?.addEventListener('click', ()=> show(trashSheet, false));


    btnNextRound?.addEventListener('click', onNextRound);
  }



  // === 人数設定＆配布 ===
  async function setPlayersAndDeal(N){
    const room=`rooms/${state.code}`;
    let deck = buildDeck40();
    if (N <= 3) { deck = deck.filter(c => c.id !== 'purple-1'); }
    deck = shuffleInPlace(deck);
    const hands = makeDealtByRoundRobin(N, deck);

    // 追加：配布後に色順→数字昇順で並べ替え
    for (let seat = 1; seat <= N; seat++){
      const key = String(seat);
      if (hands[key]) {
        hands[key] = sortHandByColorIndex(hands[key]);
      }
    }

    const startSeat = detectStartSeatFromHands(N, hands);
    const orderSeatsArr = orderSeatsFrom(startSeat, N);
    const startUid = seatUid(startSeat);

    const initGame = {
      round: 1,
      playersN: N,
      startSeat,
      orderSeats: orderSeatsArr,
      startUid: startUid || null,
      turnUid: startUid || null,
      startColor: null,
      victory: null,
      decision: { cardId: (N === 4 ? 'purple-0' : 'purple-1'), color: 'purple', index: (N === 4 ? 0 : 1) }
    };

    await update(ref(db), {
      [`${room}/settings/players`]: N,
      [`${room}/hands`]: hands,
      [`${room}/plays`]: null,
      [`${room}/game`]: initGame,
      [`${room}/centerPieces`]: null,
 [`${room}/trash`]: {} ,
  [`${room}/used`]:  {},     // ★ 追加

    });
  }
  function detectStartSeatFromHands(N, hands){
    const target = 'purple-8'; for (let i=1; i<=N; i++){ if ((hands[String(i)]||[]).includes(target)) return i; } return 1;
  }

  // === 座席UI ===
function showSeatPop(){  show(seatBackdrop, true);   show(seatPop, true); renderSeatTabs(); renderPlayersTabs(); }
function hideSeatPop(){ show(seatPop, false);  show(seatBackdrop, false);    }

function renderSeatTabs(){
  if (!seatTabs) return;
  seatTabs.innerHTML = '';

  const N = state.playersN || 4;
  const isSeated = !!state.mySeat;   // ← 自席を保持しているか

  for (let i=1;i<=4;i++){
    const taken = !!state.seats?.[i];
    const mine  = state.seats?.[i]?.uid === state.uid;
    const invalidByPlayers =
      (!N) || (N===3 && i===4) || (N===2 && i>2) || (N===1 && i>1);

    const t = document.createElement('div');
    const classes = ['tab'];
    if (mine) {
      classes.push('active');
    }

    // すでに他の誰かが着席 → ✕ 表示＋無効化
    if (taken && !mine) {
      classes.push('disabled','taken');
    }

    // ★ 追加：自分がどこかに着席している間は、他席を選べない（退席または観戦が必要）
    if (isSeated && !mine) {
      classes.push('disabled','locked'); // lockedは表示用（必要ならCSS）
    }

    // 人数外は無効化（見た目だけ薄く）
    if (invalidByPlayers) {
      classes.push('disabled');
    }

    t.className = classes.join(' ');
    t.textContent = String(i);

    // クリック動作
    t.onclick = async () => {
      // 自席タブならクリックで「退席」
      if (mine) {
        await releaseMySeat();
        renderSeatTabs();
        return;
      }
      // 自席を持っている間は他席へ移動不可（観戦または退席が必要）
      if (isSeated) {
        // 任意：注意表示
        // alert('別の席を選ぶ前に「退席」または「観戦」を押してください。');
        return;
      }
      // 空席かつ有効なときだけ着席
      if (!taken && !invalidByPlayers) {
        const ok = await claimSeat(i);
        if (ok){
          await maybeFillStartFromSeat();
          hideSeatPop();
        }
      }
    };

    seatTabs.appendChild(t);
  }
}

// ボタン操作
btnSeatCancel?.addEventListener('click', async ()=>{
  if (state.mySeat) {
    await releaseMySeat();   // ← 観戦に戻る＝退席
  }
  hideSeatPop();
});
fabOpenSeat?.addEventListener('click', showSeatPop);

  async function claimSeat(n){
    const seatRef = ref(db, `rooms/${state.code}/seats/${n}`);
    try{
      const res = await runTransaction(seatRef, cur=>{ if (!cur || cur.uid === state.uid){ return { uid: state.uid, name: state.name, at: Date.now() }; } return cur; }, {applyLocally:false});
      if (!res.committed || res.snapshot.val()?.uid !== state.uid){ alert(`席${n} は使用中です。`); return false; }
 state._seatRef = seatRef; // ← 現在の座席Refを保持（ページクローズ時にだけ使う）
      await syncTurnOwnershipOnSeatChange(n);
      return true;
    }catch(e){ console.error(e); alert('着席に失敗しました。'); return false; }
  }
  async function releaseMySeat(){ if (!state.mySeat) return; const room = `rooms/${state.code}`; try{ await remove(ref(db, `${room}/seats/${state.mySeat}`)); }catch(_e){} }
  async function maybeFillStartFromSeat(){ const room = `rooms/${state.code}`; const g = state.game || {}; if (!g.playersN || !g.startSeat) return; const uid = seatUid(g.startSeat); if (uid && (!g.startUid || !g.turnUid)){ await update(ref(db, `${room}/game`), { startUid: uid, turnUid: uid }); } }
  async function syncTurnOwnershipOnSeatChange(n){
    const room = `rooms/${state.code}`; const g = state.game || {}; const updates = {};
    if (g.startSeat && g.startSeat === n && g.startUid !== state.uid){ updates[`${room}/game/startUid`] = state.uid; }
    const N = g.playersN || state.playersN || 0;
    if (N && Array.isArray(g.orderSeats) && g.orderSeats.length === N){
      const playsNow = Object.values(state.plays || {}).filter(p => Number(p?.round) === (g.round||1)).length;
      const expectedSeat = g.orderSeats[playsNow % N];
      if (expectedSeat === n){ updates[`${room}/game/turnUid`] = state.uid; }
    } else {
      const turnSeat = (g.turnUid && (Object.entries(state.seats||{}).find(([k,v])=>v?.uid===g.turnUid)?.[0] | 0)) || 0;
      if (!g.turnUid || !turnSeat){ updates[`${room}/game/turnUid`] = state.uid; }
    }
    if (Object.keys(updates).length){ await update(ref(db), updates); }
  }
function renderPlayersTabs(){
  if (!playersRow || !playersTabs) return;

  // ホストのみ表示
  const isHost = (state.hostUid && state.uid && state.hostUid === state.uid);
  playersRow.classList.toggle('hidden', !isHost);

  // 現在の人数Nをハイライト
  const N = Number(state.playersN || 4);
  const tabs = Array.from(playersTabs.querySelectorAll('.tab'));
  tabs.forEach(el => {
    const n = Number(el.dataset.n);
    el.classList.toggle('active', n === N);

    // クリックはホストのみ有効
    el.onclick = isHost ? async () => {
      await setPlayersAndDeal(n); // 既存：配布＆ラウンド初期化
      renderSeatTabs();
      renderPlayersTabs();
    } : null;
  });

  // ▼ ここに貼り付け
  // --- ステージ選択ボタン（ホストのみ表示） ---
  let btnOpenStage = document.getElementById('btnOpenStage');
  if (isHost) {
    if (!btnOpenStage) {
      btnOpenStage = document.createElement('button');
      btnOpenStage.id = 'btnOpenStage';
      btnOpenStage.className = 'btn sm';
      btnOpenStage.style.marginLeft = 'auto';   // 右寄せ
      playersRow.appendChild(btnOpenStage);
    }
    const n = Number(state.stage || 1);
    btnOpenStage.textContent = `# ${n}`;
    btnOpenStage.onclick = showStagePop;
  } else {
    if (btnOpenStage) btnOpenStage.remove();
  }

} // ← 関数の閉じカッコ



function showStagePop(){
  renderStageGrid();
  positionStagePopOverSeat();
  show(stageBackdrop, true);
  show(stagePop, true);
}

function hideStagePop(){
  show(stagePop, false);
  show(stageBackdrop, false);
}

function positionStagePopOverSeat(){
  if (!seatPop || !stagePop) return;
  const r = seatPop.getBoundingClientRect();
  const gap = 8; // seatPopの上端から少し離す
  const bottom = (window.innerHeight - r.top) + gap;
  stagePop.style.bottom = `${bottom}px`;
  // 横位置はCSSで left:50% / translateX(-50%) 済み
}

// 画面サイズが変わったら追従
window.addEventListener('resize', ()=>{
  if (!stagePop.classList.contains('hidden')) positionStagePopOverSeat();
});

function renderStageGrid(){
  if (!stageGrid) return;
  const room = `rooms/${state.code}`;
  const cur = Number(state.stage || 1);
  stageGrid.innerHTML = '';
  for (let i=1; i<=20; i++){
    const b = document.createElement('button');
    b.className = 'stage-btn' + (i===cur ? ' active' : '');
    b.textContent = String(i);
    b.onclick = async ()=>{
      await set(ref(db, `${room}/settings/stage`), i);
      hideStagePop();
      // ボタン表示更新（ホスト行のラベル更新）
      renderPlayersTabs?.();
    };
    stageGrid.appendChild(b);
  }
}


// --- ページクローズ時だけ「離席」させる ---
function scheduleSeatLeaveOnClose(){
  const refSeat = state?._seatRef;
  if (!refSeat) return;
  try {
    // ページが閉じられ、RTDB が切断された瞬間に座席ノードが削除される
    onDisconnect(refSeat).remove();
  } catch (e) {
    console.warn('onDisconnect scheduling failed', e);
  }
}

// bfcache（戻る/進むのキャッシュ）での「pagehide」は除外する
window.addEventListener('pagehide', (ev)=>{
  if (!ev.persisted) scheduleSeatLeaveOnClose();
}, { capture:true, once:true });

// 一部ブラウザ向けフォールバック
window.addEventListener('beforeunload', scheduleSeatLeaveOnClose, { capture:true, once:true });


  // === レンダリング ===
  function renderAll(){ renderDecisionCard(); renderHands(); renderOpponents(); renderPlays();
  if (!trashSheet.classList.contains('hidden')) renderTrash();
 }
function renderTrash(){
  if (!trashBody) return;

  // ★ 変更：累積 used と、今ラウンドの plays を合算して「濃く表示」対象にする
  const used = new Set([
    ...Object.keys(state.used || {}),
    ...Object.values(state.plays || {}).map(p => p.cardId)
  ]);

  // 色ごとに 1..8 を横並び（purple-0 は一覧から除外）
  const colors = ['red','blue','green','yellow','purple'];
  trashBody.innerHTML = '';
  for (const color of colors){
    const row = document.createElement('div'); row.className = 'trash-row';
    const lab = document.createElement('div'); lab.className = 'label'; lab.textContent = color;
    row.appendChild(lab);

    const maxIndex = 8; // purple も 1..8 を表示（0 は除外）
    for (let i=1;i<=maxIndex;i++){
      const id = `${color}-${i}`;
      const el = makeCardFaceEl(id);
      if (!used.has(id)){ el.classList.add('dim'); } // 非プレイ（未使用）は薄く
      row.appendChild(el);
    }
    trashBody.appendChild(row);
  }
}


  function renderDecisionCard(){
    const g = state.game || {}; const dec = g.decision; if (!dec) return;
    decisionCardBox.innerHTML = ''; decisionCardBox.appendChild(makeCardFaceEl(dec.cardId));
    show(victoryArea, true);
  }

  function myHand(){ if (!state.mySeat) return []; return state.hands?.[String(state.mySeat)] || []; }

 function renderHands(){
  handBar.innerHTML = '';
  handBar.classList.remove('two-lines');

  const g = state.game || {};
  const my = myHand();
  const isMyTurn = (g.turnUid === state.uid);
  const leadColor = g.startColor || null;
  const haveLead = !!my.find(id => parseCardId(id).color === leadColor);
  const isMobile = window.matchMedia('(max-width: 600px)').matches;

  // カード要素生成（既存の出せる/出せない判定を踏襲）
  const make = (id) => {
    const card = makeCardFaceEl(id);
    if (isMyTurn){
      const { color } = parseCardId(id);
      const playable = (!leadColor) || (haveLead ? color === leadColor : true);
      if (playable){
        card.classList.add('clickable','pulsate');
        card.onclick = ()=> playMyCard(id);
      }else{
        card.classList.add('unplayable');
      }
    }else{
      card.classList.add('unplayable');
    }
    return card;
  };

  if (isMobile){
    // 8枚以上なら上下に割り振り、7枚以下は1段
    const n = my.length;
    const topN    = (n >= 8) ? Math.ceil(n/2) : n;   // 10→5, 9→5, 8→4, 7→7, …
    const bottomN = (n >= 8) ? Math.floor(n/2) : 0;  // 10→5, 9→4, 8→4, 7→0, …

    const rowTop = document.createElement('div');    rowTop.className = 'handrow top';
    const rowBot = document.createElement('div');    rowBot.className = 'handrow bottom';

    for (let i=0; i<topN; i++) rowTop.appendChild(make(my[i]));
    if (bottomN > 0){
      for (let i=topN; i<topN+bottomN; i++) rowBot.appendChild(make(my[i]));
      handBar.classList.add('two-lines');
    }

    handBar.appendChild(rowTop);
    if (bottomN > 0) handBar.appendChild(rowBot);

  }else{
    // PCは従来どおり1段
    my.forEach(id => handBar.appendChild(make(id)));
  }
}

// 画面サイズ変化にも追従
window.addEventListener('resize', renderHands);


  function renderOpponents(){
    const maps = computeABCPositions();
    const places = [ ['A',oppA], ['B',oppB], ['C',oppC] ];
    places.forEach(([k,el])=>{
      const info = maps[k];
      if (!info){ show(el,false); return; }
      show(el,true);
      const seatHand = state.hands?.[String(info.seat)] || [];
      const fan = el.querySelector('.fan'); fan.innerHTML='';
      const n = seatHand.length;
      const spread = Math.min(140, n * 18);
      for (let i=0; i<n; i++){
        const deg = -spread/2 + (spread/(n-1)) * i;
        const d = document.createElement('div');
        d.className = 'card opp';
        d.style.transform = `rotate(${deg}deg)`;
        d.style.transformOrigin = '50% 100%';
        fan.appendChild(d);
      }
      const badge = el.querySelector('.badge'); badge.textContent = info.name || `席${info.seat}`;
    });
  }

  function clockwiseOthers(){
    if (!state.mySeat) return [];
    const N = state.game?.playersN || state.playersN || 4;
    const cwOffset = (s)=> ((s.seat - state.mySeat + N) % N);
    return Object.entries(state.seats)
      .filter(([k,v])=>v && v.uid)
      .map(([k,v])=>({ seat:Number(k), uid:v.uid, name:v.name||'?' }))
      .filter(s => s.seat !== state.mySeat)
      .sort((a,b) => cwOffset(a) - cwOffset(b));
  }
  function computeABCPositions(){
    const arr = clockwiseOthers(); const N = state.game?.playersN || state.playersN || 4; const map = {};
    if (arr[0]) map.B = arr[0];
    if (N === 3){ if (arr[1]) map.A = arr[1]; } else { if (arr[1]) map.C = arr[1]; if (arr[2]) map.A = arr[2]; }
    return map;
  }
  function seatToABC(seat){
    if (!state.mySeat) return null; const N = state.game?.playersN || state.playersN || 4;
    const arr = clockwiseOthers();
    if (N===3){ if (arr[1]?.seat===seat) return 'A'; if (arr[0]?.seat===seat) return 'B'; }
    else { if (arr[2]?.seat===seat) return 'A'; if (arr[0]?.seat===seat) return 'B'; if (arr[1]?.seat===seat) return 'C'; }
    return null;
  }

function renderPlays(){
  // まず場をクリア
  playMine.innerHTML = '';
  playA.innerHTML = '';
  playB.innerHTML = '';
  playC.innerHTML = '';

  const g = state.game || {};
  const r = g.round || 1;
  // ★ 勝者ピース出現後は、このラウンドの場札を非表示
  if (Number(g.hiddenPlaysRound) === r) {
    return; // 何も描かない
  }
  // このラウンドのプレイだけを抽出（p.v を正しく参照）
  const playsArr = Object.entries(state.plays || {})
    .map(([uid, v]) => ({ uid, v }))
    .filter(p => Number(p.v?.round) === r);

  for (const p of playsArr){
    const { cardId, seat: seatMaybe } = p.v || {};
    if (!cardId) continue;

    const el = makeCardFaceEl(cardId);
    const seatNum = seatMaybe || getSeatOfUid(p.uid);
    const isMe = (p.uid === state.uid);

    // 配置先を決定
    let parent;
    if (isMe){
      parent = playMine;
    }else{
      const pos = seatToABC(seatNum);
      parent = (pos === 'A') ? playA : (pos === 'B') ? playB : playC;
    }
    parent.appendChild(el);

    // 勝者を強調（クリックで「次ラウンド」表示＆中央ピース生成）
    if (g.victory && Number(g.victory.round) === r && g.victory.uid === p.uid){
      const wrap = document.createElement('div');
      wrap.className = 'played winner';
      parent.replaceChild(wrap, el);
      wrap.appendChild(el);

      if (isMe){
        wrap.onclick = ()=>{
          show(nextPanel, true);
          spawnVictoryPieceOnce();   // 勝者のみクリック可
        };
      }
    }
  }
}

// グローバルにフラグを置く（state 定義の下あたりで宣言しておく）
let doubleScanBusy = false;

// === ダブルスキャン：全員同色なら最小番号カードを点線枠に表示 ===
function renderDoubleScanPreview(){
  const box = document.querySelector('#doubleScanArea .blank-card');
  if (!box) return;
  box.innerHTML = '';

  const g = state.game || {}; 
  const N = g.playersN || 0; 
  const r = g.round || 1;

  const playsArr = Object.entries(state.plays||{})
    .map(([uid,v])=>({uid,...v}))
    .filter(p=>Number(p.round)===r);

  if (!N || playsArr.length !== N) return;

  const colors = new Set(playsArr.map(p=>p.color));
  if (colors.size !== 1) return;

  const minPlay = playsArr.reduce((a,b)=> (a.index <= b.index ? a : b));
  const host = makeCardFaceEl(minPlay.cardId);
  box.appendChild(host);

// === クリック処理 ===
// 勝者だけがクリックできる
if (g.victory && g.victory.uid === state.uid){
  host.classList.add("clickable");
  host.onclick = async ()=>{
    if (doubleScanBusy) return;
    doubleScanBusy = true;

    try {
      // ピースを生成（spawnVictoryPieceOnce相当）
      const shape = buildRelFromCard(minPlay.cardId);
      if (shape.rel.length){
        const x0 = Math.max(0, Math.floor((12 - shape.w)/2));
        const y0 = Math.max(0, Math.floor((12 - shape.h)/2));
        const pid = minPlay.cardId.replace(/[^a-z0-9\-]/gi,'') + '-' + Date.now().toString(36);
        const obj = { id: pid, round: r, cardId: minPlay.cardId,
          color: minPlay.color, index: minPlay.index,
          rel: shape.rel, w: shape.w, h: shape.h,
          x: x0, y: y0, z: 1,
          lockBy: null, angle:0, flipX:false, flipY:false,
          updatedAt: Date.now()
        };
        await set(piecePath(r,pid), obj);
      }

      // ▼ トークン共有：DB 上に残数を書き込む
      const room = `rooms/${state.code}`;
      const used = (g.doubleScanUsed || 0) + 1;
      await update(ref(db), {
        [`${room}/game/doubleScanUsed`]: used

      });

      // 枠内のカードをブランクに戻す
      // 枠内のカードをブランクに戻す
      box.innerHTML = '';

      // ▼ 同期でプレイ済みカードも消す（全員共有）
      const playsCopy = {...(state.plays||{})};
      for (const uid of Object.keys(playsCopy)) {
        const p = playsCopy[uid];
        if (p && p.cardId === minPlay.cardId && Number(p.round) === r) {
          delete playsCopy[uid];
        }
      }
// まとめて update：plays を更新しつつ、trash/{cardId}=true を立てる
const updates2 = {};
updates2[`${room}/plays`] = playsCopy;
updates2[`${room}/trash/${minPlay.cardId}`] = true; // ★これがポイント
updates2[`${room}/used/${minPlay.cardId}`]  = true; // ★ 追加

await update(ref(db), updates2);    } finally {
      doubleScanBusy = false;
    }
  };
}

}


  // === プレイ ===
  async function playMyCard(cardId){
    const g = state.game || {}; const room = `rooms/${state.code}`; const r = g.round || 1;
    if (g.turnUid !== state.uid) return;
    const mySeat = state.mySeat; if (!mySeat) return;
    const myList = (state.hands?.[String(mySeat)]||[]).slice(); const idx = myList.indexOf(cardId); if (idx<0) return;
    const {color,index} = parseCardId(cardId);

    const updates = {};
    myList.splice(idx,1);
    updates[`${room}/hands/${mySeat}`] = myList;
    updates[`${room}/plays/${state.uid}`] = { cardId, color, index, seat: mySeat, round: r, ts: Date.now() };
    if (!g.startColor){ updates[`${room}/game/startColor`] = color; }

    const nextUid = computeNextTurnUidAfterMyPlay();
    updates[`${room}/game/turnUid`] = nextUid;
  updates[`${room}/used/${cardId}`] = true; // ★ 追加：プレイ直後にプレイ済みへ

    await update(ref(db), updates);
  }
  function computeNextTurnUidAfterMyPlay(){
    const g = state.game || {}; const N = g.playersN || 1; const order = g.orderSeats || []; if (!N || !order.length) return state.uid;
    const r = g.round || 1; const playsNow = Object.values(state.plays || {}).filter(p => Number(p?.round) === r).length + 1;
    if (playsNow >= N){ return null; }
    const nextSeat = order[playsNow % N];
    return seatUid(nextSeat) || null;
  }

  // === 勝者判定 ===
// === 勝者判定（トランプ＝ディシジョン色、なければリード色最大） ===
async function maybeComputeVictory(){
  const g = state.game || {};
  const room = `rooms/${state.code}`;
  const N = g.playersN || 0;
  const r = g.round || 1;
  if (!N) return;

  const playsArr = Object.entries(state.plays||{})
    .map(([uid,v])=>({uid,...v}))
    .filter(p=>Number(p.round)===r);
  if (playsArr.length !== N) return;
  if (g.victory && Number(g.victory.round)===r) return;

  const leadColor = g.startColor;
  const decisionColor = (g?.decision?.color) || 'purple'; // ディシジョンの色をトランプ色に

  const pickMax = (arr) => arr.slice().sort((a,b)=> b.index - a.index)[0];

  // 1) ディシジョン色（トランプ）が1枚でもあれば、その中の最大が勝者
  const decPlays = playsArr.filter(p => p.color === decisionColor);
  let winner;
  if (decPlays.length){
    winner = pickMax(decPlays);
  } else {
    // 2) そうでなければ、リードカラーの中で最大
    const leadPlays = playsArr.filter(p => p.color === leadColor);
    // 先手のカードが必ず含まれる想定だが、安全のためフォールバック
    winner = leadPlays.length ? pickMax(leadPlays) : pickMax(playsArr);
  }

  const vict = {
    cardId: winner.cardId, uid: winner.uid, color: winner.color, index: winner.index,
    round: r, seat: winner.seat, ts: Date.now()
  };
  await update(ref(db), { [`${room}/game/victory`]: vict });
}


  // === 次ラウンド ===
async function onNextRound(){
  const g = state.game || {}; const room = `rooms/${state.code}`; const vict = g.victory; if (!vict) return;

  const rNow = g.round || 1;

  // このラウンドのプレイ済みから「勝者カード以外」を捨て札へ
  const playsArr = Object.entries(state.plays||{})
    .map(([uid,v])=>({uid, ...v}))
    .filter(p => Number(p.round) === rNow);

  const toTrash = [];
  for (const p of playsArr){
    if (p.cardId !== vict.cardId){
      toTrash.push(p.cardId);
    }
  }

  // updates をまとめて一括更新
  const updates = {};

  // 捨て札の追記（id: true）
  for (const id of toTrash){
    updates[`${room}/trash/${id}`] = true;
  }

  // 次ラウンド準備
  const winnerSeat = vict.seat || getSeatOfUid(vict.uid) || g.startSeat;
  const startUid = seatUid(winnerSeat);
  const orderSeatsArr = orderSeatsFrom(winnerSeat, g.playersN);
  const rNext = rNow + 1;
  const nextDecision = { cardId: vict.cardId, color: vict.color, index: vict.index };

  updates[`${room}/plays`]              = null;
  updates[`${room}/game/round`]        = rNext;
  updates[`${room}/game/startSeat`]    = winnerSeat;
  updates[`${room}/game/orderSeats`]   = orderSeatsArr;
  updates[`${room}/game/startUid`]     = startUid || null;
  updates[`${room}/game/turnUid`]      = startUid || null;
  updates[`${room}/game/startColor`]   = null;
  updates[`${room}/game/victory`]      = null;
  updates[`${room}/game/decision`]     = nextDecision;

  await update(ref(db), updates);
  show(nextPanel, false);
}


  // =========================
  // 中央ピース完全版（セル比率・同期ドラッグ）
  // =========================
  // DBパス: rooms/{room}/centerPieces/{round}/{pieceId}
  // PieceObj:
  //  {
  //    id, round, cardId, color, index,
  //    rel: [[r,c],...],    // 形状（カード定義の外接矩形基準）
  //    w, h,                // 形状の列数・行数
  //    x, y,                // 左上アンカー（0..11）セル座標
  //    z,                   // 前面制御
  //    lockBy: uid|null,    // ドラッグロック
  //    updatedAt
  //  }

  function currentRoom(){ return `rooms/${state.code}`; }
  function currentRound(){ return state.game?.round || 1; }
  function getCenterRect(){ return centerPiece.getBoundingClientRect(); }
  function cellSize(){ return getCenterRect().width / 12; }

  function buildRelFromCard(cardId){
    const {color,index} = parseCardId(cardId);
    const def = (CARD_DATA[color]||{})[index] || '';
    if (!def) return { color, index, rel: [], w:1, h:1 };
    const tokens = (def.match(/[A-Z]\d+/gi)||[]).map(s=>s.toUpperCase());
    const cells = tokens.map(t=>({ r:t.charCodeAt(0)-65, c:Number(t.slice(1))-1 }));
    const minR = Math.min(...cells.map(p=>p.r));
    const minC = Math.min(...cells.map(p=>p.c));
    const rel  = cells.map(p=>({ r:p.r-minR, c:p.c-minC }));
    const h = Math.max(...rel.map(p=>p.r))+1;
    const w = Math.max(...rel.map(p=>p.c))+1;
    return { color, index, rel: rel.map(p=>[p.r,p.c]), w, h };
  }

  function piecePath(round,pieceId){ return ref(db, `${currentRoom()}/centerPieces/${round}/${pieceId}`); }
  function roundPath(round){ return ref(db, `${currentRoom()}/centerPieces/${round}`); }

  function wireCenterPiecesListener(){
    // onValue を全体で入れているので、ここでは描画だけ
    renderCenterPieces();
  }

function renderCenterPieces(){
  const rNow = currentRound();
  const dr = state?.dragging?.round;
  const did = state?.dragging?.id;
  if (dr && state.centerPieces?.[dr]?.[did]?.lockBy === state.uid) return;

  centerPiece.innerHTML = '';

  // 1〜現在ラウンドまでを描画対象に
  const rounds = Object.keys(state.centerPieces || {})
    .map(Number)
    .filter(r => r >= 1 && r <= rNow)
    .sort((a,b)=> a-b);

  // [round, id, obj, z2] の配列を作成（z2 = round*1000 + z）
  const entries = [];
  for (const r of rounds){
    const data = state.centerPieces[r] || {};
    for (const [id,obj] of Object.entries(data)){
      const z2 = (r * 1000) + (obj.z || 0);
      entries.push([r, id, obj, z2]);
    }
  }

  // ラウンドも考慮した z2 で安定ソート
  entries.sort((a,b)=> a[3] - b[3]);

  // 現在ラウンドのみ操作可
  for (const [r, id, obj] of entries){
    const interactive = (r === rNow);
    drawPieceEl(r, id, obj, interactive);
  }
}


function drawPieceEl(round, id, obj, interactive = true){
  const el = document.createElement('div');
  el.className = `piece ${obj.color||''}`;
  el.dataset.id = id;

  el.style.setProperty('--w', obj.w);
  el.style.setProperty('--h', obj.h);

  const cell = cellSize();

  // 中身のマス（.sq）を生成
  const rel = Array.isArray(obj.rel) ? obj.rel : [];
  for (const pair of rel){
    const [r, c] = pair;
    const sq = document.createElement('div');
    sq.className = 'sq';
    sq.style.left = (c * cell) + 'px';
    sq.style.top  = (r * cell) + 'px';
    el.appendChild(sq);
  }
  {
    const { cx, cy } = pieceCenterCell(obj);
   el.style.transformOrigin = `${(cx + 0.5) * cell}px ${(cy + 0.5) * cell}px`;
  }
  // 位置＋回転/反転
  const px = obj.x * cell;
  const py = obj.y * cell;
  const ang = obj.angle || 0;
  const sx = obj.flipX ? -1 : 1;
  const sy = obj.flipY ? -1 : 1;
  el.style.transform = `translate(${px}px, ${py}px) rotate(${ang}deg) scale(${sx}, ${sy})`;

  // ラウンド跨ぎの前面制御
  el.style.zIndex = String((round * 1000) + (obj.z || 0));

  if (interactive){
    // 右上ハンドル（⇔：左右反転、⇕：上下反転）
    const handles = document.createElement('div');
    handles.className = 'handles';

    const btnH = document.createElement('div'); btnH.className = 'handle'; btnH.textContent = '⇔';
    const btnV = document.createElement('div'); btnV.className = 'handle'; btnV.textContent = '⇕';

    [btnH, btnV].forEach(b=>{
      b.addEventListener('pointerdown', e=>{ e.stopPropagation(); e.preventDefault(); });
    });

btnH.addEventListener('click', async (e)=>{
  e.stopPropagation();
  const patch = { flipX: !obj.flipX };
  const pos   = computeXYForNewTransform(obj, patch);
  try{
    await update(piecePath(round,id), { ...patch, ...pos, updatedAt: Date.now() });
  }catch(_e){}
});

btnV.addEventListener('click', async (e)=>{
  e.stopPropagation();
  const patch = { flipY: !obj.flipY };
  const pos   = computeXYForNewTransform(obj, patch);
  try{
    await update(piecePath(round,id), { ...patch, ...pos, updatedAt: Date.now() });
  }catch(_e){}
});


    handles.appendChild(btnH);
    handles.appendChild(btnV);
    el.appendChild(handles);

    // クリック回転（移動なしのみ判定）
 // クリック回転（移動なしのみ判定）
let _down = null;
el.addEventListener('pointerdown', (e) => {
  if (e.button !== 0) return;
  _down = { x: e.clientX, y: e.clientY, t: performance.now() };
});

el.addEventListener('pointerup', async (e) => {
  // ★ ドラッグが発生していた場合は回転させない
  if (e.currentTarget?.dataset?.dragMoved === '1') {
    e.currentTarget.dataset.dragMoved = ''; // 次の操作のためクリア
    _down = null;
    return;
  }

  if (!_down) return;
  const dx = Math.abs(e.clientX - _down.x);
  const dy = Math.abs(e.clientY - _down.y);
  const dt = performance.now() - _down.t;
  _down = null;

  // 小移動＆短時間 → クリック扱い（回転）
  if (dx < 4 && dy < 4 && dt < 300) {
const next  = (((obj.angle || 0) + 90) % 360);
const patch = { angle: next };
const pos   = computeXYForNewTransform(obj, patch);
try{
  await update(piecePath(round, id), { ...patch, ...pos, updatedAt: Date.now() });
} catch(_e){}
  }
}, { passive: true });


    // ドラッグ
    el.addEventListener('pointerdown', (ev)=> onPiecePointerDown(ev, round, id, obj));
  }

  centerPiece.appendChild(el);
}

  // 勝者カードクリック時に1回だけ生成（既に存在すれば何もしない）
  async function spawnVictoryPieceOnce(){
    const g = state.game||{}; const vict = g.victory; if (!vict) return;
    const r = g.round || 1;
    const roundData = state.centerPieces?.[r] || {};
    // 既にこのラウンドにピースがある → 何もしない
    if (Object.keys(roundData).length) return;

    const shape = buildRelFromCard(vict.cardId);
    if (!shape.rel.length) return; // 紫0など形無しは無視
    // 初期配置：中央寄せ
    const x0 = Math.max(0, Math.floor((12 - shape.w)/2));
    const y0 = Math.max(0, Math.floor((12 - shape.h)/2));
    const pid = vict.cardId.replace(/[^a-z0-9\-]/gi,'') + '-' + Date.now().toString(36);

    const obj = {
      id: pid, round: r, cardId: vict.cardId, color: vict.color, index: vict.index,
      rel: shape.rel, w: shape.w, h: shape.h,
      x: x0, y: y0, z: 1, lockBy: null,
      angle: 0,
      flipX: false, flipY: false,
      updatedAt: Date.now()    };
    await set(piecePath(r,pid), obj);
    // ★ 追加：このラウンドの場札を全端末で非表示にする
    const room = `rooms/${state.code}`;
    await update(ref(db), { [`${room}/game/hiddenPlaysRound`]: r });
  }

  // ===== ドラッグ実装（セルスナップ・同期） =====
  f// ===== ドラッグ実装（遅延開始：移動が閾値を超えたらドラッグ／超えなければクリック回転） =====
function clampXY(x, y, w, h){
  const maxX = 12 - w;
  const maxY = 12 - h;
  return { x: Math.max(0, Math.min(maxX, x)), y: Math.max(0, Math.min(maxY, y)) };
}


/* ===== 追加: 中心アンカー＆はみ出し抑制ユーティリティ ===== */
function pieceCenterCell(obj){
  const cx = Math.floor(((obj?.w||1) - 1) / 2);
  const cy = Math.floor(((obj?.h||1) - 1) / 2);
  return { cx, cy };
}

function gridSizePx(){ return cellSize() * 12; }

function pieceWorldCenterPx(obj){
  const cell = cellSize();
  const { cx, cy } = pieceCenterCell(obj);
  return {
    cxPx: (obj.x + cx + 0.5) * cell,
    cyPx: (obj.y + cy + 0.5) * cell,
    oxPx: (cx + 0.5) * cell,
    oyPx: (cy + 0.5) * cell,
  };
}

function rotatedHalfExtentsPx(obj){
  const cell = cellSize();
  const wPx = (obj?.w||1) * cell;
  const hPx = (obj?.h||1) * cell;
  const th  = ((obj?.angle||0) % 360) * Math.PI/180;
  const c = Math.cos(th), s = Math.sin(th);
  return {
    halfW: (Math.abs(c)*wPx + Math.abs(s)*hPx) / 2,
    halfH: (Math.abs(s)*wPx + Math.abs(c)*hPx) / 2,
  };
}

function clampCenterPxToGrid(cxPx, cyPx, obj, overhangCells = 0){
  const { halfW, halfH } = rotatedHalfExtentsPx(obj);
  const W = gridSizePx(), H = W;
  const cell = cellSize();
  const margin = (overhangCells || 0) * cell; // ★ 追加: はみ出し許容（セル単位）
  return {
    cxPx: Math.min(W - halfW + margin, Math.max(halfW - margin, cxPx)),
    cyPx: Math.min(H - halfH + margin, Math.max(halfH - margin, cyPx)),
  };
}


function xyFromWorldCenter(nextObj, cxPx, cyPx){
  const cell = cellSize();
  const { oxPx, oyPx } = pieceWorldCenterPx({ ...nextObj, x:0, y:0 });
  const x = Math.round((cxPx - oxPx) / cell);
  const y = Math.round((cyPx - oyPx) / cell);
  return { x, y };
}

function computeXYForNewTransform(oldObj, patch){
  const nextObj = { ...oldObj, ...patch };
  const { cxPx, cyPx } = pieceWorldCenterPx(oldObj);
  const clamped = clampCenterPxToGrid(cxPx, cyPx, nextObj);
  return xyFromWorldCenter(nextObj, clamped.cxPx, clamped.cyPx);
}

function pickMaxZ(r){
  const data = state.centerPieces?.[r] || {};
  let z = 0;
  for (const k in data){ z = Math.max(z, data[k]?.z||0); }
  return z;
}

function onPiecePointerDown(ev, round, id, obj){
  ev.preventDefault();
  const el = ev.currentTarget;

  // クリック／ドラッグ候補の記録（まだドラッグ開始しない）
  el.dataset.downX = String(ev.clientX);
  el.dataset.downY = String(ev.clientY);
  el.dataset.downT = String(performance.now());
  el.dataset.dragActive = '';  // ''=まだドラッグ開始していない

  // 一時リスナーを登録
  const move = (e)=> onPiecePointerMove(e, el, round, id, obj);
  const up   = (e)=> onPiecePointerUp(e, el, move, up, round, id, obj);
  el.addEventListener('pointermove', move);
  el.addEventListener('pointerup', up, { once:true });
  el.addEventListener('pointercancel', up, { once:true });
}

function beginDrag(el, ev, round, id, obj){
  el.setPointerCapture?.(ev.pointerId);
  el.classList.add('dragging');
  el.dataset.dragActive = '1';

  // ローカル状態→ロック（競合抑制）
  state.dragging.id = id;
  state.dragging.round = round;
  state.dragging.ownLock = true;
  update(piecePath(round,id), { lockBy: state.uid }).catch(()=>{});

  // Z持ち上げ（ラウンド考慮の一貫性）
  const nextZ = pickMaxZ(round) + 1;
  update(piecePath(round,id), { z: nextZ }).catch(()=>{});
  el.style.zIndex = String((round * 1000) + nextZ);

  // ポインタ位置→要素左上オフセット
  const rect = el.getBoundingClientRect();
  state.dragging.offPx = { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
}

function onPiecePointerMove(ev, el, round, id, obj){
  // まだドラッグ開始していなければ、移動量で判定
  if (el.dataset.dragActive !== '1'){
    const dx = Math.abs(ev.clientX - Number(el.dataset.downX||0));
    const dy = Math.abs(ev.clientY - Number(el.dataset.downY||0));
    const DRAG_THRESHOLD = 4;  // px
    if (dx >= DRAG_THRESHOLD || dy >= DRAG_THRESHOLD){
      beginDrag(el, ev, round, id, obj);
    }else{
      return; // しきい値未満＝まだクリック候補
    }
  }

  // ここから実ドラッグ中
  if (!state.dragging.id) return;

  const r = state.dragging.round; const pid = state.dragging.id;
  const grid = getCenterRect();
  const cell = grid.width / 12;

  // ★ 修正: 左上アンカーではなく「中心アンカー＋回転後外接矩形」で境界判定
  const anchorPxX = ev.clientX - grid.left - state.dragging.offPx.x;
  const anchorPxY = ev.clientY - grid.top  - state.dragging.offPx.y;

  const cur = state.centerPieces?.[r]?.[pid] || obj;
  if (!cur) return;

  // ピース中心のオフセット（左上→中心）
  const { oxPx, oyPx } = pieceWorldCenterPx({ ...cur, x:0, y:0 });
  const wantCxPx = anchorPxX + oxPx;
  const wantCyPx = anchorPxY + oyPx;

  // 2マスまではみ出し可能にして中心をクリップ
  const clamped = clampCenterPxToGrid(wantCxPx, wantCyPx, cur, 2);

  // クリップした中心座標からグリッド左上(x,y)へ戻す
  const { x, y } = xyFromWorldCenter(cur, clamped.cxPx, clamped.cyPx);

  if (state.dragging.raf) cancelAnimationFrame(state.dragging.raf);
  state.dragging.raf = requestAnimationFrame(async ()=>{
    // ローカル即時反映（回転/反転も維持）
    const ang = cur.angle || 0;
    const sx = cur.flipX ? -1 : 1;
    const sy = cur.flipY ? -1 : 1;
    el.style.transform = `translate(${x*cell}px, ${y*cell}px) rotate(${ang}deg) scale(${sx}, ${sy})`;

    try{
      await update(piecePath(r,pid), { x, y, updatedAt: Date.now() });
    }catch(e){}
  });
}

function onPiecePointerUp(ev, el, move, up, round, id, obj){
  // リスナー解除
  el.removeEventListener('pointermove', move);

  // ドラッグ中なら終了処理（回転はしない）
  if (el.dataset.dragActive === '1'){
    el.classList.remove('dragging');
    el.releasePointerCapture?.(ev.pointerId);

    const r = state.dragging.round; const pid = state.dragging.id;
    update(piecePath(r,pid), { lockBy: null, updatedAt: Date.now() }).catch(()=>{});
    state.dragging.id = null; state.dragging.round = null; state.dragging.ownLock = false;

    // フラグ類クリア
    el.dataset.dragActive = '';
    el.dataset.downX = ''; el.dataset.downY = ''; el.dataset.downT = '';
    return; // ← ここで終了（回転させない）
  }

  // ここに来るのは「クリックのみ」
  const downT = Number(el.dataset.downT||0);
  const dt = performance.now() - downT;
  const dx = Math.abs(ev.clientX - Number(el.dataset.downX||0));
  const dy = Math.abs(ev.clientY - Number(el.dataset.downY||0));

  // クリア
  el.dataset.dragActive = '';
  el.dataset.downX = ''; el.dataset.downY = ''; el.dataset.downT = '';

  // クリックとみなす条件（小移動＆短時間）
  if (dx < 4 && dy < 4 && dt < 300) {
    const next = (((obj.angle || 0) + 90) % 360);
    const baseW = obj.w || 1, baseH = obj.h || 1;
    const rotW = (next % 180 === 0) ? baseW : baseH;
    const rotH = (next % 180 === 0) ? baseH : baseW;
    const x = Math.min(obj.x, 12 - rotW);
    const y = Math.min(obj.y, 12 - rotH);
    update(piecePath(round, id), { angle: next, x, y, updatedAt: Date.now() }).catch(()=>{});
  }
}



  // === 中央ピースの onValue でローカルドラッグと競合しないように反映 ===
  onValue(ref(db, ()=>{})); // no-op to keep module import tree-shake happy

  // 既に wireRoom 内で centerPieces 全体を購読しているので、
  // renderCenterPieces() 内で毎回DOMを作り直し。自分がドラッグ中の要素は
  // lockBy===uid の間は DB 変更を無視（drawPieceEl は都度ロック状態を見ない設計なので
  // ここでガードする代わりに、move で即ローカルに反映→updateで他端末へ）
  // ※必要十分なため簡潔さを優先

  // =========================

  // ========= 相対配置補助 =========
  function seatedList(){ return Object.entries(state.seats).filter(([_,v])=>v && v.uid).map(([k,v])=>({ seat:Number(k), uid:v.uid, name:v.name||'?' })).sort((a,b)=>a.seat-b.seat); }

  // ========= 初期表示 =========
  function init(){ updateHeader(); }
  init();
</script>
</body>
</html>
