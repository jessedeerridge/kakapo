<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ã‚¶ãƒ»ã‚«ã‚«ãƒ</title>
<style>
  :root{
    --card-w: 56px;                 /* è‡ªåˆ†ã®æ‰‹æœ­ã‚«ãƒ¼ãƒ‰å¹…ï¼ˆè¡¨é¢ãƒ¬ãƒ³ãƒ€ï¼‰ */
    --card-w-opp: calc(64px * .4);  /* ç›¸æ‰‹ã®è£é¢ã‚«ãƒ¼ãƒ‰å¹…ï¼ˆè‡ªåˆ†ã®ç´„40%ï¼‰ */
    --card-r: 10px;
    --card-r-opp: 4px;              /* ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è§’ä¸¸ã‚’æŠ‘ãˆã‚‹ */
    --gap: 10px;
    --hand-h: 104px;                /* ç”»é¢ä¸‹ã®æ‰‹æœ­ãƒãƒ¼é«˜ã•ç›®å®‰ */

    /* ç›¸æ‰‹ã‚¨ãƒªã‚¢ã‚’å¤–å´ã¸å¯„ã›ã‚‹é‡ï¼ˆã¾ã¨ã‚ã¦èª¿æ•´ï¼‰ */
    --opp-shift: 28px;

    /* ã‚«ãƒ¼ãƒ‰è¡¨é¢ */
    --grid-gap: 2px;
    --radius: 8px;
    --paper: #fff;

    /* æ±ºå®šè‰²ï¼ˆãƒ‡ã‚£ã‚·ã‚¸ãƒ§ãƒ³ï¼‰ï¼šå¸¸ã«ç´« */
    --decision-color: #8e24aa;

    /* ä¸­å¤®12x12ã®ã‚»ãƒ«ã‚µã‚¤ã‚º */
    --center-cell: 28px;
    /* ã‚«ãƒ¼ãƒ‰é¢ã‚»ãƒ«ï¼ˆã‚«ãƒ¼ãƒ‰ã®ä¸­ã®ãƒŸãƒ‹æ ¼å­ï¼‰ */
    --cell-size: 8px;
  }

  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#fff;color:#111}
  header{display:flex;justify-content:space-between;align-items:center;padding:12px;border-bottom:1px solid #eee;gap:8px}
  h1{margin:0;font-size:18px}
  .small{font-size:12px;opacity:.85;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .copybtn{padding:6px 10px;border:1px solid #ddd;border-radius:10px;background:#f7f7f7;cursor:pointer}
  main{padding:14px;display:grid;gap:16px;max-width:1100px;margin:0 auto; padding-bottom: calc(var(--hand-h) + 24px);}  

  .join-box{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .join-box input{padding:10px;border:1px solid #ddd;border-radius:8px;font-size:16px}
  .btn{padding:10px 14px;border:1px solid #ddd;border-radius:10px;background:#111;color:#fff;cursor:pointer}
  .btn.ghost{background:#f7f7f7;color:#111}
  .btn.sm{padding:6px 10px;border-radius:8px}
  .hidden{display:none !important}
  .muted{opacity:.7; font-size:13px}

  /* å³ä¸‹ï¼šè¨­å®š(FAB) */
  .fab{
    position:fixed; right:16px; bottom:16px; z-index:70;
    width:48px; height:48px; border-radius:50%;
    display:flex; align-items:center; justify-content:center;
    background:#111; color:#fff; border:1px solid #000; cursor:pointer;
    box-shadow:0 6px 18px rgba(0,0,0,.2);
  }

  /* ãƒ†ãƒ¼ãƒ–ãƒ«ï¼†å ´é…ç½® */
  .table-area{ position:relative; min-height:420px; border:none; border-radius:0; padding:0; overflow:visible; }
  .badge{display:inline-block;padding:2px 8px;border-radius:999px;background:#111;color:#fff;font-size:12px}

  /* ç›¸æ‰‹ã‚¨ãƒªã‚¢ï¼ˆ3äººã¨ã‚‚åŒã˜å½¢ãƒ»åŒã˜å‘ãï¼‰ */
  .opp{ position:absolute; width:240px; height:180px; display:block; }
  .opp.A{left: calc(-150px - var(--opp-shift)); top:50%; transform:translateY(-50%);} /* å·¦ */
  .opp.B{right:calc(-150px - var(--opp-shift)); top:50%; transform:translateY(-50%);} /* å³ */
  .opp.C{left:50%; top: calc(-20px - var(--opp-shift)); transform:translateX(-50%);}    /* ä¸Š */

  .opp .badge{
    background: #f6f0e6; color:#111; border:2px dashed #333; border-radius:10px; padding:4px 10px; font-weight:700; font-size:12px;
    position:absolute; left:50%; bottom:100px; transform:translateX(-50%);
  }

  /* æ‰‡ã®åœŸå°ï¼ˆå…¨å“¡â€œä¸Šå‘ãâ€ã§çµ±ä¸€ï¼‰ */
  .fan{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:0; height:0; }
  .fan .card.opp{
    position:absolute; left:0; top:0; width: var(--card-w-opp); height: calc(var(--card-w-opp) / 0.714);
    border:1px solid #ddd; border-radius: var(--card-r-opp);
    background: url("kakapocardback.jpg") center/cover no-repeat;
    transform-origin:50% 100%; will-change: transform; backface-visibility: hidden; transform: translateZ(0);
    pointer-events:none;
  }

  /* è‡ªåˆ†ã®æ‰‹æœ­ãƒãƒ¼ */
  .handbar{
    position:fixed; left:0; right:0; bottom: calc(env(safe-area-inset-bottom) + 10px);
    z-index:40; display:flex; gap:8px; flex-wrap:wrap; justify-content:center;
    padding:10px 12px 14px; background:linear-gradient(to bottom, rgba(255,255,255,.0), rgba(255,255,255,.7) 40%, rgba(255,255,255,.95));
    backdrop-filter: blur(2px); min-height: var(--hand-h);
  }

  /* æ±ç”¨ã‚«ãƒ¼ãƒ‰ç®±ï¼ˆè‡ªåˆ†/å ´ã®è¡¨é¢ï¼‰ */
  .cardbox{ width:var(--card-w); aspect-ratio: 63.5 / 88.9; display:flex; align-items:center; justify-content:center; }
  .clickable{ cursor:pointer; }
  .unplayable{ opacity:.35; filter:grayscale(60%); pointer-events:none; }

  /* â€œå ´â€ã‚¹ãƒ­ãƒƒãƒˆ */
  .play-slot{ position:absolute; display:flex; align-items:center; justify-content:center; z-index:4; }
  .play-mine-fixed{ position:fixed; left:50%; bottom: calc(var(--hand-h) + 3px); transform:translateX(-50%); z-index:45; display:flex; align-items:center; justify-content:center; }
  .play-A{ left: calc(70px - var(--opp-shift)); top:60%; transform:translateY(-50%);}  /* å·¦ã®å ´ */
  .play-B{ right:calc(40px - var(--opp-shift)); top:60%; transform:translateY(-50%);} /* å³ã®å ´ */
  .play-C{ left:50%; top:  calc(110px - var(--opp-shift)); transform:translate(-50%, 0);}   /* ä¸Šã®å ´ */
  .played.winner .cardbox{ transform: scale(1.3); transform-origin:center; }

  /* ========= 40æšã‚«ãƒ¼ãƒ‰ã®è¡¨é¢ã‚¹ã‚¿ã‚¤ãƒ« ========= */
  .face{ position:relative; width: 100%; height: 100%; background:var(--paper); border:2px solid var(--color, #999); border-radius: var(--radius); padding: 10px; box-shadow: 0 2px 10px rgba(0,0,0,.06); color: var(--color, #666); display:flex; justify-content:center; align-items:center; overflow:hidden; }
  .ovalBG{ position:absolute; left:50%; top:50%; width:72%; height:64%; transform:translate(-50%,-50%) rotate(18deg); background: currentColor; border-radius: 42% / 58%; pointer-events:none; z-index:0;  }
  .num{ position:absolute; font-weight:800; font-size:14px; line-height:1; color: var(--color, #666); user-select:none; }
  .tl{ top:4px; left:4px; } .tr{ top:4px; right:4px; } .bl{ bottom:4px; left:4px; transform: rotate(180deg); } .br{ bottom:4px; right:4px; transform: rotate(180deg); }

  /* ã‚«ãƒ¼ãƒ‰å†…ã®å°ã•ãªæ ¼å­ï¼ˆç©ºã‚»ãƒ«ã¯é€æ˜ï¼‰ */
  .grid{
    display:grid;
    grid-template-columns: repeat(var(--cols), var(--cell-size));
    grid-template-rows: repeat(var(--rows), var(--cell-size));
    gap: 0;
    justify-content:center;
    align-content:center;
  }
  .cell{ width:var(--cell-size); height:var(--cell-size); }
  .cell.filled{
    background: currentColor;
    border-radius: .4px;
    border: 1px solid #fff;
    z-index: 2;
  }

  /* è‰²ãƒ†ãƒ¼ãƒ */
  .red   { --color:#e53935; color:#e53935; }
  .blue  { --color:#1e88e5; color:#1e88e5; }
  .green { --color:#43a047; color:#43a047; }
  .yellow{ --color:#fdd835; color:#fdd835; }
  .purple{ --color:#8e24aa; color:#8e24aa; }

  /* å·¦ä¸Šï¼šãƒ‡ã‚£ã‚·ã‚¸ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰è¡¨ç¤º */
  .victoryArea{ position:fixed; left:12px; top:60px; z-index:50; display:flex; flex-direction:column; align-items:center; gap:6px; background:rgba(255,255,255,.9); border:1px solid #eee; border-radius:12px; padding:8px 10px; box-shadow:0 4px 20px rgba(0,0,0,.08); }
  .victoryArea .title{ font-size:12px; opacity:.8; font-weight:700; }
  .victoryArea .cardbox{ transform: scale(1.1); }


  /* å³ä¸‹ï¼šæ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰ï¼ˆç·‘ï¼‰ */
  .nextPanel{ position:fixed; right:12px; bottom:12px; z-index:55; display:flex; align-items:center; justify-content:center; background:transparent; border:none; padding:0; }
  .nextBtn{ border:2px solid #2e7d32; color:#fff; background:#2e7d32; padding:10px 16px; border-radius:999px; font-weight:700; cursor:pointer; box-shadow:0 4px 12px rgba(0,0,0,.12); }
/* å·¦ä¸‹ï¼šã‚´ãƒŸç®±ï¼ˆFABï¼‰ */
.trashBtn{
  position:fixed; left:12px; bottom:12px; z-index:56;
  width:48px; height:48px; border-radius:50%;
  display:flex; align-items:center; justify-content:center;
  background:#111; color:#fff; border:1px solid #000; cursor:pointer;
  box-shadow:0 6px 18px rgba(0,0,0,.2);
}

/* æ¨ã¦æœ­ãƒãƒƒãƒ—ï¼ˆãƒœãƒˆãƒ ã‚·ãƒ¼ãƒˆï¼‰ */
.trash-panel{
  position:relative;
  background:rgba(255,255,255,.98);
  border-radius:16px;                 /* â† ä¸Šä¸‹ã™ã¹ã¦ã®è§’ã‚’ä¸¸ã */
  border:1px solid #eee;              /* â† ä¸Šã ã‘ã§ãªãå…¨é¢ãƒœãƒ¼ãƒ€ãƒ¼ */
  box-shadow:0 4px 30px rgba(0,0,0,.12);
  padding:10px 12px;
  width:min(680px, calc(100vw - 32px));
  margin:0 auto;
}

.trash-grid{
  display:flex;flex-direction:column;gap:10px;
}
.trash-row{
  display:flex;align-items:center;gap:8px;flex-wrap:wrap;
}
.trash-row .label{
  font-weight:700;width:64px;text-transform:capitalize;
}
.dim{ opacity:.45; filter:grayscale(30%); }

  /* å‡ºã›ã‚‹ã‚«ãƒ¼ãƒ‰ã®é¼“å‹•ã‚¢ãƒ‹ãƒ¡ï¼ˆè‡ªåˆ†ã®æ‰‹ç•ªã®ã¿é©ç”¨ï¼‰ */
  @keyframes pulse12 { 0% { transform: scale(1.0); } 50% { transform: scale(1.2); } 100% { transform: scale(1.0); } }
  .pulsate { animation: pulse12 1.2s ease-in-out infinite; transform-origin:center; }

  /* ãƒ€ãƒ–ãƒ«ã‚¹ã‚­ãƒ£ãƒ³UIï¼ˆå³å´ï¼‰ */
  #doubleScanArea { left: 120px; top: 60px; }
  .doubleScan { display:flex; flex-direction:column; align-items:center; margin-bottom:6px; }
  .doubleScan .label { font-size:12px; font-weight:700; margin-bottom:4px; }
  .doubleScan .circles { display:flex; gap:6px; }
  .doubleScan .circles span { width:14px; height:14px; border-radius:50%; background:#000; display:inline-block; }
  .blank-card { border:2px dashed #999; border-radius: var(--radius); width: var(--card-w); aspect-ratio: 63.5 / 88.9; background: transparent; }

/* â–¼ ä¸­å¤® 12x12 ã‚°ãƒªãƒƒãƒ‰ï¼ˆèƒŒæ™¯ã«ç”»åƒã€ä¸Šã«ç½«ç·šï¼‰ */
.center-grid{
  position:absolute;
  left:50%; top:80%;
  transform:translate(-50%,-50%);
  width: calc(12 * var(--center-cell));
  height: calc(12 * var(--center-cell));
  /* ä¸Šã‹ã‚‰é †ã«å‰é¢ â†’ èƒŒé¢ã€‚ç½«ç·šã‚’å‰é¢ã€ç”»åƒã‚’èƒŒé¢ã«é…ç½® */
  background:
    linear-gradient(to right, black 1px, transparent 1px) 0 0/var(--center-cell) var(--center-cell),
    linear-gradient(to bottom, black 1px, transparent 1px) 0 0/var(--center-cell) var(--center-cell),
    url("celltable.jpg") center/cover no-repeat;
  /* ç”»åƒãŒè¦‹ãˆã‚‹ã‚ˆã†ã«ç™½ãƒ™ãƒ¼ãƒ«ã¯æ’¤å» */
  border: 1px solid #d0d0d0;
  border-radius: 0;
  z-index: 1;
  pointer-events: none; /* èª¤ã‚¿ãƒƒãƒ—é˜²æ­¢ï¼šä¸Šã®ã‚«ãƒ¼ãƒ‰æ“ä½œã‚’é‚ªé­”ã—ãªã„ */
}


  /* â–¼ ãƒ”ãƒ¼ã‚¹ï¼ˆãƒ‰ãƒ©ãƒƒã‚°å¯¾è±¡ï¼‰ã‚’è¼‰ã›ã‚‹ãƒ¬ã‚¤ãƒ¤ */
  .center-piece-layer{
    position:absolute;
    left:50%; top:80%;
    transform:translate(-50%,-50%);
    width: calc(12 * var(--center-cell));
    height: calc(12 * var(--center-cell));
  z-index: 60;           /* ä¸­å¤®ãƒ”ãƒ¼ã‚¹ãŒ play-slot(4) ã‚„ handbar(45) ã‚ˆã‚Šå‰ã«æ¥ã‚‹ã‚ˆã†ã« */
  pointer-events: auto;
  touch-action: none;    /* å¿µã®ãŸã‚ */

  }
.piece{
  position:absolute; left:0; top:0;
  transform-origin: 0 0; /* å·¦ä¸ŠåŸºæº–ã§å›è»¢/åè»¢ â†’ ã‚»ãƒ«ç›®ã«ãƒ”ãƒƒã‚¿ãƒª */
  /* å¹…ãƒ»é«˜ã•ã¯ JS ã§ --w, --h ã‚’è¨­å®šï¼ˆã‚»ãƒ«æ•°ï¼‰ */
  width: calc(var(--w) * var(--center-cell));
  height: calc(var(--h) * var(--center-cell));
  cursor: grab;
  touch-action: none; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æŠ‘æ­¢ */
}

  .piece.dragging{ cursor: grabbing; }
  .piece .sq{
    position:absolute;
    width: var(--center-cell);
    height: var(--center-cell);
    background: currentColor;
    border: 1px solid #fff;         /* ç™½æ  */
    border-radius: 2px;
    box-sizing: border-box;
    pointer-events: none;           /* ãƒ’ãƒƒãƒˆã¯è¦ª .piece ã«é›†ç´„ */
  }

/* è¿½åŠ : ãƒ•ãƒªãƒƒãƒ—ãƒãƒ³ãƒ‰ãƒ« */
.piece .handles{
  position:absolute;
  right:-4px;               /* å³ä¸Šã«å°‘ã—å¤–å´ã¸ */
  top:-24px;
  display:flex; gap:4px;
  z-index:2;
  pointer-events:auto;
}
.piece .handle{
  font-size:12px; line-height:1;
  padding:4px 6px;
  border-radius:12px;
  background:rgba(17,17,17,.85);
  color:#fff;
  border:1px solid rgba(0,0,0,.35);
  box-shadow:0 2px 6px rgba(0,0,0,.18);
  cursor:pointer; user-select:none;
}
.piece .handle:active{ transform:translateY(1px); }

.trash-row .label{ display:none; }










/* ====== å…±é€šï¼šã‚«ãƒ¼ãƒ‰å¹…ã«å¿œã˜ã¦æ¯”ç‡ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆè¿½è¨˜ï¼‰ ====== */
:root{
  /* ãƒ™ãƒ¼ã‚¹è¨­è¨ˆå€¤ï¼ˆä»Šã®PCã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦å¿…è¦ãªã‚‰èª¿æ•´ï¼‰ */
  --card-w-base: 56px;      /* æ—¢å®šã®ã‚«ãƒ¼ãƒ‰å¹… */
  --num-size-base: 14px;    /* è§’ã®æ•°å­—ã®æ—¢å®šãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º */
  --cell-size-base: 8px;    /* ã‚«ãƒ¼ãƒ‰å†…ã‚»ãƒ«ã®æ—¢å®šã‚µã‚¤ã‚ºï¼ˆpxï¼‰ */
  --face-padding-base: 10px;/* ã‚«ãƒ¼ãƒ‰å†…ä½™ç™½ã®æ—¢å®šï¼ˆpxï¼‰ */
  --card-radius-base: 6px;  /* ã‚«ãƒ¼ãƒ‰è§’ä¸¸ã®æ—¢å®šï¼ˆpxï¼‰ */

  /* æ¯”ç‡ï¼ˆ--card-w ã«é€£å‹•ã€‚--card-w æœªå®šç¾©ã§ã‚‚ãƒ™ãƒ¼ã‚¹ã§å‹•ä½œï¼‰ */
  --card-scale: calc(var(--card-w, var(--card-w-base)) / var(--card-w-base));

  /* æ´¾ç”Ÿãƒˆãƒ¼ã‚¯ãƒ³ï¼šä»¥ä¸‹ã¯å…¨éƒ¨ --card-w ã«è¿½å¾“ */
  --num-size: clamp(8px, calc(var(--num-size-base) * var(--card-scale)), var(--num-size-base));
  --cell-size: max(3.5px, calc(var(--cell-size-base) * var(--card-scale)));
  --face-padding: max(2px, calc(var(--face-padding-base) * var(--card-scale)));
  --card-radius: calc(var(--card-radius-base) * var(--card-scale));

  /* ç›¸æ‰‹ã‚«ãƒ¼ãƒ‰å¹…ã‚‚æ¯”ç‡ã§ï¼ˆå…ƒã® 64px * .36 â‰’ 23.04px / 56px â‰’ 0.41ï¼‰ */
  --opp-w-ratio: 0.41;
  --card-w-opp: calc(var(--card-w, var(--card-w-base)) * var(--opp-w-ratio));
}

/* æœ€å°é™ã®ä¸Šæ›¸ãï¼ˆæ—¢å­˜CSSãŒã“ã‚Œã‚‰ã®å¤‰æ•°ã‚’å‚ç…§ã—ã¦ã„ã‚Œã°ä¸è¦ã§ã™ï¼‰ */
.face{ padding: var(--face-padding); border-radius: var(--card-radius); }
.face .num{ font-size: var(--num-size); line-height: 1; }

/* ï¼ˆä¿é™ºï¼‰ã‚‚ã— .cell ã®ã‚µã‚¤ã‚ºãŒå¤‰æ•°å‚ç…§ã«ãªã£ã¦ã„ãªã„å ´åˆã ã‘æœ‰åŠ¹åŒ–ã—ã¦ãã ã•ã„
.face .cell, .grid .cell{ width: var(--cell-size); height: var(--cell-size); }
*/

/* ====== ãƒ¢ãƒã‚¤ãƒ«ï¼šå¹…ã ã‘æŒ‡å®šã™ã‚Œã°ä»–ã¯è‡ªå‹•ã§ç¸®å° ====== */
@media (max-width: 600px){
  :root{
    --card-w: 40px;  /* â†ã”æŒ‡å®šã®å€¤ã€‚ã“ã‚Œã ã‘ã§æ•°å­—/ã‚»ãƒ«/ä½™ç™½/è§’ä¸¸ã‚‚è‡ªå‹•ã§å°ã•ããªã‚‹ */
    /* --card-w-opp ã¯ä¸Šã®æ¯”ç‡å¼ã«ã‚ˆã‚Šè‡ªå‹•æ›´æ–°ã•ã‚Œã¾ã™ */
  }
}


/* ===== ã‚¹ãƒãƒ›æ™‚ï¼šã‚»ãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«ï¼†ãƒ”ãƒ¼ã‚¹ å›ºå®šã‚µã‚¤ã‚º ===== */
@media (max-width: 600px){
  :root{
    --center-cell: 22px;  /* â† å›ºå®šã‚µã‚¤ã‚ºï¼ˆ1ãƒã‚¹ã®ä¸€è¾ºï¼‰ã“ã“ã ã‘å¤‰ãˆã‚Œã°OK */
  }

  /* ä»»æ„ï¼šå°ã•ã„æ™‚ã«æ ç·šãŒç´°ã™ããªã„ã‚ˆã†å¾®èª¿æ•´ */
  .piece .sq{
    border-width: max(1px, calc(var(--center-cell) * 0.04));
    border-radius: calc(var(--center-cell) * 0.08);
  }
}






/* handbar ã®ãƒ¢ãƒã‚¤ãƒ«2æ®µãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
@media (max-width: 600px){
  .handbar{
    flex-direction: column;   /* â†ç¸¦ç©ã¿ */
    flex-wrap: nowrap;
    align-items: center;
    gap: 6px;
  }
  .handbar .handrow{
    display: flex;
    gap: 6px;
    justify-content: center;
  }
  /* ä¸‹æ®µãŒã‚ã‚‹ã¨ãã¯é«˜ã•ã‚’å°‘ã—å¢—ã‚„ã™ï¼ˆã‚«ãƒ¼ãƒ‰é«˜ã•=å¹…/0.714ï¼‰ */
  .handbar.two-lines{
    min-height: calc(var(--hand-h) + (var(--card-w) / 0.714) + 12px);
  }
}




@media (max-width: 600px){
  /* è¦‹å‡ºã—ã‚’2è¡Œï¼†ä¸­å¤®å¯„ã› */
  #victoryArea { 
    text-align: center;        /* å­ã®ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³è¦ç´ ã‚’ä¸­å¤®ã« */
  }
  #victoryArea .title{
    position: relative;
    color: transparent;        /* å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆã‚’è¦–è¦šçš„ã«éš ã™ */
  }
  #victoryArea .title::before{
    content: "ãƒ‡ã‚£ã‚·ã‚¸ãƒ§ãƒ³\Aã‚«ãƒ¼ãƒ‰";  /* \A ã§æ”¹è¡Œ */
    white-space: pre; 
    color: #111;
    line-height: 1.1;
    display: block;            /* ãƒ–ãƒ­ãƒƒã‚¯ã«ã—ã¦ */
    margin: 0 auto;            /* è‡ªèº«ã‚‚ä¸­å¤®ã« */
  }

  /* ã‚«ãƒ¼ãƒ‰ï¼ˆç”»åƒå«ã‚€ï¼‰ã‚’ä¸­å¤®å¯„ã› */
  #victoryArea .card,
  #victoryArea .card > img,
  #victoryArea img.card,
  #victoryArea .decisionCard {
    display: block;
    margin-left: auto;
    margin-right: auto;
  }

  /* ã‚«ãƒ¼ãƒ‰ä¸€è¦§ãŒã‚³ãƒ³ãƒ†ãƒŠã§æ¨ªä¸¦ã³ãªã‚‰ä¸­å¤®å¯„ã› */
  #victoryArea .cards,
  #victoryArea .card-list,
  #victoryArea .deck {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;           /* åã¾ã‚‰ãªã„ã¨ãã¯æŠ˜ã‚Šè¿”ã™ */
    gap: 8px;
  }
}


/* æ¨ã¦æœ­ä¸€è¦§ã®ã‚«ãƒ¼ãƒ‰ã‚’å…¨ä½“ã®85%ã«ï¼ˆå½±éŸ¿ç¯„å›²ã¯ .trash-panel å†…ã®ã¿ï¼‰ */
.trash-panel{
  --trash-scale: 0.85; /* â† å¥½ã¿ã§ 0.80ã€œ0.90 ã«èª¿æ•´å¯ */
}
.trash-panel .cardbox{
  /* å¹…ã ã‘å°ã•ã â†’ é«˜ã•ã¯ aspect-ratio ã§è¿½å¾“ */
  width: calc(var(--card-w, var(--card-w-base)) * var(--trash-scale));
}
/* æ•°å­—ãƒ»å†…å´ã‚»ãƒ«ãƒ»ä½™ç™½ãªã©ã‚‚åŒç‡ã§ç¸®å°ï¼ˆã«ã˜ã¿é˜²æ­¢ï¼‰ */
.trash-panel .face{
  padding: calc(var(--face-padding) * var(--trash-scale));
  border-radius: calc(var(--card-radius) * var(--trash-scale));
}
.trash-panel .face .num{
  font-size: calc(var(--num-size) * var(--trash-scale));
}
.trash-panel .cell{
  width:  calc(var(--cell-size) * var(--trash-scale));
  height: calc(var(--cell-size) * var(--trash-scale));
}




/* ===== ã‚¹ãƒãƒ›æ™‚ï¼šä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ‰‹æœ­ & å ´ã®ä½ç½®èª¿æ•´ï¼ˆä¸Šæ›¸ãï¼‰ ===== */
@media (max-width: 600px){
  :root{
    /* ã¾ãšå…¨ä½“ã®æŠ¼ã—å‡ºã—é‡ã‚’å¼±ã‚ã‚‹ï¼ˆãƒã‚¤ãƒŠã‚¹ã«ã™ã‚‹ã¨å†…å´ã«å¯„ã‚Šã¾ã™ï¼‰ */
    --opp-shift: -10px;

    /* â† ã“ã“ã‚’è§¦ã‚Œã° â€œæ„Ÿè¦šçš„ã«â€ ä½ç½®èª¿æ•´ã§ãã¾ã™ï¼ˆæ¨å¥¨: ã“ã“ã ã‘è§¦ã‚‹ï¼‰ */
    --opp-side-x: -118px;   /* A/B ã®å·¦å³ä½ç½®ï¼ˆè² ã®çµ¶å¯¾å€¤â†‘ã§å¤–ã«ã€â†“ã§å†…å´ã«ï¼‰ */
    --opp-side-y: 56%;      /* A/B ã®ç¸¦ä½ç½®ï¼ˆ50%ã§ãƒ‰çœŸã‚“ä¸­ï¼‰ */
    --opp-top-y: 8px;       /* C ã®ä¸Šç«¯ã‹ã‚‰ã®è·é›¢ */

    --play-side-x: 22px;    /* A/B ã® â€œå ´â€ ã®å·¦å³ä½ç½® */
    --play-side-y: 64%;     /* A/B ã® â€œå ´â€ ã®ç¸¦ä½ç½® */
    --play-top-y: 92px;     /* C ã® â€œå ´â€ ã®ç¸¦ä½ç½® */

    /* ãƒãƒƒã‚¸ã®ä½ç½®ï¼ˆå¿…è¦ãªã‚‰ï¼‰ */
    --opp-badge-bottom: 76px;
  }

  /* ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ‰‹æœ­ï¼ˆæ‰‡ã®åœŸå°ã”ã¨ï¼‰ */
  .opp.A{ left: var(--opp-side-x); top: var(--opp-side-y); transform: translateY(-50%); }
  .opp.B{ right:var(--opp-side-x); top: var(--opp-side-y); transform: translateY(-50%); }
  .opp.C{ left: 50%; top: var(--opp-top-y); transform: translateX(-50%); }

  /* ãƒãƒƒã‚¸ã®å¾®èª¿æ•´ï¼ˆå¿…è¦ãªã¨ãã ã‘æ´»ãã¾ã™ï¼‰ */
  .opp .badge{ bottom: var(--opp-badge-bottom); }

  /* å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã® â€œå ´â€ ã®ä½ç½®ã‚‚åˆã‚ã›ã¦å¯„ã›ã‚‹ */
  .play-A{ left: var(--play-side-x); top: var(--play-side-y); transform: translateY(-50%); }
  .play-B{ right:var(--play-side-x); top: var(--play-side-y); transform: translateY(-50%); }
  .play-C{ left: 50%; top: var(--play-top-y); transform: translate(-50%, 0); }
}

/* ã•ã‚‰ã«å°ã•ã„ç«¯æœ«å‘ã‘ã®äºˆå‚™ãƒ—ãƒªã‚»ãƒƒãƒˆï¼ˆä»»æ„ï¼‰ */
@media (max-width: 380px){
  :root{
    --opp-side-x: -110px;
    --opp-side-y: 58%;
    --play-side-x: 18px;
    --play-side-y: 66%;
    --play-top-y: 96px;
  }
}

/* === ã‚¹ãƒãƒ›ï¼šãƒ‡ã‚£ã‚·ã‚¸ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰ãƒãƒƒãƒ—ã‚’ç´°ãã™ã‚‹ === */
@media (max-width: 600px){
  /* ãƒãƒƒãƒ—æœ¬ä½“ã‚’ã‚«ãƒ¼ãƒ‰å¹… + å·¦å³ä½™ç™½ã«å›ºå®š */
  #victoryArea{
    width: calc(var(--card-w) + 16px); /* 8px+8px ã®ä½™ç™½ã¶ã‚“ã‚’åŠ ç®— */
    padding: 6px 8px;                  /* æ—¢å­˜ã‚ˆã‚Šå°‘ã—ã‚¿ã‚¤ãƒˆã« */
  }

  /* ãƒ¢ãƒã‚¤ãƒ«ã§ã¯æ‹¡å¤§ã‚’è§£é™¤ï¼ˆæº¢ã‚Œé˜²æ­¢ï¼‰ */
  #victoryArea .cardbox{
    transform: none;
  }

  /* è¦‹å‡ºã—ãŒå¹…ã‚’æŠ¼ã—åºƒã’ãªã„ã‚ˆã†ã« */
  #victoryArea .title{ font-size: 11px; }
  #victoryArea .title::before{
    /* æ—¢å­˜ã® \A æ”¹è¡Œã‚’ç¶­æŒã—ã¤ã¤ã€ã¯ã¿å‡ºã•ãªã„ã‚ˆã†ä»»æ„ä½ç½®ã§æŠ˜ã‚Šå¯èƒ½ã« */
    overflow-wrap: anywhere;
  }
}

/* --- ã‚¹ãƒãƒ›æ™‚ï¼šä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ‰‹æœ­ã ã‘ä¸‹ã’ã‚‹ & ä¸Šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å…¨ä½“ã‚’å°‘ã—ä¸‹ã¸ --- */
@media (max-width: 600px){
  :root{
    /* ä¸Šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å…¨ä½“ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆãƒãƒ¼ãƒ ã‚‚å«ã‚ã¦ä¸‹ã’ã‚‹ï¼‰ */
    --opp-top-y: 20px;        /* æ—¢å­˜ã® 8px ã‚’ä¸Šæ›¸ãï¼šå°‘ã—ä¸‹ã¸ */

    /* ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã® â€œæ‰‹æœ­ï¼ˆæ‰‡ï¼‰ã ã‘â€ ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆé‡ */
    --fan-shift-side: 30px;   /* A/B ã®æ‰‡ã‚’ä¸‹ã’ã‚‹é‡ï¼ˆãŠå¥½ã¿ã§ 10ã€œ18px ç›®å®‰ï¼‰ */
    --fan-shift-top: 25px;     /* C ã®æ‰‡ã‚’å¾®èª¿æ•´ã—ãŸã„å ´åˆã€‚ä¸è¦ãªã‚‰ 0px ã§ã‚‚OK */
  }

  /* æ‰‹æœ­ï¼ˆæ‰‡ï¼‰ã ã‘ä¸‹ã’ã‚‹ï¼šãƒãƒ¼ãƒ ï¼ˆ.badgeï¼‰ã‚„æ ï¼ˆ.oppï¼‰ã¯å‹•ã‹ã•ãªã„ */
  .opp.A .fan,
  .opp.B .fan{ top: calc(50% + var(--fan-shift-side)); }

  /* ä¸Šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ â€œå…¨ä½“â€ ã‚’ä¸‹ã’ã‚‹ï¼ˆãƒãƒ¼ãƒ ã‚‚ä¸€ç·’ã«ï¼‰ï¼‹å¿…è¦ãªã‚‰æ‰‡ã‚‚å¾®èª¿æ•´ */
  .opp.C{ top: var(--opp-top-y); }            /* å…¨ä½“ã‚’ä¸‹ã’ã‚‹ */
  .opp.C .fan{ top: calc(50% + var(--fan-shift-top)); }  /* æ‰‡ã ã‘å¾®èª¿æ•´ï¼ˆä»»æ„ï¼‰ */
}


</style>
</head>
<body>
<header>
  <h1>ã‚¶ãƒ»ã‚«ã‚«ãƒ</h1>
  <div class="small" id="headerInfo"></div>
</header>

<main>
  <!-- å…¥å®¤ -->
  <section id="joinPanel" class="join-box">
    <input id="nameInput" placeholder="åå‰ï¼ˆ1æ–‡å­—ï¼‰" maxlength="1" inputmode="text" />
    <input id="codeInput" placeholder="ãƒ«ãƒ¼ãƒ ã‚³ãƒ¼ãƒ‰ï¼ˆä¾‹: 1234ï¼‰" maxlength="12" inputmode="numeric" />
    <button id="btnJoin" class="btn">å…¥å®¤</button>
  </section>

  <!-- ãƒ†ãƒ¼ãƒ–ãƒ« -->
  <section id="afterPanel" class="hidden">
    <div id="hostBar" class="hidden" style="display:none">
      <span id="hostInfo">ãƒ›ã‚¹ãƒˆæœªè¨­å®š</span>
      <button id="btnBecomeHost" class="btn">ãƒ›ã‚¹ãƒˆã«ãªã‚‹</button>
      <button id="btn1p" class="btn ghost">1äºº</button>
      <button id="btn2p" class="btn ghost">2äºº</button>
      <button id="btn3p" class="btn ghost">3äºº</button>
      <button id="btn4p" class="btn ghost">4äºº</button>
      <span class="muted">â€»äººæ•°ã‚’é¸ã¶ã¨é…å¸ƒãƒ»ãƒ©ã‚¦ãƒ³ãƒ‰åˆæœŸåŒ–</span>
    </div>

    <div id="tableArea" class="table-area">
      <!-- â–¼ ä¸­å¤® 12x12 ã‚°ãƒªãƒƒãƒ‰ç·š -->
      <div id="centerGrid" class="center-grid" aria-hidden="true"></div>
      <!-- â–¼ ãƒ‰ãƒ©ãƒƒã‚°åŒæœŸãƒ”ãƒ¼ã‚¹ã®æç”»ãƒ¬ã‚¤ãƒ¤ -->
      <div id="centerPiece" class="center-piece-layer" aria-label="drag-layer"></div>

      <!-- ç›¸æ‰‹A/B/C -->
      <div id="oppA" class="opp A hidden">
        <div class="fan"></div>
        <div class="badge">A</div>
      </div>
      <div id="oppB" class="opp B hidden">
        <div class="fan"></div>
        <div class="badge">B</div>
      </div>
      <div id="oppC" class="opp C hidden">
        <div class="fan"></div>
        <div class="badge">C</div>
      </div>

      <!-- â€œå ´â€ï¼ˆç›¸æ‰‹ï¼‰ -->
      <div id="playA" class="play-slot play-A"></div>
      <div id="playB" class="play-slot play-B"></div>
      <div id="playC" class="play-slot play-C"></div>
    </div>
  </section>
</main>

<!-- è‡ªåˆ†ã®æ‰‹æœ­ï¼†å ´ -->
<div id="handBar" class="handbar"></div>
<div id="playMine" class="play-mine-fixed"></div>

<!-- å·¦ä¸Šï¼šãƒ‡ã‚£ã‚·ã‚¸ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰ -->
<div id="victoryArea" class="victoryArea hidden">
  <div class="title">ãƒ‡ã‚£ã‚·ã‚¸ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰</div>
  <div id="decisionCardBox"></div>
</div>

<!-- å³å´ï¼šãƒ€ãƒ–ãƒ«ã‚¹ã‚­ãƒ£ãƒ³ãƒãƒƒãƒ— -->
<div id="doubleScanArea" class="victoryArea hidden">
  <div class="doubleScan">
    <div class="label">ãƒ€ãƒ–ãƒ«ã‚¹ã‚­ãƒ£ãƒ³</div>
    <div class="circles">
      <span></span><span></span><span></span><span></span><span></span>
    </div>
  </div>
  <div class="cardbox blank-card"></div>
</div>

<!-- å³ä¸‹ï¼šæ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰ -->
<div id="nextPanel" class="nextPanel hidden">
  <button id="btnNextRound" class="nextBtn" title="æ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰">æ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰</button>
</div>

<!-- å³ä¸‹ï¼šè¨­å®š -->
<button id="fabOpenSeat" class="fab" title="è¨­å®š / åº§å¸­é¸æŠ" aria-label="è¨­å®š">âš™ï¸</button>
<!-- å·¦ä¸‹ï¼šæ¨ã¦æœ­ -->
<button id="btnOpenTrash" class="trashBtn" title="ãƒˆãƒ©ãƒƒã‚·ãƒ¥" aria-label="æ¨ã¦æœ­">ğŸ—‘ï¸</button>

<!-- åº§å¸­ã‚·ãƒ¼ãƒˆ -->
<div id="seatSheet" class="hidden" style="position:fixed;inset:0;z-index:80;display:flex;flex-direction:column;justify-content:flex-end;">
  <div id="sheetBackdrop" style="position:absolute;inset:0;background:rgba(0,0,0,.24);"></div>
  <div class="panel" role="dialog" aria-modal="true" style="position:relative;background:rgba(255,255,255,.98);border-top-left-radius:16px;border-top-right-radius:16px;border-top:1px solid #eee;box-shadow:0 -10px 30px rgba(0,0,0,.12);padding:10px 12px;width:min(420px, calc(100vw - 32px));margin:0 auto;">
    <div class="row head" style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
      <div class="title" id="sheetTitle" style="font-weight:700">åº§å¸­é¸æŠ</div>
      <button id="sheetClose" class="btn ghost" style="padding:6px 10px;">é–‰ã˜ã‚‹</button>
    </div>
    <div class="row" id="rowTop" style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:center;margin:8px 0;"></div>
    <div class="row" id="rowSeats" style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:center;margin:8px 0;"></div>
  </div>
</div>

<!-- æ¨ã¦æœ­ã‚·ãƒ¼ãƒˆ -->
<div id="trashSheet" class="hidden" style="position:fixed;inset:0;z-index:85;display:flex;align-items:center;justify-content:center;">
  <div id="trashBackdrop" style="position:absolute;inset:0;background:rgba(0,0,0,.24);"></div>
  <div class="trash-panel" role="dialog" aria-modal="true" 
       style="max-height:80vh;overflow-y:auto;">

    <div class="row head" style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
      <div class="title" style="font-weight:700">æ¨ã¦æœ­ä¸€è¦§</div>
      <button id="trashClose" class="btn ghost" style="padding:6px 10px;">é–‰ã˜ã‚‹</button>
    </div>
    <div id="trashBody" class="trash-grid"></div>
  </div>
</div>


<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import { getDatabase, ref, set, onDisconnect, onValue, runTransaction, remove, update } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyARne6Jb4ePP7vbvLryE_P-jZ2umI3LFc",
    authDomain: "kakapo-8d297.firebaseapp.com",
    databaseURL: "https://kakapo-8d297-default-rtdb.firebaseio.com",
    projectId: "kakapo-8d297",
    storageBucket: "kakapo-8d297.firebasestorage.app",
    messagingSenderId: "702767130857",
    appId: "1:702767130857:web:54472c8d5ea09bd3cf6878",
    measurementId: "G-NXSRP1T826"
  };

  const app = initializeApp(firebaseConfig);
  const db  = getDatabase(app);

  // ==== DOM ====
  const headerInfo = document.getElementById('headerInfo');
  const joinPanel  = document.getElementById('joinPanel');
  const afterPanel = document.getElementById('afterPanel');
  const nameInput  = document.getElementById('nameInput');
  const codeInput  = document.getElementById('codeInput');
  const btnJoin    = document.getElementById('btnJoin');

  const handBar  = document.getElementById('handBar');
  const oppA     = document.getElementById('oppA');
  const oppB     = document.getElementById('oppB');
  const oppC     = document.getElementById('oppC');

  const playMine = document.getElementById('playMine');
  const playA    = document.getElementById('playA');
  const playB    = document.getElementById('playB');
  const playC    = document.getElementById('playC');

  const victoryArea     = document.getElementById('victoryArea');
  const decisionCardBox = document.getElementById('decisionCardBox');
  const nextPanel       = document.getElementById('nextPanel');
  const btnNextRound    = document.getElementById('btnNextRound');

  // ä¸­å¤®ãƒ¬ã‚¤ãƒ¤
  const centerGrid  = document.getElementById('centerGrid');   // èƒŒæ™¯ã®12x12ç½«ç·š
  const centerPiece = document.getElementById('centerPiece');  // å‹è€…ãƒ”ãƒ¼ã‚¹ã®12x12ï¼ˆåŒæœŸãƒ‰ãƒ©ãƒƒã‚°ï¼‰

  // ãƒœãƒˆãƒ ã‚·ãƒ¼ãƒˆ
  const seatSheet   = document.getElementById('seatSheet');
  const rowTop      = document.getElementById('rowTop');
  const rowSeats    = document.getElementById('rowSeats');
  const sheetTitle  = document.getElementById('sheetTitle');
  const sheetClose  = document.getElementById('sheetClose');
  const sheetBackdrop = document.getElementById('sheetBackdrop');
  const fabOpenSeat = document.getElementById('fabOpenSeat');
// æ¨ã¦æœ­UI
const btnOpenTrash  = document.getElementById('btnOpenTrash');
const trashSheet    = document.getElementById('trashSheet');
const trashBackdrop = document.getElementById('trashBackdrop');
const trashClose    = document.getElementById('trashClose');
const trashBody     = document.getElementById('trashBody');
// â˜… ã‚´ãƒŸç®±UIã®é–‹é–‰ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ã§å¸¸æ™‚æœ‰åŠ¹ã«ã—ã¦ãŠãï¼ˆå…¥å®¤å‰ã§ã‚‚é–‹ãï¼‰
btnOpenTrash?.addEventListener('click', () => {
  show(trashSheet, true);
  renderTrash();
});
trashBackdrop?.addEventListener('click', () => show(trashSheet, false));
trashClose?.addEventListener('click', () => show(trashSheet, false));
  // ==== 40æšã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ï¼ˆè‰²Ã—8ã€ç´«ã¯0~8 â€»0ã¯ãƒ”ãƒ¼ã‚¹ãªã—è¡¨ç¾ï¼‰ ====
  const CARD_DATA = {
    red:   {1:'A1',2:'A1,B1',3:'A1,B1,C1',4:'A1,B1,C1,C2',5:'A1,B1,C1,C2,D1',6:'A1,A2,B2,C2,C3,D2',7:'A1,A2,B1,C1,C2,D1,E1',8:'A1,A2,B2,C2,D2,E2,E3,F2'},
    blue:  {1:'A1',2:'A1,B1',3:'A1,B1,C1',4:'A1,A2,B1,B2',5:'A1,A2,B1,B2,C1',6:'A1,A2,A3,B1,B2,C2',7:'A1,A2,B1,B2,C1,C2,D1',8:'A1,A2,B1,B2,B3,C2,C3,D3'},
    green: {1:'A1',2:'A1,B1',3:'A1,B1,C1',4:'A1,B1,B2,C1',5:'A2,A3,B2,C1,C2',6:'A3,B1,B2,B3,C1,C3',7:'A1,A2,A3,A4,B1,C1,D1',8:'A1,A2,B1,C1,C2,C3,C4,D4'},
    yellow:{1:'A1',2:'A1,B1',3:'A1,B1,C1',4:'A1,B1,B2,C2',5:'A2,B1,B2,B3,C2',6:'A1,A3,B1,B2,B3,C2',7:'A1,A2,A3,B2,C1,C2,C3',8:'A1,A2,A3,B2,C2,D1,D2,D3'},
    purple:{0:'',  1:'A1,B1',2:'A1,B1',3:'A1,A2,B2',4:'A1,A2,B2',5:'A1,A2,B1,B2',6:'A1,A2,B1,B2',7:'A1,B1,C1,D1,E1,F1',8:'A1,B1,C1,D1,E1,F1,G1'}
  };
  const COLOR_ORDER = ['red','blue','green','yellow','purple'];

  // ==== çŠ¶æ…‹ ====
  const state = {
    uid: crypto.randomUUID(),
    name: "",
    code: "",
    joined: false,
    mySeat: null,      // 1..4
    playersN: null,    // 1..4
    hostUid: null,
    seats: {},         // { "1": {uid,name}, ... }
    hands: {},         // { "1":[cardId,...], ... }
    plays: {},         // { uid: {cardId,color,index,seat,round,ts} }
    game: {},          // ãƒ©ã‚¦ãƒ³ãƒ‰é€²è¡Œã®ãƒ¡ã‚¿
    centerPieces: {},  // { [round]: { [pieceId]: PieceObj } }
    dragging: { id: null, round: null, raf: 0, offPx: {x:0,y:0}, ownLock: false },
  trash: {},   // { [cardId]: true } æ¨ã¦æœ­ç´¯ç©ãƒ•ãƒ©ã‚°
    used:  {},   // â˜… ãƒ—ãƒ¬ã‚¤æ¸ˆã¿ç´¯ç©ãƒ•ãƒ©ã‚°ï¼ˆå‹è€…å«ã‚€ï¼‰

  };

  // ==== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ====
  function randomLetter(){ return String.fromCharCode(65 + Math.floor(Math.random()*26)); }
  function random4(){ return String(Math.floor(Math.random()*10000)).padStart(4, '0'); }
  const NAME_RE = /^[A-Za-z\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FFF]$/;
  function normalizeName(raw){ const t = (raw || "").trim(); if (!t) return randomLetter(); const c = t[0]; return NAME_RE.test(c) ? c : randomLetter(); }
  function show(el, yes){ el.classList.toggle('hidden', !yes); }
  function parseCardId(id){ const [c, n] = String(id).split('-'); return { color:c, index:Number(n)||0 }; }

// è¿½åŠ ï¼šæ‰‹æœ­ã‚’ã€Œè‰²é †â†’æ•°å­—æ˜‡é †ã€ã§ä¸¦ã¹æ›¿ãˆã‚‹
  function sortHandByColorIndex(ids){
    const order = (COLOR_ORDER || ['red','blue','green','yellow','purple']);
    const rank = c => {
      const i = order.indexOf(c);
      return i >= 0 ? i : 999;
    };
    return (ids||[]).slice().sort((a,b)=>{
      const pa = parseCardId(a), pb = parseCardId(b);
      const byColor = rank(pa.color) - rank(pb.color);
      if (byColor !== 0) return byColor;
      return pa.index - pb.index;
    });
  }

  function buildDeck40(){
    const deck = [];
    for(const color of ['red','blue','green','yellow','purple']){
      for(let i=1;i<=8;i++) deck.push({ id:`${color}-${i}`, color, index:i });
    }
    return deck;
  }
  function shuffleInPlace(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
  function makeDealtByRoundRobin(N, deck){ const out={ '1':[], '2':[], '3':[], '4':[] }; deck.forEach((card,idx)=>{ const seat=((idx)%N)+1; out[String(seat)].push(card.id); }); return out; }
  function seatUid(seatNum){ return state.seats?.[String(seatNum)]?.uid || null; }

  function orderSeatsFrom(startSeat, N){
    const arr=[]; for (let k=0; k<N; k++){ const seat = (((startSeat - 1 - k) % N) + N) % N + 1; arr.push(seat); } return arr;
  }
  function getSeatOfUid(uid){ for (const [k,v] of Object.entries(state.seats||{})){ if (v?.uid===uid) return Number(k); } return null; }

function updateHeader(){
  headerInfo.innerHTML = '';

  // éƒ¨å±‹ç•ªå·ã®ã¿
  const spanRoom = document.createElement('span');
  spanRoom.textContent = state.code || '-';

  // COPYãƒœã‚¿ãƒ³
  const btn = document.createElement('button');
  btn.className = 'copybtn';
  btn.textContent = 'COPY';
  btn.onclick = ()=>{
    const url = new URL(location.href);
    url.searchParams.set('room', state.code);
    url.searchParams.set('name', state.name);
    navigator.clipboard.writeText(url.toString());
    btn.textContent = 'COPIED';
    setTimeout(()=> btn.textContent='COPY', 1200);
  };

  // åå‰ã®ã¿
  const spanMe = document.createElement('span');
  spanMe.textContent = state.name || '-';

  // é †ç•ªã«è¿½åŠ ï¼šéƒ¨å±‹ç•ªå· â†’ COPY â†’ åå‰
  headerInfo.appendChild(spanRoom);
  headerInfo.appendChild(btn);
  headerInfo.appendChild(spanMe);
}


  // === ã‚«ãƒ¼ãƒ‰é¢ Element ===
  function makeCardFaceEl(cardId){
    const {color, index} = parseCardId(cardId);
    const host = document.createElement('div'); host.className = `cardbox`;
    // purple-0 ã ã‘ã¯æ•°å­—ã‚’è¡¨ç¤ºã—ãªã„
    const isPurpleZero = (color === 'purple' && index === 0);
    const face = document.createElement('div');
    face.className = `face ${color}${isPurpleZero ? ' zero' : ''}`;
    host.appendChild(face);
    if (!isPurpleZero){
      const tl = document.createElement('div'); tl.className='num tl'; tl.textContent = String(index); face.appendChild(tl);
      const tr = document.createElement('div'); tr.className='num tr'; tr.textContent = String(index); face.appendChild(tr);
      const bl = document.createElement('div'); bl.className='num bl'; bl.textContent = String(index); face.appendChild(bl);
      const br = document.createElement('div'); br.className='num br'; br.textContent = String(index); face.appendChild(br);
    }
    const oval = document.createElement('div'); oval.className='ovalBG'; face.appendChild(oval);
    // shape gridï¼ˆã‚«ãƒ¼ãƒ‰ã®ä¸­ã®è¡¨ç¤ºï¼‰
    const def = (CARD_DATA[color]||{})[index] || '';
    const tokens = (def.match(/[A-Z]\d+/gi)||[]).map(s=>s.toUpperCase());
    const toRC = t => ({ r: t.charCodeAt(0)-65, c: Number(t.slice(1))-1 });
    const cells = tokens.map(toRC);
    if (tokens.length){
      const minR = Math.min(...cells.map(p=>p.r));
      const minC = Math.min(...cells.map(p=>p.c));
      const rel  = cells.map(p=>({ r:p.r-minR, c:p.c-minC }));
      const rows = Math.max(...rel.map(p=>p.r))+1; const cols = Math.max(...rel.map(p=>p.c))+1;
      const grid = document.createElement('div'); grid.className='grid'; grid.style.setProperty('--rows', rows); grid.style.setProperty('--cols', cols);
      for (let i=0;i<rows*cols;i++){ const d=document.createElement('div'); d.className='cell'; grid.appendChild(d); }
      rel.forEach(({r,c})=>{ grid.children[r*cols+c].classList.add('filled'); });
      face.appendChild(grid);
    }
    return host;
  }

  // === å…¥å®¤ ===
  async function join(){
    const name = normalizeName(nameInput.value);
    const code = (codeInput.value || "").trim() || random4();
    state.name = name; state.code = code;

    const meRef = ref(db, `rooms/${code}/participants/${state.uid}`);
    await set(meRef, { name, at: Date.now() });
    onDisconnect(meRef).remove();

    await runTransaction(ref(db, `rooms/${code}/settings/hostUid`), cur => cur || state.uid, { applyLocally:false });

    updateHeader(); show(joinPanel, false); show(afterPanel, true); state.joined = true;

    wireRoom(); openSeatSheet();
    document.getElementById('doubleScanArea').classList.remove('hidden');
  }
  btnJoin.onclick = join;

  // äº‹å‰å…¥åŠ›
  try{
    const qs = new URLSearchParams(location.search);
    const qRoom = (qs.get('room')||'').trim(); const qName = (qs.get('name')||'').trim();
    if (qRoom) codeInput.value = qRoom.slice(0, 12);
    if (qName) nameInput.value = qName.slice(0, 1);
  }catch(_e){}

  // === ãƒ«ãƒ¼ãƒ è³¼èª­ ===
  function wireRoom(){
    const room = `rooms/${state.code}`;

    onValue(ref(db, `${room}/settings`), snap=>{
      const st = snap.val() || {}; state.hostUid = st.hostUid || null; state.playersN = st.players || null;
      const hostBar = document.getElementById('hostBar');
      const btn1 = document.getElementById('btn1p'); const btn2 = document.getElementById('btn2p'); const btn3 = document.getElementById('btn3p'); const btn4 = document.getElementById('btn4p'); const btnHost = document.getElementById('btnBecomeHost'); const hostInfo = document.getElementById('hostInfo');
      if (hostBar){ hostBar.style.display = 'block'; }
      if (btnHost){ btnHost.onclick = async()=>{ await set(ref(db, `${room}/settings/hostUid`), state.uid); }; }
      if (btn1){ btn1.onclick = async ()=>{ await setPlayersAndDeal(1); }; }
      if (btn2){ btn2.onclick = async ()=>{ await setPlayersAndDeal(2); }; }
      if (btn3){ btn3.onclick = async ()=>{ await setPlayersAndDeal(3); }; }
      if (btn4){ btn4.onclick = async ()=>{ await setPlayersAndDeal(4); }; }
      if (hostInfo){ hostInfo.textContent = `ãƒ›ã‚¹ãƒˆï¼š${st.hostUid ? (st.hostUid===state.uid?'ã‚ãªãŸ':st.hostUid.slice(0,4)) : 'æœªè¨­å®š'}`; }
      if (!seatSheet.classList.contains('hidden')) renderSeatSheet();
      updateHeader(); renderAll();
    });

    onValue(ref(db, `${room}/hands`), snap=>{ state.hands = snap.val() || {}; renderAll(); });

    onValue(ref(db, `${room}/seats`), snap=>{
      state.seats = snap.val() || {}; state.mySeat = null; for (const k of Object.keys(state.seats)){ if (state.seats[k]?.uid === state.uid){ state.mySeat = Number(k); break; } }
      if (!seatSheet.classList.contains('hidden')) renderSeatSheet();
      renderAll();
    });

// å¤‰æ›´å¾Œ
onValue(ref(db, `${room}/plays`), snap=>{
  state.plays = snap.val() || {};
  renderPlays();
  // å…ˆã«å‹è€…ã‚’ç¢ºå®š
  maybeComputeVictory().finally(()=>{
    // å‹è€…ãŒ state.game ã«åæ˜ ã•ã‚ŒãŸå¾Œã«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’å†æç”»
    renderDoubleScanPreview();
  });
});

    onValue(ref(db, `${room}/game`), snap=>{
      state.game = snap.val() || {};
      updateHeader(); renderAll();

      // â˜… ã“ã“ã‹ã‚‰è¿½åŠ ï¼šãƒ€ãƒ–ãƒ«ã‚¹ã‚­ãƒ£ãƒ³ã®ãƒˆãƒ¼ã‚¯ãƒ³æç”»æ›´æ–°
      const used = state.game.doubleScanUsed || 0;
      const circles = document.querySelectorAll('#doubleScanArea .circles span');
      circles.forEach((c,i)=>{
        if (i < used){
          c.classList.add('used');
          c.style.background = '#ccc';
        }else{
          c.classList.remove('used');
          c.style.background = '#000';
        }
      });
      // â˜… è¿½åŠ ã“ã“ã¾ã§

      // ãƒ©ã‚¦ãƒ³ãƒ‰ã«ã²ã‚‚ã¥ãä¸­å¤®ãƒ”ãƒ¼ã‚¹è³¼èª­
      wireCenterPiecesListener();
    });


    // å…¨ãƒ©ã‚¦ãƒ³ãƒ‰é…ä¸‹ã‚’è³¼èª­ï¼ˆãƒ©ã‚¦ãƒ³ãƒ‰å¤‰ã‚ã£ã¦ã‚‚å³åæ˜ ï¼‰
    onValue(ref(db, `${room}/centerPieces`), snap=>{
      state.centerPieces = snap.val() || {};
      renderCenterPieces();
    });

// æ¨ã¦æœ­è³¼èª­
onValue(ref(db, `${room}/trash`), snap=>{
  state.trash = snap.val() || {};
  if (!trashSheet.classList.contains('hidden')) renderTrash();
});
// â˜… ä½¿ç”¨æ¸ˆã¿è³¼èª­
onValue(ref(db, `${room}/used`), snap=>{
  state.used = snap.val() || {};
  if (!trashSheet.classList.contains('hidden')) renderTrash();
});
// ã‚´ãƒŸç®±UIã®é–‹é–‰
btnOpenTrash?.addEventListener('click', ()=>{ show(trashSheet, true); renderTrash(); });
trashBackdrop?.addEventListener('click', ()=> show(trashSheet, false));
trashClose?.addEventListener('click', ()=> show(trashSheet, false));


    btnNextRound?.addEventListener('click', onNextRound);
  }



  // === äººæ•°è¨­å®šï¼†é…å¸ƒ ===
  async function setPlayersAndDeal(N){
    const room=`rooms/${state.code}`;
    let deck = buildDeck40();
    if (N <= 3) { deck = deck.filter(c => c.id !== 'purple-1'); }
    deck = shuffleInPlace(deck);
    const hands = makeDealtByRoundRobin(N, deck);

    // è¿½åŠ ï¼šé…å¸ƒå¾Œã«è‰²é †â†’æ•°å­—æ˜‡é †ã§ä¸¦ã¹æ›¿ãˆ
    for (let seat = 1; seat <= N; seat++){
      const key = String(seat);
      if (hands[key]) {
        hands[key] = sortHandByColorIndex(hands[key]);
      }
    }

    const startSeat = detectStartSeatFromHands(N, hands);
    const orderSeatsArr = orderSeatsFrom(startSeat, N);
    const startUid = seatUid(startSeat);

    const initGame = {
      round: 1,
      playersN: N,
      startSeat,
      orderSeats: orderSeatsArr,
      startUid: startUid || null,
      turnUid: startUid || null,
      startColor: null,
      victory: null,
      decision: { cardId: (N === 4 ? 'purple-0' : 'purple-1'), color: 'purple', index: (N === 4 ? 0 : 1) }
    };

    await update(ref(db), {
      [`${room}/settings/players`]: N,
      [`${room}/hands`]: hands,
      [`${room}/plays`]: null,
      [`${room}/game`]: initGame,
      [`${room}/centerPieces`]: null,
 [`${room}/trash`]: {} ,
  [`${room}/used`]:  {},     // â˜… è¿½åŠ 

    });
  }
  function detectStartSeatFromHands(N, hands){
    const target = 'purple-8'; for (let i=1; i<=N; i++){ if ((hands[String(i)]||[]).includes(target)) return i; } return 1;
  }

  // === åº§å¸­UI ===
  function openSeatSheet(){ show(seatSheet, true); renderSeatSheet(); }
  function closeSeatSheet(){ show(seatSheet, false); }
  sheetClose.addEventListener('click', closeSeatSheet);
  sheetBackdrop.addEventListener('click', closeSeatSheet);
  fabOpenSeat.addEventListener('click', openSeatSheet);

  function renderSeatSheet(){
    const isHost = state.hostUid === state.uid; sheetTitle.textContent = isHost ? 'è¨­å®šã¨ç€å¸­ï¼ˆãƒ›ã‚¹ãƒˆï¼‰' : 'ç€å¸­ï¼ˆã‚²ã‚¹ãƒˆï¼‰';
    rowTop.innerHTML = '';
    if (isHost){
      const seg = document.createElement('div'); seg.style.display='flex'; seg.style.gap='8px';
      const mk = (n)=>{ const b=document.createElement('button'); b.className='btn ghost'; b.textContent=`${n}äºº`; b.onclick= async()=>{ await setPlayersAndDeal(n); }; return b; };
      seg.appendChild(mk(1)); seg.appendChild(mk(2)); seg.appendChild(mk(3)); seg.appendChild(mk(4));
      const cap = document.createElement('div'); cap.className='muted'; cap.textContent='äººæ•°ã‚’é¸ã‚“ã æ™‚ç‚¹ã§40æšã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«é…å¸ƒã—ã¾ã™ã€‚æ¬¡ã«åº§å¸­ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚';
      rowTop.appendChild(seg); rowTop.appendChild(cap);
    }else{
      const cap = document.createElement('div'); cap.className='muted'; cap.textContent = state.playersN ? `ç¾åœ¨ ${state.playersN} äººãƒ—ãƒ¬ã‚¤` : 'ãƒ›ã‚¹ãƒˆãŒäººæ•°ã‚’è¨­å®šä¸­â€¦'; rowTop.appendChild(cap);
    }

    rowSeats.innerHTML = '';
    const N = state.playersN || 4;
    for (let i=1; i<=4; i++){
      const taken = !!state.seats[i];
      const mine  = state.seats[i]?.uid === state.uid;
      const invalidByPlayers = (!N) || (N===3 && i===4) || (N===2 && i>2) || (N===1 && i>1);

      const btn = document.createElement('button');
      btn.className = 'btn ghost'; btn.style.minWidth='76px';
      btn.textContent = mine ? `å¸­${i}ï¼ˆã‚ãªãŸï¼‰` : taken ? `å¸­${i}ï¼ˆä½¿ç”¨ä¸­ï¼‰` : `å¸­${i}`;
      btn.disabled = (!mine && (taken || invalidByPlayers));
      btn.onclick = async ()=>{ if (mine){ await releaseMySeat(); } else { const ok = await claimSeat(i); if (ok){ await maybeFillStartFromSeat(); closeSeatSheet(); } } };
      rowSeats.appendChild(btn);
    }
  }
  async function claimSeat(n){
    const seatRef = ref(db, `rooms/${state.code}/seats/${n}`);
    try{
      const res = await runTransaction(seatRef, cur=>{ if (!cur || cur.uid === state.uid){ return { uid: state.uid, name: state.name, at: Date.now() }; } return cur; }, {applyLocally:false});
      if (!res.committed || res.snapshot.val()?.uid !== state.uid){ alert(`å¸­${n} ã¯ä½¿ç”¨ä¸­ã§ã™ã€‚`); return false; }
      onDisconnect(seatRef).remove();
      await syncTurnOwnershipOnSeatChange(n);
      return true;
    }catch(e){ console.error(e); alert('ç€å¸­ã«å¤±æ•—ã—ã¾ã—ãŸã€‚'); return false; }
  }
  async function releaseMySeat(){ if (!state.mySeat) return; const room = `rooms/${state.code}`; try{ await remove(ref(db, `${room}/seats/${state.mySeat}`)); }catch(_e){} }
  async function maybeFillStartFromSeat(){ const room = `rooms/${state.code}`; const g = state.game || {}; if (!g.playersN || !g.startSeat) return; const uid = seatUid(g.startSeat); if (uid && (!g.startUid || !g.turnUid)){ await update(ref(db, `${room}/game`), { startUid: uid, turnUid: uid }); } }
  async function syncTurnOwnershipOnSeatChange(n){
    const room = `rooms/${state.code}`; const g = state.game || {}; const updates = {};
    if (g.startSeat && g.startSeat === n && g.startUid !== state.uid){ updates[`${room}/game/startUid`] = state.uid; }
    const N = g.playersN || state.playersN || 0;
    if (N && Array.isArray(g.orderSeats) && g.orderSeats.length === N){
      const playsNow = Object.values(state.plays || {}).filter(p => Number(p?.round) === (g.round||1)).length;
      const expectedSeat = g.orderSeats[playsNow % N];
      if (expectedSeat === n){ updates[`${room}/game/turnUid`] = state.uid; }
    } else {
      const turnSeat = (g.turnUid && (Object.entries(state.seats||{}).find(([k,v])=>v?.uid===g.turnUid)?.[0] | 0)) || 0;
      if (!g.turnUid || !turnSeat){ updates[`${room}/game/turnUid`] = state.uid; }
    }
    if (Object.keys(updates).length){ await update(ref(db), updates); }
  }

  // === ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° ===
  function renderAll(){ renderDecisionCard(); renderHands(); renderOpponents(); renderPlays();
  if (!trashSheet.classList.contains('hidden')) renderTrash();
 }
function renderTrash(){
  if (!trashBody) return;

  // â˜… å¤‰æ›´ï¼šç´¯ç© used ã¨ã€ä»Šãƒ©ã‚¦ãƒ³ãƒ‰ã® plays ã‚’åˆç®—ã—ã¦ã€Œæ¿ƒãè¡¨ç¤ºã€å¯¾è±¡ã«ã™ã‚‹
  const used = new Set([
    ...Object.keys(state.used || {}),
    ...Object.values(state.plays || {}).map(p => p.cardId)
  ]);

  // è‰²ã”ã¨ã« 1..8 ã‚’æ¨ªä¸¦ã³ï¼ˆpurple-0 ã¯ä¸€è¦§ã‹ã‚‰é™¤å¤–ï¼‰
  const colors = ['red','blue','green','yellow','purple'];
  trashBody.innerHTML = '';
  for (const color of colors){
    const row = document.createElement('div'); row.className = 'trash-row';
    const lab = document.createElement('div'); lab.className = 'label'; lab.textContent = color;
    row.appendChild(lab);

    const maxIndex = 8; // purple ã‚‚ 1..8 ã‚’è¡¨ç¤ºï¼ˆ0 ã¯é™¤å¤–ï¼‰
    for (let i=1;i<=maxIndex;i++){
      const id = `${color}-${i}`;
      const el = makeCardFaceEl(id);
      if (!used.has(id)){ el.classList.add('dim'); } // éãƒ—ãƒ¬ã‚¤ï¼ˆæœªä½¿ç”¨ï¼‰ã¯è–„ã
      row.appendChild(el);
    }
    trashBody.appendChild(row);
  }
}


  function renderDecisionCard(){
    const g = state.game || {}; const dec = g.decision; if (!dec) return;
    decisionCardBox.innerHTML = ''; decisionCardBox.appendChild(makeCardFaceEl(dec.cardId));
    show(victoryArea, true);
  }

  function myHand(){ if (!state.mySeat) return []; return state.hands?.[String(state.mySeat)] || []; }

 function renderHands(){
  handBar.innerHTML = '';
  handBar.classList.remove('two-lines');

  const g = state.game || {};
  const my = myHand();
  const isMyTurn = (g.turnUid === state.uid);
  const leadColor = g.startColor || null;
  const haveLead = !!my.find(id => parseCardId(id).color === leadColor);
  const isMobile = window.matchMedia('(max-width: 600px)').matches;

  // ã‚«ãƒ¼ãƒ‰è¦ç´ ç”Ÿæˆï¼ˆæ—¢å­˜ã®å‡ºã›ã‚‹/å‡ºã›ãªã„åˆ¤å®šã‚’è¸è¥²ï¼‰
  const make = (id) => {
    const card = makeCardFaceEl(id);
    if (isMyTurn){
      const { color } = parseCardId(id);
      const playable = (!leadColor) || (haveLead ? color === leadColor : true);
      if (playable){
        card.classList.add('clickable','pulsate');
        card.onclick = ()=> playMyCard(id);
      }else{
        card.classList.add('unplayable');
      }
    }else{
      card.classList.add('unplayable');
    }
    return card;
  };

  if (isMobile){
    // 8æšä»¥ä¸Šãªã‚‰ä¸Šä¸‹ã«å‰²ã‚ŠæŒ¯ã‚Šã€7æšä»¥ä¸‹ã¯1æ®µ
    const n = my.length;
    const topN    = (n >= 8) ? Math.ceil(n/2) : n;   // 10â†’5, 9â†’5, 8â†’4, 7â†’7, â€¦
    const bottomN = (n >= 8) ? Math.floor(n/2) : 0;  // 10â†’5, 9â†’4, 8â†’4, 7â†’0, â€¦

    const rowTop = document.createElement('div');    rowTop.className = 'handrow top';
    const rowBot = document.createElement('div');    rowBot.className = 'handrow bottom';

    for (let i=0; i<topN; i++) rowTop.appendChild(make(my[i]));
    if (bottomN > 0){
      for (let i=topN; i<topN+bottomN; i++) rowBot.appendChild(make(my[i]));
      handBar.classList.add('two-lines');
    }

    handBar.appendChild(rowTop);
    if (bottomN > 0) handBar.appendChild(rowBot);

  }else{
    // PCã¯å¾“æ¥ã©ãŠã‚Š1æ®µ
    my.forEach(id => handBar.appendChild(make(id)));
  }
}

// ç”»é¢ã‚µã‚¤ã‚ºå¤‰åŒ–ã«ã‚‚è¿½å¾“
window.addEventListener('resize', renderHands);


  function renderOpponents(){
    const maps = computeABCPositions();
    const places = [ ['A',oppA], ['B',oppB], ['C',oppC] ];
    places.forEach(([k,el])=>{
      const info = maps[k];
      if (!info){ show(el,false); return; }
      show(el,true);
      const seatHand = state.hands?.[String(info.seat)] || [];
      const fan = el.querySelector('.fan'); fan.innerHTML='';
      const n = seatHand.length;
      const spread = Math.min(140, n * 18);
      for (let i=0; i<n; i++){
        const deg = -spread/2 + (spread/(n-1)) * i;
        const d = document.createElement('div');
        d.className = 'card opp';
        d.style.transform = `rotate(${deg}deg)`;
        d.style.transformOrigin = '50% 100%';
        fan.appendChild(d);
      }
      const badge = el.querySelector('.badge'); badge.textContent = info.name || `å¸­${info.seat}`;
    });
  }

  function clockwiseOthers(){
    if (!state.mySeat) return [];
    const N = state.game?.playersN || state.playersN || 4;
    const cwOffset = (s)=> ((s.seat - state.mySeat + N) % N);
    return Object.entries(state.seats)
      .filter(([k,v])=>v && v.uid)
      .map(([k,v])=>({ seat:Number(k), uid:v.uid, name:v.name||'?' }))
      .filter(s => s.seat !== state.mySeat)
      .sort((a,b) => cwOffset(a) - cwOffset(b));
  }
  function computeABCPositions(){
    const arr = clockwiseOthers(); const N = state.game?.playersN || state.playersN || 4; const map = {};
    if (arr[0]) map.B = arr[0];
    if (N === 3){ if (arr[1]) map.A = arr[1]; } else { if (arr[1]) map.C = arr[1]; if (arr[2]) map.A = arr[2]; }
    return map;
  }
  function seatToABC(seat){
    if (!state.mySeat) return null; const N = state.game?.playersN || state.playersN || 4;
    const arr = clockwiseOthers();
    if (N===3){ if (arr[1]?.seat===seat) return 'A'; if (arr[0]?.seat===seat) return 'B'; }
    else { if (arr[2]?.seat===seat) return 'A'; if (arr[0]?.seat===seat) return 'B'; if (arr[1]?.seat===seat) return 'C'; }
    return null;
  }

function renderPlays(){
  // ã¾ãšå ´ã‚’ã‚¯ãƒªã‚¢
  playMine.innerHTML = '';
  playA.innerHTML = '';
  playB.innerHTML = '';
  playC.innerHTML = '';

  const g = state.game || {};
  const r = g.round || 1;
  // â˜… å‹è€…ãƒ”ãƒ¼ã‚¹å‡ºç¾å¾Œã¯ã€ã“ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã®å ´æœ­ã‚’éè¡¨ç¤º
  if (Number(g.hiddenPlaysRound) === r) {
    return; // ä½•ã‚‚æã‹ãªã„
  }
  // ã“ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã®ãƒ—ãƒ¬ã‚¤ã ã‘ã‚’æŠ½å‡ºï¼ˆp.v ã‚’æ­£ã—ãå‚ç…§ï¼‰
  const playsArr = Object.entries(state.plays || {})
    .map(([uid, v]) => ({ uid, v }))
    .filter(p => Number(p.v?.round) === r);

  for (const p of playsArr){
    const { cardId, seat: seatMaybe } = p.v || {};
    if (!cardId) continue;

    const el = makeCardFaceEl(cardId);
    const seatNum = seatMaybe || getSeatOfUid(p.uid);
    const isMe = (p.uid === state.uid);

    // é…ç½®å…ˆã‚’æ±ºå®š
    let parent;
    if (isMe){
      parent = playMine;
    }else{
      const pos = seatToABC(seatNum);
      parent = (pos === 'A') ? playA : (pos === 'B') ? playB : playC;
    }
    parent.appendChild(el);

    // å‹è€…ã‚’å¼·èª¿ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§ã€Œæ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰ã€è¡¨ç¤ºï¼†ä¸­å¤®ãƒ”ãƒ¼ã‚¹ç”Ÿæˆï¼‰
    if (g.victory && Number(g.victory.round) === r && g.victory.uid === p.uid){
      const wrap = document.createElement('div');
      wrap.className = 'played winner';
      parent.replaceChild(wrap, el);
      wrap.appendChild(el);

      if (isMe){
        wrap.onclick = ()=>{
          show(nextPanel, true);
          spawnVictoryPieceOnce();   // å‹è€…ã®ã¿ã‚¯ãƒªãƒƒã‚¯å¯
        };
      }
    }
  }
}

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ãƒ•ãƒ©ã‚°ã‚’ç½®ãï¼ˆstate å®šç¾©ã®ä¸‹ã‚ãŸã‚Šã§å®£è¨€ã—ã¦ãŠãï¼‰
let doubleScanBusy = false;

// === ãƒ€ãƒ–ãƒ«ã‚¹ã‚­ãƒ£ãƒ³ï¼šå…¨å“¡åŒè‰²ãªã‚‰æœ€å°ç•ªå·ã‚«ãƒ¼ãƒ‰ã‚’ç‚¹ç·šæ ã«è¡¨ç¤º ===
function renderDoubleScanPreview(){
  const box = document.querySelector('#doubleScanArea .blank-card');
  if (!box) return;
  box.innerHTML = '';

  const g = state.game || {}; 
  const N = g.playersN || 0; 
  const r = g.round || 1;

  const playsArr = Object.entries(state.plays||{})
    .map(([uid,v])=>({uid,...v}))
    .filter(p=>Number(p.round)===r);

  if (!N || playsArr.length !== N) return;

  const colors = new Set(playsArr.map(p=>p.color));
  if (colors.size !== 1) return;

  const minPlay = playsArr.reduce((a,b)=> (a.index <= b.index ? a : b));
  const host = makeCardFaceEl(minPlay.cardId);
  box.appendChild(host);

// === ã‚¯ãƒªãƒƒã‚¯å‡¦ç† ===
// å‹è€…ã ã‘ãŒã‚¯ãƒªãƒƒã‚¯ã§ãã‚‹
if (g.victory && g.victory.uid === state.uid){
  host.classList.add("clickable");
  host.onclick = async ()=>{
    if (doubleScanBusy) return;
    doubleScanBusy = true;

    try {
      // ãƒ”ãƒ¼ã‚¹ã‚’ç”Ÿæˆï¼ˆspawnVictoryPieceOnceç›¸å½“ï¼‰
      const shape = buildRelFromCard(minPlay.cardId);
      if (shape.rel.length){
        const x0 = Math.max(0, Math.floor((12 - shape.w)/2));
        const y0 = Math.max(0, Math.floor((12 - shape.h)/2));
        const pid = minPlay.cardId.replace(/[^a-z0-9\-]/gi,'') + '-' + Date.now().toString(36);
        const obj = { id: pid, round: r, cardId: minPlay.cardId,
          color: minPlay.color, index: minPlay.index,
          rel: shape.rel, w: shape.w, h: shape.h,
          x: x0, y: y0, z: 1,
          lockBy: null, angle:0, flipX:false, flipY:false,
          updatedAt: Date.now()
        };
        await set(piecePath(r,pid), obj);
      }

      // â–¼ ãƒˆãƒ¼ã‚¯ãƒ³å…±æœ‰ï¼šDB ä¸Šã«æ®‹æ•°ã‚’æ›¸ãè¾¼ã‚€
      const room = `rooms/${state.code}`;
      const used = (g.doubleScanUsed || 0) + 1;
      await update(ref(db), {
        [`${room}/game/doubleScanUsed`]: used

      });

      // æ å†…ã®ã‚«ãƒ¼ãƒ‰ã‚’ãƒ–ãƒ©ãƒ³ã‚¯ã«æˆ»ã™
      // æ å†…ã®ã‚«ãƒ¼ãƒ‰ã‚’ãƒ–ãƒ©ãƒ³ã‚¯ã«æˆ»ã™
      box.innerHTML = '';

      // â–¼ åŒæœŸã§ãƒ—ãƒ¬ã‚¤æ¸ˆã¿ã‚«ãƒ¼ãƒ‰ã‚‚æ¶ˆã™ï¼ˆå…¨å“¡å…±æœ‰ï¼‰
      const playsCopy = {...(state.plays||{})};
      for (const uid of Object.keys(playsCopy)) {
        const p = playsCopy[uid];
        if (p && p.cardId === minPlay.cardId && Number(p.round) === r) {
          delete playsCopy[uid];
        }
      }
// ã¾ã¨ã‚ã¦ updateï¼šplays ã‚’æ›´æ–°ã—ã¤ã¤ã€trash/{cardId}=true ã‚’ç«‹ã¦ã‚‹
const updates2 = {};
updates2[`${room}/plays`] = playsCopy;
updates2[`${room}/trash/${minPlay.cardId}`] = true; // â˜…ã“ã‚ŒãŒãƒã‚¤ãƒ³ãƒˆ
updates2[`${room}/used/${minPlay.cardId}`]  = true; // â˜… è¿½åŠ 

await update(ref(db), updates2);    } finally {
      doubleScanBusy = false;
    }
  };
}

}


  // === ãƒ—ãƒ¬ã‚¤ ===
  async function playMyCard(cardId){
    const g = state.game || {}; const room = `rooms/${state.code}`; const r = g.round || 1;
    if (g.turnUid !== state.uid) return;
    const mySeat = state.mySeat; if (!mySeat) return;
    const myList = (state.hands?.[String(mySeat)]||[]).slice(); const idx = myList.indexOf(cardId); if (idx<0) return;
    const {color,index} = parseCardId(cardId);

    const updates = {};
    myList.splice(idx,1);
    updates[`${room}/hands/${mySeat}`] = myList;
    updates[`${room}/plays/${state.uid}`] = { cardId, color, index, seat: mySeat, round: r, ts: Date.now() };
    if (!g.startColor){ updates[`${room}/game/startColor`] = color; }

    const nextUid = computeNextTurnUidAfterMyPlay();
    updates[`${room}/game/turnUid`] = nextUid;
  updates[`${room}/used/${cardId}`] = true; // â˜… è¿½åŠ ï¼šãƒ—ãƒ¬ã‚¤ç›´å¾Œã«ãƒ—ãƒ¬ã‚¤æ¸ˆã¿ã¸

    await update(ref(db), updates);
  }
  function computeNextTurnUidAfterMyPlay(){
    const g = state.game || {}; const N = g.playersN || 1; const order = g.orderSeats || []; if (!N || !order.length) return state.uid;
    const r = g.round || 1; const playsNow = Object.values(state.plays || {}).filter(p => Number(p?.round) === r).length + 1;
    if (playsNow >= N){ return null; }
    const nextSeat = order[playsNow % N];
    return seatUid(nextSeat) || null;
  }

  // === å‹è€…åˆ¤å®š ===
// === å‹è€…åˆ¤å®šï¼ˆãƒˆãƒ©ãƒ³ãƒ—ï¼ãƒ‡ã‚£ã‚·ã‚¸ãƒ§ãƒ³è‰²ã€ãªã‘ã‚Œã°ãƒªãƒ¼ãƒ‰è‰²æœ€å¤§ï¼‰ ===
async function maybeComputeVictory(){
  const g = state.game || {};
  const room = `rooms/${state.code}`;
  const N = g.playersN || 0;
  const r = g.round || 1;
  if (!N) return;

  const playsArr = Object.entries(state.plays||{})
    .map(([uid,v])=>({uid,...v}))
    .filter(p=>Number(p.round)===r);
  if (playsArr.length !== N) return;
  if (g.victory && Number(g.victory.round)===r) return;

  const leadColor = g.startColor;
  const decisionColor = (g?.decision?.color) || 'purple'; // ãƒ‡ã‚£ã‚·ã‚¸ãƒ§ãƒ³ã®è‰²ã‚’ãƒˆãƒ©ãƒ³ãƒ—è‰²ã«

  const pickMax = (arr) => arr.slice().sort((a,b)=> b.index - a.index)[0];

  // 1) ãƒ‡ã‚£ã‚·ã‚¸ãƒ§ãƒ³è‰²ï¼ˆãƒˆãƒ©ãƒ³ãƒ—ï¼‰ãŒ1æšã§ã‚‚ã‚ã‚Œã°ã€ãã®ä¸­ã®æœ€å¤§ãŒå‹è€…
  const decPlays = playsArr.filter(p => p.color === decisionColor);
  let winner;
  if (decPlays.length){
    winner = pickMax(decPlays);
  } else {
    // 2) ãã†ã§ãªã‘ã‚Œã°ã€ãƒªãƒ¼ãƒ‰ã‚«ãƒ©ãƒ¼ã®ä¸­ã§æœ€å¤§
    const leadPlays = playsArr.filter(p => p.color === leadColor);
    // å…ˆæ‰‹ã®ã‚«ãƒ¼ãƒ‰ãŒå¿…ãšå«ã¾ã‚Œã‚‹æƒ³å®šã ãŒã€å®‰å…¨ã®ãŸã‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    winner = leadPlays.length ? pickMax(leadPlays) : pickMax(playsArr);
  }

  const vict = {
    cardId: winner.cardId, uid: winner.uid, color: winner.color, index: winner.index,
    round: r, seat: winner.seat, ts: Date.now()
  };
  await update(ref(db), { [`${room}/game/victory`]: vict });
}


  // === æ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰ ===
async function onNextRound(){
  const g = state.game || {}; const room = `rooms/${state.code}`; const vict = g.victory; if (!vict) return;

  const rNow = g.round || 1;

  // ã“ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã®ãƒ—ãƒ¬ã‚¤æ¸ˆã¿ã‹ã‚‰ã€Œå‹è€…ã‚«ãƒ¼ãƒ‰ä»¥å¤–ã€ã‚’æ¨ã¦æœ­ã¸
  const playsArr = Object.entries(state.plays||{})
    .map(([uid,v])=>({uid, ...v}))
    .filter(p => Number(p.round) === rNow);

  const toTrash = [];
  for (const p of playsArr){
    if (p.cardId !== vict.cardId){
      toTrash.push(p.cardId);
    }
  }

  // updates ã‚’ã¾ã¨ã‚ã¦ä¸€æ‹¬æ›´æ–°
  const updates = {};

  // æ¨ã¦æœ­ã®è¿½è¨˜ï¼ˆid: trueï¼‰
  for (const id of toTrash){
    updates[`${room}/trash/${id}`] = true;
  }

  // æ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰æº–å‚™
  const winnerSeat = vict.seat || getSeatOfUid(vict.uid) || g.startSeat;
  const startUid = seatUid(winnerSeat);
  const orderSeatsArr = orderSeatsFrom(winnerSeat, g.playersN);
  const rNext = rNow + 1;
  const nextDecision = { cardId: vict.cardId, color: vict.color, index: vict.index };

  updates[`${room}/plays`]              = null;
  updates[`${room}/game/round`]        = rNext;
  updates[`${room}/game/startSeat`]    = winnerSeat;
  updates[`${room}/game/orderSeats`]   = orderSeatsArr;
  updates[`${room}/game/startUid`]     = startUid || null;
  updates[`${room}/game/turnUid`]      = startUid || null;
  updates[`${room}/game/startColor`]   = null;
  updates[`${room}/game/victory`]      = null;
  updates[`${room}/game/decision`]     = nextDecision;

  await update(ref(db), updates);
  show(nextPanel, false);
}


  // =========================
  // ä¸­å¤®ãƒ”ãƒ¼ã‚¹å®Œå…¨ç‰ˆï¼ˆã‚»ãƒ«æ¯”ç‡ãƒ»åŒæœŸãƒ‰ãƒ©ãƒƒã‚°ï¼‰
  // =========================
  // DBãƒ‘ã‚¹: rooms/{room}/centerPieces/{round}/{pieceId}
  // PieceObj:
  //  {
  //    id, round, cardId, color, index,
  //    rel: [[r,c],...],    // å½¢çŠ¶ï¼ˆã‚«ãƒ¼ãƒ‰å®šç¾©ã®å¤–æ¥çŸ©å½¢åŸºæº–ï¼‰
  //    w, h,                // å½¢çŠ¶ã®åˆ—æ•°ãƒ»è¡Œæ•°
  //    x, y,                // å·¦ä¸Šã‚¢ãƒ³ã‚«ãƒ¼ï¼ˆ0..11ï¼‰ã‚»ãƒ«åº§æ¨™
  //    z,                   // å‰é¢åˆ¶å¾¡
  //    lockBy: uid|null,    // ãƒ‰ãƒ©ãƒƒã‚°ãƒ­ãƒƒã‚¯
  //    updatedAt
  //  }

  function currentRoom(){ return `rooms/${state.code}`; }
  function currentRound(){ return state.game?.round || 1; }
  function getCenterRect(){ return centerPiece.getBoundingClientRect(); }
  function cellSize(){ return getCenterRect().width / 12; }

  function buildRelFromCard(cardId){
    const {color,index} = parseCardId(cardId);
    const def = (CARD_DATA[color]||{})[index] || '';
    if (!def) return { color, index, rel: [], w:1, h:1 };
    const tokens = (def.match(/[A-Z]\d+/gi)||[]).map(s=>s.toUpperCase());
    const cells = tokens.map(t=>({ r:t.charCodeAt(0)-65, c:Number(t.slice(1))-1 }));
    const minR = Math.min(...cells.map(p=>p.r));
    const minC = Math.min(...cells.map(p=>p.c));
    const rel  = cells.map(p=>({ r:p.r-minR, c:p.c-minC }));
    const h = Math.max(...rel.map(p=>p.r))+1;
    const w = Math.max(...rel.map(p=>p.c))+1;
    return { color, index, rel: rel.map(p=>[p.r,p.c]), w, h };
  }

  function piecePath(round,pieceId){ return ref(db, `${currentRoom()}/centerPieces/${round}/${pieceId}`); }
  function roundPath(round){ return ref(db, `${currentRoom()}/centerPieces/${round}`); }

  function wireCenterPiecesListener(){
    // onValue ã‚’å…¨ä½“ã§å…¥ã‚Œã¦ã„ã‚‹ã®ã§ã€ã“ã“ã§ã¯æç”»ã ã‘
    renderCenterPieces();
  }

function renderCenterPieces(){
  const rNow = currentRound();
  const dr = state?.dragging?.round;
  const did = state?.dragging?.id;
  if (dr && state.centerPieces?.[dr]?.[did]?.lockBy === state.uid) return;

  centerPiece.innerHTML = '';

  // 1ã€œç¾åœ¨ãƒ©ã‚¦ãƒ³ãƒ‰ã¾ã§ã‚’æç”»å¯¾è±¡ã«
  const rounds = Object.keys(state.centerPieces || {})
    .map(Number)
    .filter(r => r >= 1 && r <= rNow)
    .sort((a,b)=> a-b);

  // [round, id, obj, z2] ã®é…åˆ—ã‚’ä½œæˆï¼ˆz2 = round*1000 + zï¼‰
  const entries = [];
  for (const r of rounds){
    const data = state.centerPieces[r] || {};
    for (const [id,obj] of Object.entries(data)){
      const z2 = (r * 1000) + (obj.z || 0);
      entries.push([r, id, obj, z2]);
    }
  }

  // ãƒ©ã‚¦ãƒ³ãƒ‰ã‚‚è€ƒæ…®ã—ãŸ z2 ã§å®‰å®šã‚½ãƒ¼ãƒˆ
  entries.sort((a,b)=> a[3] - b[3]);

  // ç¾åœ¨ãƒ©ã‚¦ãƒ³ãƒ‰ã®ã¿æ“ä½œå¯
  for (const [r, id, obj] of entries){
    const interactive = (r === rNow);
    drawPieceEl(r, id, obj, interactive);
  }
}


function drawPieceEl(round, id, obj, interactive = true){
  const el = document.createElement('div');
  el.className = `piece ${obj.color||''}`;
  el.dataset.id = id;

  el.style.setProperty('--w', obj.w);
  el.style.setProperty('--h', obj.h);

  const cell = cellSize();

  // ä¸­èº«ã®ãƒã‚¹ï¼ˆ.sqï¼‰ã‚’ç”Ÿæˆ
  const rel = Array.isArray(obj.rel) ? obj.rel : [];
  for (const pair of rel){
    const [r, c] = pair;
    const sq = document.createElement('div');
    sq.className = 'sq';
    sq.style.left = (c * cell) + 'px';
    sq.style.top  = (r * cell) + 'px';
    el.appendChild(sq);
  }
  {
    const { cx, cy } = pieceCenterCell(obj);
   el.style.transformOrigin = `${(cx + 0.5) * cell}px ${(cy + 0.5) * cell}px`;
  }
  // ä½ç½®ï¼‹å›è»¢/åè»¢
  const px = obj.x * cell;
  const py = obj.y * cell;
  const ang = obj.angle || 0;
  const sx = obj.flipX ? -1 : 1;
  const sy = obj.flipY ? -1 : 1;
  el.style.transform = `translate(${px}px, ${py}px) rotate(${ang}deg) scale(${sx}, ${sy})`;

  // ãƒ©ã‚¦ãƒ³ãƒ‰è·¨ãã®å‰é¢åˆ¶å¾¡
  el.style.zIndex = String((round * 1000) + (obj.z || 0));

  if (interactive){
    // å³ä¸Šãƒãƒ³ãƒ‰ãƒ«ï¼ˆâ‡”ï¼šå·¦å³åè»¢ã€â‡•ï¼šä¸Šä¸‹åè»¢ï¼‰
    const handles = document.createElement('div');
    handles.className = 'handles';

    const btnH = document.createElement('div'); btnH.className = 'handle'; btnH.textContent = 'â‡”';
    const btnV = document.createElement('div'); btnV.className = 'handle'; btnV.textContent = 'â‡•';

    [btnH, btnV].forEach(b=>{
      b.addEventListener('pointerdown', e=>{ e.stopPropagation(); e.preventDefault(); });
    });

btnH.addEventListener('click', async (e)=>{
  e.stopPropagation();
  const patch = { flipX: !obj.flipX };
  const pos   = computeXYForNewTransform(obj, patch);
  try{
    await update(piecePath(round,id), { ...patch, ...pos, updatedAt: Date.now() });
  }catch(_e){}
});

btnV.addEventListener('click', async (e)=>{
  e.stopPropagation();
  const patch = { flipY: !obj.flipY };
  const pos   = computeXYForNewTransform(obj, patch);
  try{
    await update(piecePath(round,id), { ...patch, ...pos, updatedAt: Date.now() });
  }catch(_e){}
});


    handles.appendChild(btnH);
    handles.appendChild(btnV);
    el.appendChild(handles);

    // ã‚¯ãƒªãƒƒã‚¯å›è»¢ï¼ˆç§»å‹•ãªã—ã®ã¿åˆ¤å®šï¼‰
 // ã‚¯ãƒªãƒƒã‚¯å›è»¢ï¼ˆç§»å‹•ãªã—ã®ã¿åˆ¤å®šï¼‰
let _down = null;
el.addEventListener('pointerdown', (e) => {
  if (e.button !== 0) return;
  _down = { x: e.clientX, y: e.clientY, t: performance.now() };
});

el.addEventListener('pointerup', async (e) => {
  // â˜… ãƒ‰ãƒ©ãƒƒã‚°ãŒç™ºç”Ÿã—ã¦ã„ãŸå ´åˆã¯å›è»¢ã•ã›ãªã„
  if (e.currentTarget?.dataset?.dragMoved === '1') {
    e.currentTarget.dataset.dragMoved = ''; // æ¬¡ã®æ“ä½œã®ãŸã‚ã‚¯ãƒªã‚¢
    _down = null;
    return;
  }

  if (!_down) return;
  const dx = Math.abs(e.clientX - _down.x);
  const dy = Math.abs(e.clientY - _down.y);
  const dt = performance.now() - _down.t;
  _down = null;

  // å°ç§»å‹•ï¼†çŸ­æ™‚é–“ â†’ ã‚¯ãƒªãƒƒã‚¯æ‰±ã„ï¼ˆå›è»¢ï¼‰
  if (dx < 4 && dy < 4 && dt < 300) {
const next  = (((obj.angle || 0) + 90) % 360);
const patch = { angle: next };
const pos   = computeXYForNewTransform(obj, patch);
try{
  await update(piecePath(round, id), { ...patch, ...pos, updatedAt: Date.now() });
} catch(_e){}
  }
}, { passive: true });


    // ãƒ‰ãƒ©ãƒƒã‚°
    el.addEventListener('pointerdown', (ev)=> onPiecePointerDown(ev, round, id, obj));
  }

  centerPiece.appendChild(el);
}

  // å‹è€…ã‚«ãƒ¼ãƒ‰ã‚¯ãƒªãƒƒã‚¯æ™‚ã«1å›ã ã‘ç”Ÿæˆï¼ˆæ—¢ã«å­˜åœ¨ã™ã‚Œã°ä½•ã‚‚ã—ãªã„ï¼‰
  async function spawnVictoryPieceOnce(){
    const g = state.game||{}; const vict = g.victory; if (!vict) return;
    const r = g.round || 1;
    const roundData = state.centerPieces?.[r] || {};
    // æ—¢ã«ã“ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã«ãƒ”ãƒ¼ã‚¹ãŒã‚ã‚‹ â†’ ä½•ã‚‚ã—ãªã„
    if (Object.keys(roundData).length) return;

    const shape = buildRelFromCard(vict.cardId);
    if (!shape.rel.length) return; // ç´«0ãªã©å½¢ç„¡ã—ã¯ç„¡è¦–
    // åˆæœŸé…ç½®ï¼šä¸­å¤®å¯„ã›
    const x0 = Math.max(0, Math.floor((12 - shape.w)/2));
    const y0 = Math.max(0, Math.floor((12 - shape.h)/2));
    const pid = vict.cardId.replace(/[^a-z0-9\-]/gi,'') + '-' + Date.now().toString(36);

    const obj = {
      id: pid, round: r, cardId: vict.cardId, color: vict.color, index: vict.index,
      rel: shape.rel, w: shape.w, h: shape.h,
      x: x0, y: y0, z: 1, lockBy: null,
      angle: 0,
      flipX: false, flipY: false,
      updatedAt: Date.now()    };
    await set(piecePath(r,pid), obj);
    // â˜… è¿½åŠ ï¼šã“ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã®å ´æœ­ã‚’å…¨ç«¯æœ«ã§éè¡¨ç¤ºã«ã™ã‚‹
    const room = `rooms/${state.code}`;
    await update(ref(db), { [`${room}/game/hiddenPlaysRound`]: r });
  }

  // ===== ãƒ‰ãƒ©ãƒƒã‚°å®Ÿè£…ï¼ˆã‚»ãƒ«ã‚¹ãƒŠãƒƒãƒ—ãƒ»åŒæœŸï¼‰ =====
  f// ===== ãƒ‰ãƒ©ãƒƒã‚°å®Ÿè£…ï¼ˆé…å»¶é–‹å§‹ï¼šç§»å‹•ãŒé–¾å€¤ã‚’è¶…ãˆãŸã‚‰ãƒ‰ãƒ©ãƒƒã‚°ï¼è¶…ãˆãªã‘ã‚Œã°ã‚¯ãƒªãƒƒã‚¯å›è»¢ï¼‰ =====
function clampXY(x, y, w, h){
  const maxX = 12 - w;
  const maxY = 12 - h;
  return { x: Math.max(0, Math.min(maxX, x)), y: Math.max(0, Math.min(maxY, y)) };
}


/* ===== è¿½åŠ : ä¸­å¿ƒã‚¢ãƒ³ã‚«ãƒ¼ï¼†ã¯ã¿å‡ºã—æŠ‘åˆ¶ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ===== */
function pieceCenterCell(obj){
  const cx = Math.floor(((obj?.w||1) - 1) / 2);
  const cy = Math.floor(((obj?.h||1) - 1) / 2);
  return { cx, cy };
}

function gridSizePx(){ return cellSize() * 12; }

function pieceWorldCenterPx(obj){
  const cell = cellSize();
  const { cx, cy } = pieceCenterCell(obj);
  return {
    cxPx: (obj.x + cx + 0.5) * cell,
    cyPx: (obj.y + cy + 0.5) * cell,
    oxPx: (cx + 0.5) * cell,
    oyPx: (cy + 0.5) * cell,
  };
}

function rotatedHalfExtentsPx(obj){
  const cell = cellSize();
  const wPx = (obj?.w||1) * cell;
  const hPx = (obj?.h||1) * cell;
  const th  = ((obj?.angle||0) % 360) * Math.PI/180;
  const c = Math.cos(th), s = Math.sin(th);
  return {
    halfW: (Math.abs(c)*wPx + Math.abs(s)*hPx) / 2,
    halfH: (Math.abs(s)*wPx + Math.abs(c)*hPx) / 2,
  };
}

function clampCenterPxToGrid(cxPx, cyPx, obj, overhangCells = 0){
  const { halfW, halfH } = rotatedHalfExtentsPx(obj);
  const W = gridSizePx(), H = W;
  const cell = cellSize();
  const margin = (overhangCells || 0) * cell; // â˜… è¿½åŠ : ã¯ã¿å‡ºã—è¨±å®¹ï¼ˆã‚»ãƒ«å˜ä½ï¼‰
  return {
    cxPx: Math.min(W - halfW + margin, Math.max(halfW - margin, cxPx)),
    cyPx: Math.min(H - halfH + margin, Math.max(halfH - margin, cyPx)),
  };
}


function xyFromWorldCenter(nextObj, cxPx, cyPx){
  const cell = cellSize();
  const { oxPx, oyPx } = pieceWorldCenterPx({ ...nextObj, x:0, y:0 });
  const x = Math.round((cxPx - oxPx) / cell);
  const y = Math.round((cyPx - oyPx) / cell);
  return { x, y };
}

function computeXYForNewTransform(oldObj, patch){
  const nextObj = { ...oldObj, ...patch };
  const { cxPx, cyPx } = pieceWorldCenterPx(oldObj);
  const clamped = clampCenterPxToGrid(cxPx, cyPx, nextObj);
  return xyFromWorldCenter(nextObj, clamped.cxPx, clamped.cyPx);
}

function pickMaxZ(r){
  const data = state.centerPieces?.[r] || {};
  let z = 0;
  for (const k in data){ z = Math.max(z, data[k]?.z||0); }
  return z;
}

function onPiecePointerDown(ev, round, id, obj){
  ev.preventDefault();
  const el = ev.currentTarget;

  // ã‚¯ãƒªãƒƒã‚¯ï¼ãƒ‰ãƒ©ãƒƒã‚°å€™è£œã®è¨˜éŒ²ï¼ˆã¾ã ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ã—ãªã„ï¼‰
  el.dataset.downX = String(ev.clientX);
  el.dataset.downY = String(ev.clientY);
  el.dataset.downT = String(performance.now());
  el.dataset.dragActive = '';  // ''=ã¾ã ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ã—ã¦ã„ãªã„

  // ä¸€æ™‚ãƒªã‚¹ãƒŠãƒ¼ã‚’ç™»éŒ²
  const move = (e)=> onPiecePointerMove(e, el, round, id, obj);
  const up   = (e)=> onPiecePointerUp(e, el, move, up, round, id, obj);
  el.addEventListener('pointermove', move);
  el.addEventListener('pointerup', up, { once:true });
  el.addEventListener('pointercancel', up, { once:true });
}

function beginDrag(el, ev, round, id, obj){
  el.setPointerCapture?.(ev.pointerId);
  el.classList.add('dragging');
  el.dataset.dragActive = '1';

  // ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹â†’ãƒ­ãƒƒã‚¯ï¼ˆç«¶åˆæŠ‘åˆ¶ï¼‰
  state.dragging.id = id;
  state.dragging.round = round;
  state.dragging.ownLock = true;
  update(piecePath(round,id), { lockBy: state.uid }).catch(()=>{});

  // ZæŒã¡ä¸Šã’ï¼ˆãƒ©ã‚¦ãƒ³ãƒ‰è€ƒæ…®ã®ä¸€è²«æ€§ï¼‰
  const nextZ = pickMaxZ(round) + 1;
  update(piecePath(round,id), { z: nextZ }).catch(()=>{});
  el.style.zIndex = String((round * 1000) + nextZ);

  // ãƒã‚¤ãƒ³ã‚¿ä½ç½®â†’è¦ç´ å·¦ä¸Šã‚ªãƒ•ã‚»ãƒƒãƒˆ
  const rect = el.getBoundingClientRect();
  state.dragging.offPx = { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
}

function onPiecePointerMove(ev, el, round, id, obj){
  // ã¾ã ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ã—ã¦ã„ãªã‘ã‚Œã°ã€ç§»å‹•é‡ã§åˆ¤å®š
  if (el.dataset.dragActive !== '1'){
    const dx = Math.abs(ev.clientX - Number(el.dataset.downX||0));
    const dy = Math.abs(ev.clientY - Number(el.dataset.downY||0));
    const DRAG_THRESHOLD = 4;  // px
    if (dx >= DRAG_THRESHOLD || dy >= DRAG_THRESHOLD){
      beginDrag(el, ev, round, id, obj);
    }else{
      return; // ã—ãã„å€¤æœªæº€ï¼ã¾ã ã‚¯ãƒªãƒƒã‚¯å€™è£œ
    }
  }

  // ã“ã“ã‹ã‚‰å®Ÿãƒ‰ãƒ©ãƒƒã‚°ä¸­
  if (!state.dragging.id) return;

  const r = state.dragging.round; const pid = state.dragging.id;
  const grid = getCenterRect();
  const cell = grid.width / 12;

  // â˜… ä¿®æ­£: å·¦ä¸Šã‚¢ãƒ³ã‚«ãƒ¼ã§ã¯ãªãã€Œä¸­å¿ƒã‚¢ãƒ³ã‚«ãƒ¼ï¼‹å›è»¢å¾Œå¤–æ¥çŸ©å½¢ã€ã§å¢ƒç•Œåˆ¤å®š
  const anchorPxX = ev.clientX - grid.left - state.dragging.offPx.x;
  const anchorPxY = ev.clientY - grid.top  - state.dragging.offPx.y;

  const cur = state.centerPieces?.[r]?.[pid] || obj;
  if (!cur) return;

  // ãƒ”ãƒ¼ã‚¹ä¸­å¿ƒã®ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆå·¦ä¸Šâ†’ä¸­å¿ƒï¼‰
  const { oxPx, oyPx } = pieceWorldCenterPx({ ...cur, x:0, y:0 });
  const wantCxPx = anchorPxX + oxPx;
  const wantCyPx = anchorPxY + oyPx;

  // 2ãƒã‚¹ã¾ã§ã¯ã¿å‡ºã—å¯èƒ½ã«ã—ã¦ä¸­å¿ƒã‚’ã‚¯ãƒªãƒƒãƒ—
  const clamped = clampCenterPxToGrid(wantCxPx, wantCyPx, cur, 2);

  // ã‚¯ãƒªãƒƒãƒ—ã—ãŸä¸­å¿ƒåº§æ¨™ã‹ã‚‰ã‚°ãƒªãƒƒãƒ‰å·¦ä¸Š(x,y)ã¸æˆ»ã™
  const { x, y } = xyFromWorldCenter(cur, clamped.cxPx, clamped.cyPx);

  if (state.dragging.raf) cancelAnimationFrame(state.dragging.raf);
  state.dragging.raf = requestAnimationFrame(async ()=>{
    // ãƒ­ãƒ¼ã‚«ãƒ«å³æ™‚åæ˜ ï¼ˆå›è»¢/åè»¢ã‚‚ç¶­æŒï¼‰
    const ang = cur.angle || 0;
    const sx = cur.flipX ? -1 : 1;
    const sy = cur.flipY ? -1 : 1;
    el.style.transform = `translate(${x*cell}px, ${y*cell}px) rotate(${ang}deg) scale(${sx}, ${sy})`;

    try{
      await update(piecePath(r,pid), { x, y, updatedAt: Date.now() });
    }catch(e){}
  });
}

function onPiecePointerUp(ev, el, move, up, round, id, obj){
  // ãƒªã‚¹ãƒŠãƒ¼è§£é™¤
  el.removeEventListener('pointermove', move);

  // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ãªã‚‰çµ‚äº†å‡¦ç†ï¼ˆå›è»¢ã¯ã—ãªã„ï¼‰
  if (el.dataset.dragActive === '1'){
    el.classList.remove('dragging');
    el.releasePointerCapture?.(ev.pointerId);

    const r = state.dragging.round; const pid = state.dragging.id;
    update(piecePath(r,pid), { lockBy: null, updatedAt: Date.now() }).catch(()=>{});
    state.dragging.id = null; state.dragging.round = null; state.dragging.ownLock = false;

    // ãƒ•ãƒ©ã‚°é¡ã‚¯ãƒªã‚¢
    el.dataset.dragActive = '';
    el.dataset.downX = ''; el.dataset.downY = ''; el.dataset.downT = '';
    return; // â† ã“ã“ã§çµ‚äº†ï¼ˆå›è»¢ã•ã›ãªã„ï¼‰
  }

  // ã“ã“ã«æ¥ã‚‹ã®ã¯ã€Œã‚¯ãƒªãƒƒã‚¯ã®ã¿ã€
  const downT = Number(el.dataset.downT||0);
  const dt = performance.now() - downT;
  const dx = Math.abs(ev.clientX - Number(el.dataset.downX||0));
  const dy = Math.abs(ev.clientY - Number(el.dataset.downY||0));

  // ã‚¯ãƒªã‚¢
  el.dataset.dragActive = '';
  el.dataset.downX = ''; el.dataset.downY = ''; el.dataset.downT = '';

  // ã‚¯ãƒªãƒƒã‚¯ã¨ã¿ãªã™æ¡ä»¶ï¼ˆå°ç§»å‹•ï¼†çŸ­æ™‚é–“ï¼‰
  if (dx < 4 && dy < 4 && dt < 300) {
    const next = (((obj.angle || 0) + 90) % 360);
    const baseW = obj.w || 1, baseH = obj.h || 1;
    const rotW = (next % 180 === 0) ? baseW : baseH;
    const rotH = (next % 180 === 0) ? baseH : baseW;
    const x = Math.min(obj.x, 12 - rotW);
    const y = Math.min(obj.y, 12 - rotH);
    update(piecePath(round, id), { angle: next, x, y, updatedAt: Date.now() }).catch(()=>{});
  }
}



  // === ä¸­å¤®ãƒ”ãƒ¼ã‚¹ã® onValue ã§ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‰ãƒ©ãƒƒã‚°ã¨ç«¶åˆã—ãªã„ã‚ˆã†ã«åæ˜  ===
  onValue(ref(db, ()=>{})); // no-op to keep module import tree-shake happy

  // æ—¢ã« wireRoom å†…ã§ centerPieces å…¨ä½“ã‚’è³¼èª­ã—ã¦ã„ã‚‹ã®ã§ã€
  // renderCenterPieces() å†…ã§æ¯å›DOMã‚’ä½œã‚Šç›´ã—ã€‚è‡ªåˆ†ãŒãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®è¦ç´ ã¯
  // lockBy===uid ã®é–“ã¯ DB å¤‰æ›´ã‚’ç„¡è¦–ï¼ˆdrawPieceEl ã¯éƒ½åº¦ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã‚’è¦‹ãªã„è¨­è¨ˆãªã®ã§
  // ã“ã“ã§ã‚¬ãƒ¼ãƒ‰ã™ã‚‹ä»£ã‚ã‚Šã«ã€move ã§å³ãƒ­ãƒ¼ã‚«ãƒ«ã«åæ˜ â†’updateã§ä»–ç«¯æœ«ã¸ï¼‰
  // â€»å¿…è¦ååˆ†ãªãŸã‚ç°¡æ½”ã•ã‚’å„ªå…ˆ

  // =========================

  // ========= ç›¸å¯¾é…ç½®è£œåŠ© =========
  function seatedList(){ return Object.entries(state.seats).filter(([_,v])=>v && v.uid).map(([k,v])=>({ seat:Number(k), uid:v.uid, name:v.name||'?' })).sort((a,b)=>a.seat-b.seat); }

  // ========= åˆæœŸè¡¨ç¤º =========
  function init(){ updateHeader(); }
  init();
</script>
</body>
</html>
